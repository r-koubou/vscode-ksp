KSP Reference Manual
Table of Contents
1. Disclaimer
.................................................................................................................. 1

2. Callbacks
................................................................................................................... 2

2.1. General Information
.......................................................................................... 2

2.2. on async_complete
........................................................................................... 2

2.3. on controller
..................................................................................................... 3

2.4. on init ............................................................................................................... 4

2.5. on listener
........................................................................................................ 6

2.6. on note ............................................................................................................ 7

2.7. on persistence_changed
................................................................................... 7

2.8. on pgs_changed
............................................................................................... 8

2.9. on poly_at ........................................................................................................ 9

2.10. on release
.................................................................................................... 10

2.11. on rpn/nrpn
................................................................................................... 10

2.12. on ui_control()
............................................................................................... 11

2.13. on ui_update
................................................................................................ 12

3. Variables
.................................................................................................................. 13

3.1. General Information
........................................................................................ 13

3.2. $ (int variable)
................................................................................................ 13

3.3. % (int array) ................................................................................................... 14

3.4. ~ (real variable)
.............................................................................................. 14

3.5. ? (real array)
.................................................................................................. 15

3.6. @ (string variable)
.......................................................................................... 16

3.7. ! (string array) ................................................................................................. 17

3.8. const $ (constant integer) ................................................................................ 18

3.9. const ~ (real constant) .................................................................................... 18

3.10. polyphonic $ (polyphonic integer)
................................................................... 19

3.11. make_instr_persistent()
................................................................................. 20

3.12. make_persistent()
......................................................................................... 20

3.13. read_persistent_var()
.................................................................................... 21

3.14. watch_var())
................................................................................................. 22

3.15. watch_array_idx()
......................................................................................... 23

4. User Interface Controls ............................................................................................. 25

4.1. ui_button
........................................................................................................ 25

4.2. ui_knob
.......................................................................................................... 25

4.3. ui_file_selector
............................................................................................... 27

4.4. ui_label
.......................................................................................................... 28

4.5. ui_level_meter
................................................................................................ 29

4.6. ui_menu
......................................................................................................... 30

4.7. ui_panel
......................................................................................................... 30

4.8. ui_slider
......................................................................................................... 31

4.9. ui_switch
........................................................................................................ 32

4.10. ui_table
........................................................................................................ 33

4.11. ui_text_edit
................................................................................................... 33

4.12. ui_value_edit
................................................................................................ 34

4.13. ui_waveform
................................................................................................. 35

4.14. ui_wavetable
................................................................................................ 35

4.15. ui_xy
............................................................................................................ 36

5. Control Statements
................................................................................................... 39

5.1. if�celse�cend if ............................................................................................... 39

5.2. select() .......................................................................................................... 39

5.3. while()
............................................................................................................ 40

5.4. Boolean Operators
......................................................................................... 40

6. Arithmetic Commands & Operators
............................................................................ 42

6.1. Basic Operators .............................................................................................. 42

6.2. Integer Operators & Commands
...................................................................... 42

6.3. Real Number Commands
................................................................................ 42

6.4. Rounding Commands
..................................................................................... 43

6.5. Trigonometric Commands
............................................................................... 43

6.6. Bit Operators
.................................................................................................. 43

6.7. random()
........................................................................................................ 44

6.8. int_to_real() .................................................................................................... 44

6.9. real_to_int()
.................................................................................................... 45

6.10. msb() ........................................................................................................... 45

6.11. lsb() ............................................................................................................. 46

7. General Commands
.................................................................................................. 47

7.1. disable_logging()
............................................................................................ 47

7.2. exit ................................................................................................................ 47

7.3. ignore_controller
............................................................................................. 48

7.4. message()
...................................................................................................... 48

7.5. note_off() ....................................................................................................... 49

7.6. play_note()
..................................................................................................... 50

7.7. set_controller()
............................................................................................... 51

7.8. set_rpn()/set_nrpn
.......................................................................................... 52

7.9. set_snapshot_type()
....................................................................................... 52

8. Event Commands
..................................................................................................... 54

8.1. by_marks()
..................................................................................................... 54

8.2. change_note()
................................................................................................ 54

8.3. change_pan()
................................................................................................. 55

8.4. change_tune()
................................................................................................ 56

8.5. change_velo()
................................................................................................ 57

8.6. change_vol()
.................................................................................................. 57

8.7. delete_event_mark()
....................................................................................... 58

8.8. event_status() ................................................................................................ 59

8.9. fade_in() ........................................................................................................ 59

8.10. fade_out()
.................................................................................................... 60

8.11. get_event_ids()
............................................................................................. 61

8.12. get_event_par()
............................................................................................ 61

8.13. get_event_par_arr()
...................................................................................... 63

8.14. ignore_event()
.............................................................................................. 64

8.15. set_event_mark() .......................................................................................... 65

8.16. set_event_par()
............................................................................................ 66

8.17. set_event_par_arr()
...................................................................................... 67

9. Array Commands ...................................................................................................... 68

9.1. array_equal()
.................................................................................................. 68

9.2. num_elements()
............................................................................................. 68

9.3. search() ......................................................................................................... 69

9.4. sort() .............................................................................................................. 69

10. Group Commands
.................................................................................................. 71

10.1. allow_group()
............................................................................................... 71

10.2. disallow_group()
........................................................................................... 71

10.3. find_group()
.................................................................................................. 72

10.4. get_purge_state()
......................................................................................... 73

10.5. group_name()
............................................................................................... 73

10.6. purge_group()
.............................................................................................. 74

11. Time-Related Commands
........................................................................................ 76

11.1. change_listener_par()
................................................................................... 76

11.2. ms_to_ticks() ................................................................................................ 77

11.3. set_listener()  ................................................................................................ 77

11.4. stop_wait()
.................................................................................................... 78

11.5. reset_ksp_timer ............................................................................................ 79

11.6. ticks_to_ms() ................................................................................................ 80

11.7. wait() ............................................................................................................ 81

11.8. wait_ticks() ................................................................................................... 81

12. User Interface Commands
....................................................................................... 82

12.1. add_menu_item()
......................................................................................... 82

12.2. add_text_line()
.............................................................................................. 83

12.3. attach_level_meter()
..................................................................................... 83

12.4. attach_zone()
............................................................................................... 84

12.5. fs_get_filename()
.......................................................................................... 85

12.6. fs_navigate() ................................................................................................ 85

12.7. get_control_par()
.......................................................................................... 86

12.8. get_font_id() ................................................................................................. 86

12.9. get_menu_item_str()
..................................................................................... 87

12.10. get_menu_item_value()
............................................................................... 88

12.11. get_menu_item_visibility()
........................................................................... 89

12.12. get_ui_id()
.................................................................................................. 90

12.13. get_ui_wf_property()
................................................................................... 90

12.14. hide_part()
.................................................................................................. 91

12.15. load_performance_view()
............................................................................ 92

12.16. make_perfview
........................................................................................... 93

12.17. move_control()
........................................................................................... 94

12.18. move_control_px()
...................................................................................... 94

12.19. set_control_help()
....................................................................................... 95

12.20. set_control_par()
......................................................................................... 96

12.21. set_control_par_arr()
................................................................................... 96

12.22. set_knob_defval()
....................................................................................... 98

12.23. set_knob_label()
......................................................................................... 98

12.24. set_knob_unit()
........................................................................................... 99

12.25. set_menu_item_str()
.................................................................................. 100

12.26. set_menu_item_value()
.............................................................................. 101

12.27. set_menu_item_visibility()
.......................................................................... 102

12.28. set_table_steps_shown()
............................................................................ 103

12.29. set_script_title()
......................................................................................... 103

12.30. set_skin_offset()
........................................................................................ 104

12.31. set_text() ................................................................................................... 104

12.32. set_ui_color()
............................................................................................. 105

12.33. set_ui_height()
........................................................................................... 106

12.34. set_ui_height_px()
..................................................................................... 106

12.35. set_ui_width_px()
....................................................................................... 107

12.36. set_ui_wf_property()
.................................................................................. 107

13. Keyboard Commands
............................................................................................ 109

13.1. get_key_color()
............................................................................................ 109

13.2. get_key_name()
.......................................................................................... 110

13.3. get_key_triggerstate()
.................................................................................. 110

13.4. get_key_type()
............................................................................................. 111

13.5. get_keyrange_min_note()
............................................................................. 111

13.6. get_keyrange_max_note()
............................................................................ 112

13.7. get_keyrange_name()
.................................................................................. 112

13.8. set_key_color()
............................................................................................ 113

13.9. set_key_name()
........................................................................................... 115

13.10. set_key_pressed()
..................................................................................... 116

13.11. set_key_pressed_support()
......................................................................... 116

13.12. set_key_type()
........................................................................................... 117

13.13. set_keyrange()
.......................................................................................... 118

13.14. remove_keyrange()
.................................................................................... 119

14. Engine Parameter Commands
................................................................................ 121

14.1. find_mod()
................................................................................................... 121

14.2. find_target()
................................................................................................. 122

14.3. get_engine_par()
......................................................................................... 123

14.4. get_engine_par_disp()
................................................................................. 125

14.5. get_voice_limit()
.......................................................................................... 126

14.6. output_channel_name()
............................................................................... 127

14.7. set_engine_par()
......................................................................................... 128

14.8. set_voice_limit()
.......................................................................................... 130

15. Load/Save Commands
........................................................................................... 131

15.1. General Information
..................................................................................... 131

15.2. get_folder()
.................................................................................................. 131

15.3. load_array()
................................................................................................. 132

15.4. load_array_str()
........................................................................................... 134

15.5. load_ir_sample()
.......................................................................................... 136

15.6. save_array()
................................................................................................ 138

15.7. save_array_str() .......................................................................................... 138

15.8. save_midi_file()
........................................................................................... 140

16. MIDI Object Commands
......................................................................................... 142

16.1. General Information
..................................................................................... 142

16.2. mf_insert_file()
............................................................................................. 143

16.3. mf_set_export_area()
................................................................................... 144

16.4. mf_set_buffer_size()
.................................................................................... 145

16.5. mf_get_buffer_size()
.................................................................................... 146

16.6. mf_reset() ................................................................................................... 146

16.7. mf_insert_event() ......................................................................................... 147

16.8. mf_remove_event()
...................................................................................... 147

16.9. mf_set_event_par()
...................................................................................... 148

16.10. mf_get_event_par()
.................................................................................... 149

16.11. mf_get_id() ................................................................................................ 150

16.12. mf_set_mark() ........................................................................................... 150

16.13. mf_get_mark()
........................................................................................... 151

16.14. by_marks()
................................................................................................ 151

16.15. by_track() .................................................................................................. 152

16.16. mf_get_first()
............................................................................................. 152

16.17. mf_get_last() ............................................................................................. 153

16.18. mf_get_next()
............................................................................................ 153

16.19. mf_get_next_at() ........................................................................................ 154

16.20. mf_get_prev()
............................................................................................ 154

16.21. mf_get_prev_at() ....................................................................................... 155

16.22. mf_get_num_tracks()
................................................................................. 155

17. Built-in Variables and Constants
............................................................................. 157

17.1. General
....................................................................................................... 157

17.2. Events and MIDI .......................................................................................... 158

17.3. Transport and Timing
................................................................................... 161

17.4. Callbacks and UI
......................................................................................... 162

17.5. Mathemetical Constants
............................................................................... 164

18. Control Parameter Variables
................................................................................... 165

18.1. General ....................................................................................................... 165

18.2. Specific ....................................................................................................... 168

19. Engine Parameter Variables
................................................................................... 175

19.1. Instrument, Source and Amp Module
............................................................ 175

19.2. Insert Effects ............................................................................................... 177

19.3. Filter and EQ ............................................................................................... 181

19.4. Send Effects ................................................................................................ 183

19.5. Modulation
.................................................................................................. 187

19.6. Module Types and Subtypes
......................................................................... 188

19.7. Group Start Options Query ........................................................................... 193

20. Advanced Concepts
............................................................................................... 195

20.1. Preprocessor & System Scripts .................................................................... 195

20.2. PGS ............................................................................................................ 197

20.3. Zone and Slice Functions
............................................................................. 198

20.4. User defined Functions
................................................................................ 199

20.5. Resource Container
..................................................................................... 200

20.6. Changing FX from KSP ................................................................................ 201

20.7. The Advanced Engine Tab
........................................................................... 202

21. Multi Script
............................................................................................................ 204

21.1. General Information
..................................................................................... 204

21.2. ignore_midi
................................................................................................. 205

21.3. on midi_in
................................................................................................... 205

21.4. set_midi()
.................................................................................................... 206

21.5. Multi Script Variables
.................................................................................... 207

22. Version History
...................................................................................................... 209
22.1. KONTAKT 6.1.0
........................................................................................... 209
22.2. KONTAKT 6.0.2
........................................................................................... 209
22.3. KONTAKT 5.8.0 ........................................................................................... 210
22.4. KONTAKT 5.7 .............................................................................................. 210
22.5. KONTAKT 5.6.8 ........................................................................................... 210
22.6. KONTAKT 5.6.5 ........................................................................................... 210
22.7. KONTAKT 5.6
.............................................................................................. 211
22.8. KONTAKT 5.5
.............................................................................................. 211
22.9. KONTAKT 5.4.2 ........................................................................................... 211
22.10. KONTAKT 5.4.1 ......................................................................................... 211
22.11. KONTAKT 5.3
............................................................................................ 212
22.12. KONTAKT 5.2 ............................................................................................ 212
22.13. KONTAKT 5.1.1 ......................................................................................... 212
22.14. KONTAKT 5.1 ............................................................................................ 212
22.15. KONTAKT 5.0.2
......................................................................................... 212
22.16. KONTAKT 5.0.1
......................................................................................... 213
22.17. KONTAKT 5
.............................................................................................. 213
22.18. KONTAKT 4.2 ............................................................................................ 214
22.19. KONTAKT 4.1.2 ......................................................................................... 214
22.20. KONTAKT 4.1.1 ......................................................................................... 214
22.21. KONTAKT 4.1
............................................................................................ 215
22.22. KONTAKT 4.0.2 ......................................................................................... 215
22.23. KONTAKT 4 .............................................................................................. 215
22.24. KONTAKT 3.5 ............................................................................................ 216
22.25. KONTAKT 3 .............................................................................................. 216
22.26. KONTAKT 2.2 ............................................................................................ 217
22.27. KONTAKT 2.1.1
......................................................................................... 217

22.28. KONTAKT 2.1 ............................................................................................ 217
22.29. KONTAKT 2 .............................................................................................. 218

23. Index ..................................................................................................................... 219


1. DISCLAIMER
The information in this document is subject to change without notice and does not represent a commitment on the part of Native Instruments GmbH. The software described by this document is subject to a License Agreement and may not be copied to other media. No part of this publication may be copied, reproduced or otherwise transmitted or recorded, for any purpose, without prior written permission by Native Instruments GmbH, hereinafter referred to as Native Instruments.
�gNative Instruments�h, �gNI�h and associated logos are (registered) trademarks of Native Instruments GmbH.
Mac, macOS, GarageBand, Logic and iTunes are registered trademarks of Apple Inc., registered in the U.S. and other countries.
All other trademarks are the property of their respective owners and use of them does not imply any affiliation with or endorsement by them.
Document authored by: Adam Hanley, Nikolas Jeroma & Hannah Lockwood
Software version: 6.1.0 (05/2019)

2. CALLBACKS
2.1. General Information
.
A callback is a section within a script that is being "called" (i.e. executed) at certain times.

.
All callbacks start with on <callback-name> and end with end on.

.
Callbacks can be stopped by using the command exit.

.
Each callback has a unique ID number which can be retrieved with $NI_CALLBACK_ID

.
You can query which callback triggered a function with $NI_CALLBACK_TYPE and the corre-sponding built-in constants.


Examples
function show_callback_type if ($NI_CALLBACK_TYPE = $NI_CB_TYPE_NOTE)
 message("Function was called from note callback!") end if if ($NI_CALLBACK_TYPE = $NI_CB_TYPE_CONTROLLER)
 message("Function was called from controller callback!") end if end function
on note call show_callback_type end on
on controller call show_callback_type end on
Query the callback type in a function
See Also
exit
$NI_CALLBACK_ID
$NI_CALLBACK_TYPE

2.2. on async_complete
on async_complete
async complete callback, triggered after the execution of any load/save command
Remarks
To resolve synchronization issues, the commands mentioned above return unique IDs when being used. Upon completion of the command�fs action, the on async_complete callback gets triggered and the built-in variable $NI_ASYNC_ID is updated with the ID of the command that triggered the callback. If the command was completed successfully (for example if the file was found and suc-cessfully loaded), the internal value $NI_ASYNC_EXIT_STATUS is set to 1, otherwise it is 0.

Examples
on init declare $load_midi_file_id declare ui_button $load_midi_file
end on
on ui_control ($load_midi_file) $load_midi_file_id := load_midi_file(<midifile-path>) while ($load_midi_file_id # -1)
 wait (1) end while message ("MIDI file loaded")
end on on async_complete if ($NI_ASYNC_ID = $load_midi_file_id) $load_midi_file_id := -1 end if end on
Example that pauses the ui_control callback until the file is loaded

See Also
$NI_ASYNC_EXIT_STATUS
$NI_ASYNC_ID
Load/Save Commands


2.3. on controller
on controller
MIDI controller callback, executed whenever a CC, pitch bend or channel pressure message is received
Examples
on controller if (in_range($CC_NUM,0,127)) message("CC Number: "& $CC_NUM&" - Value: " & %CC[$CC_NUM]) else if ($CC_NUM = $VCC_PITCH_BEND) message("Pitchbend" & " - Value: " & %CC[$CC_NUM])
end if if ($CC_NUM = $VCC_MONO_AT) message("Channel Pressure" &" - Value: "&%CC[$CC_NUM]) end if end if end on
Query CC, pitch bend and channel pressure data

See Also
set_controller()
ignore_controller
%CC[]
$CC_NUM
$VCC_PITCH_BEND
$VCC_MONO_AT


2.4. on init
on init
Initialization callback, executed when the script was successfully analyzed
Remarks
The init callback will be executed when:
.
clicking the "Apply" button in the script editor

.
loading a script preset or an instrument

.
restarting KONTAKT's audio engine by clicking the restart button in the Monitor/Engine tab or the restart button in KONTAKT's header

.
loading a snapshot with set_snapshot_type() set to 0



Examples
on init
 declare ui_button $Sync
 declare ui_menu $time
 add_menu_item ($time,"16th",0)
 add_menu_item ($time,"8th",1)
 $Sync := 0 {sync is off by default, so hide menu}
 move_control ($time,0,0)
 move_control ($Sync,1,1)
 make_persistent ($Sync)
 make_persistent ($time)
 read_persistent_var ($Sync)
if ($Sync = 1) move_control ($time,2,1) else move_control ($time,0,0)
 end if end on on ui_control ($Sync)
 if ($Sync = 1) move_control ($time,2,1) else move_control ($time,0,0) end if end on
init callback with read_persistent_var()
on init declare ui_button $Sync move_control ($Sync,1,1) make_persistent ($Sync)
 declare ui_menu $time add_menu_item ($time,"16th",0) add_menu_item ($time,"8th",1) move_control ($time,0,0) make_persistent ($time)
end on
function show_menu if ($Sync = 1) move_control ($time,2,1) else move_control ($time,0,0) end if end function
on persistence_changed call show_menu end on
on ui_control ($Sync) call show_menu end on
The same script functionality, now with persistence_changed callback
See Also
make_persistent()
read_persistent_var()
on persistence_changed


2.5. on listener
on listener
Listener callback, executed at definable time intervals or whenever a transport command is received
Remarks
The listener callback is executed at time intervals defined with the set_listener() command. It can also react to the host's transport start and stop command. This makes it the ideal callback for anything tempo synced like sequencers, arpeggiators, midi file player etc.
. In some situations (like tempo changes within the host) ticks can be left out.

Examples
on init declare ui_knob $Test (0,99,1) declare $direction declare $tick_counter set_listener($NI_SIGNAL_TIMER_MS,10000)
end on
on listener if ($NI_SIGNAL_TYPE = $NI_SIGNAL_TIMER_MS) if ($direction = 0) inc($tick_counter) else dec($tick_counter) end if
 $Test := $tick_counter
 if ($tick_counter = 99)
 $direction := 1 end if if ($tick_counter = 0)
 $direction := 0 end if end if end on
Not useful as such, but nice to look at
See Also
set_listener()
change_listener_par()
$NI_SIGNAL_TYPE $NI_SONG_POSITION


2.6. on note
on note
Note callback, executed whenever a note on message is received
Examples
on note
 message("Note Nr: " & $EVENT_NOTE & " - Velocity: " & $EVENT_VELOCITY) end on
Query note data

See Also
on release ignore_event() set_event_par() get_event_par() $EVENT_NOTE $EVENT_VELOCITY $EVENT_ID


2.7. on persistence_changed
on persistence_changed
Executed after the init callback or whenever a snapshot has been loaded
Remarks
The on persistence_changed callback is called whenever the persistent variables change in an instrument, i.e. it is always executed after the init callback has been called and/or upon loading a snapshot.

Examples
on init
 set_snapshot_type(1) {init callback not executed upon snapshot loading} reset_ksp_timer
 declare $init_flag {1 if init callback has been executed, 0 otherwise} $init_flag := 1
declare ui_label $label (2,2)
 set_text($label,"init callback " & $KSP_TIMER) end on
function add_text
 add_text_line($label,"persistence_changed callback " & $KSP_TIMER) end function
on persistence_changed if ($init_flag = 1) {instrument has been loaded} call add_text else {snapshot has been loaded} set_text($label,"Snapshot loaded") end if
 $init_flag := 0 end on
Query if a snapshot or if an instrument has been loaded. This also demonstrates the ability to call functions upon initialization, i.e. the persistence callback acts as an extension to the init callback.

See Also
on init
read_persistent_var()
set_snapshot_type()


2.8. on pgs_changed
on pgs_changed
Executed whenever any pgs_set_key_val() command is executed in any script
Remarks
PGS stands for Program Global Storage and is a means of communication between script slots. See the chapter on PGS for more details.

Examples
on init
 pgs_create_key(FIRST_KEY, 1) {defines a key with 1 element}
 pgs_create_key(NEXT_KEY, 128){defines a key with 128 elements}
 declare ui_button $Push end on
on ui_control($Push) pgs_set_key_val(FIRST_KEY, 0,70 * $Push)
pgs_set_key_val(NEXT_KEY, 0, 50 * $Push) pgs_set_key_val(NEXT_KEY, 127, 60 * $Push) end on
Pressing the button...
on init declare ui_knob $First (0,100,1) declare ui_table %Next[128] (5,2,100)
end on
on pgs_changed
{checks if FIRST_KEY and NEXT_KEY have been declared}
 if(pgs_key_exists(FIRST_KEY) and pgs_key_exists(NEXT_KEY)) $First := pgs_get_key_val(FIRST_KEY,0) %Next[0] := pgs_get_key_val(NEXT_KEY,0) %Next[127] := pgs_get_key_val(NEXT_KEY,127)
 end if end on
�c will change the controls in this example, regardless of the script slot order

See Also
pgs_create_key()
pgs_set_key_val()
pgs_get_key_val()


2.9. on poly_at
on poly_at
Polyphonic aftertouch callback, executed whenever a polyphonic aftertouch message is received
Examples
on init declare %note_id[128] end on
on note %note_id[$EVENT_NOTE] := $EVENT_ID end on
on poly_at change_tune(%note_id[$POLY_AT_NUM],%POLY_AT[$POLY_AT_NUM]*1000,0) end on
A simple poly aftertouch to pitch implementation

See Also
%POLY_AT[]
$POLY_AT_NUM
$VCC_MONO_AT


2.10. on release
on release
Release callback, executed whenever a note off message is received
Examples
on init
 declare polyphonic $new_id end on
on release
 wait(1000)
 $new_id := play_note($EVENT_NOTE,$EVENT_VELOCITY,0,100000)
 change_vol ($new_id,-24000,1) end on
Creating an artificial release noise

See Also
on note
ignore_event()


2.11. on rpn/nrpn
on rpn/nrpn
rpn and nrpn callbacks, executed whenever a rpn or nrpn (registered/nonregistered parameter number) message is received
Examples
on rpn
 select ($RPN_ADDRESS)
 case 0
 message ("Pitch Bend Sensitivity"&" - Value: "& $RPN_VALUE)
 case 1
 message ("Fine Tuning" & " - Value: " & $RPN_VALUE)
 case 2
 message ("Coarse Tuning" & " - Value: " & $RPN_VALUE)
 end select end on
Query standard rpn messages

See Also
on controller
set_rpn/set_nrpn
msb()/lsb()
$RPN_ADDRESS
$RPN_VALUE


2.12. on ui_control()
on ui_control(<variable>)
UI callback, executed whenever the user changes the respective UI element
Examples
on init declare ui_knob $Knob (0,100,1) declare ui_button $Button declare ui_switch $Switch declare ui_table %Table[10] (2,2,100) declare ui_menu $Menu add_menu_item ($Menu,"Entry 1",0) add_menu_item ($Menu,"Entry 2",1) declare ui_value_edit $VEdit (0,127,1) declare ui_slider $Slider (0,100)
end on on ui_control ($Knob)
 message("Knob" & " (" & $ENGINE_UPTIME & ")") end on on ui_control ($Button)
 message("Button" & " (" & $ENGINE_UPTIME & ")") end on on ui_control ($Switch)
 message("Switch" & " (" & $ENGINE_UPTIME & ")") end on on ui_control (%Table)
 message("Table" & " (" & $ENGINE_UPTIME & ")") end on on ui_control ($Menu)
 message("Menu" & " (" & $ENGINE_UPTIME & ")") end on on ui_control ($VEdit)
 message("Value Edit" & " (" & $ENGINE_UPTIME & ")") end on on ui_control ($Slider)
message("Slider" & " (" & $ENGINE_UPTIME & ")") end on
Various UI controls and their corresponding callbacks

See Also
on ui_update


2.13. on ui_update
on ui_update
UI update callback, executed with every GUI change in KONTAKT
Remarks
This command is triggered with every GUI change in KONTAKT, so use it with caution.

Examples
on init declare ui_knob $Volume (0,1000000,1) set_knob_unit ($Volume,$KNOB_UNIT_DB) set_knob_defval ($Volume,630859) $Volume := _get_engine_par ($ENGINE_PAR_VOLUME,-1,-1,-1) set_knob_label ($Volume,_get_engine_par_disp... ($ENGINE_PAR_VOLUME,-1,-1,-1))
end on
on ui_update $Volume := _get_engine_par ($ENGINE_PAR_VOLUME,-1,-1,-1) set_knob_label($Volume,_get_engine_par_disp... ($ENGINE_PAR_VOLUME,-1,-1,-1))
end on
on ui_control ($Volume) _set_engine_par($ENGINE_PAR_VOLUME,$Volume,-1,-1,-1) set_knob_label ($Volume,_get_engine_par_disp... ($ENGINE_PAR_VOLUME,-1,-1,-1))
end on
Mirroring instrument volume with a KSP control
See Also
on ui_control()



3. VARIABLES
3.1. General Information
.
All user defined variables must be declared in the on init callback.

.
Variable names may contain only numbers, characters and the underscore ( _ ).

.
Variable names are case-sensitive.

.
Please do not create variables with the prefixes below, as these prefixes are used for internal variables and constants.


$NI_ $CONTROL_PAR_ $EVENT_PAR_ $ENGINE_PAR_

3.2. $ (int variable)
declare $<int variable>
Declare a user-defined variable to store a single integer value
Examples
on init declare $test $test := -1
end on
Creating a variable
on init declare $test := -1 end on
Creating a variable, the same as above but shorter

See Also
on init make_persistent() read_persistent_var() int_to_real() real_to_int()


3.3. % (int array)
declare %<array-name>[<num-of-elements>]
Declare a user-defined array to store single integer values at specific indices
Remarks
.
The maximal size of arrays is 1000000.

.
The number of elements must be defined with a constant value, a standard variable cannot be used.

.
It is possible to initialize an array with one value, see the second example below.



Examples
on init declare %presets[10*8] := (...
{1}  8,8,8,0,  0,0,0,0,...
 {2}  8,8,8,8,  0,0,0,0,...
 {3}  8,8,8,8,  8,8,8,8,...
 {4}  0,0,5,3,  2,0,0,0,...
 {5}  0,0,4,4,  3,2,0,0,...
 {6}  0,0,8,7,  4,0,0,0,...
 {7}  0,0,4,5,  4,4,2,2,...
 {8}  0,0,5,4,  0,3,0,0,...
 {9}  0,0,4,6,  7,5,3,0,...
 {10}  0,0,5,6,  4,4,3,2)
end on

Creating an array for storing preset data
on init
 declare %presets[10*8] := (4) end on
Quick way of initializing the same array with the value 4

See Also
Array and Group Commands make_persistent()


3.4. ~ (real variable)
declare ~<real variable>
Declare a user-defined variable to store a single real value
Remarks
. Real numbers should always be defined using a decimal, even if the number is a whole num-ber. For example 2.0 should be used instead of only 2.

Examples
on init declare ~test ~test := 0.5
end on
Creating a variable
on init declare ~test := 0.5 end on
Creating a variable, the same as above but shorter

See Also
on init
make_persistent()
read_persistent_var()
int_to_real()
real_to_int()


3.5. ? (real array)
declare ?<array-name>[<num-of-elements>]
Declare a user-defined array to store single real values at specific indices
Remarks
.
The maximal size of arrays is 1000000.

.
The number of elements must be defined with a constant integer value, a standard variable cannot be used.

.
It is possible to initialize an array with one value, see the second example below.

.
The commands array_equal() and search() do not work with arrays of real numbers.



Examples
on init declare ?presets[5*4] := (... {1} 1.0, 1.0, 1.0, 1.0,... {2} 0.5, 0.7, 0.1, 0.5,...
{3}  1.0, 0.6, 0.6, 0.2,...
 {4}  0.0, 0.0, 0.5, 0.3,...
 {5}  0.0, 1.0, 0.4, 0.1)
end on

Creating an array for storing preset data
on init
 declare ?presets[10*8] := (1.0) end on
Quick way of initializing the same array with the value 1.0

See Also
Array and Group Commands
make_persistent()


3.6. @ (string variable)
declare @<variable-name>
Declare a user-defined string variable to store text
Remarks
.
You cannot declare and define a string variable in the same line of code as you can with an integer variable.

.
It is possible to make string variables persistent.



Examples
on init
 declare @text
 @text := "Last received note number played or released: " end on
on note
 message(@text & $EVENT_NOTE) end on
on release
 message(@text & $EVENT_NOTE) end on
Use string variables to display long text
See Also
!(string array)
ui_text_edit
make_persistent()


3.7. ! (string array)
declare !<array-name>[<num-of-elements>]
Declare a user-defined string array to store text strings at specified indices
Remarks
.
The maximal size of arrays is 1000000.

.
Just like with string variables, the contents of a string array cannot be defined on the same line as the declaration.

.
String arrays cannot be made persistent.



Examples
on init declare $count
 declare !note[12] !note[0] := "C" !note[1] := "Db" !note[2] := "D" !note[3] := "Eb" !note[4] := "E" !note[5] := "F" !note[6] := "Gb" !note[7] := "G" !note[8] := "Ab" !note[9] := "A" !note[10] := "Bb" !note[11] := "B"
 declare !name [128]
 while ($count < 128) !name[$count] := !note[$count mod 12] & (($count/12)-2) inc ($count) end while
end on
on note message("Note played: " & !name[$EVENT_NOTE])
end on
Creating a string array with all MIDI note names

See Also
@ (string variable)


3.8. const $ (constant integer)
declare const $<variable-name>
Declare a user-defined constant to store a single integer value
Remarks
.
As the name implies, the value of constant variables can only be read, not changed.

.
It is quite common to capitalize the names of constants.



Examples
on init declare const $NUM_OF_PRESETS := 10 declare const $NUM_OF_PARAMETERS := 5
 declare %preset_data[$NUM_OF_PRESETS * $NUM_OF_PARAMETERS]
end on
Creating constants . useful when creating preset arrays

See Also
on init


3.9. const ~ (real constant)
declare const ~<variable-name>
Declare a user-defined constant to store a single real value
Remarks
.
As the name implies, the value of constant variables can only be read, not changed.

.
It is quite common to capitalize the names of constants.



Examples
on init declare const ~BIG_NUMBER := 100000.0 declare const ~SMALL_NUMBER := 0.00001
end on

See Also
on init


3.10. polyphonic $ (polyphonic integer)
declare polyphonic $<variable-name>
Declare a user-defined polyphonic variable to store a single integer value per note event
Remarks
.
A polyphonic variable acts as a unique variable for each executed note event, avoiding con-flicts in callbacks that are executed in parallel for example when using wait().

.
A polyphonic variable retains its value in the release callback of the corresponding note.

.
Polyphonic variables need much more memory than normal variables.

.
Polyphonic variables should only be used in note and release callbacks.



Examples
on init declare polyphonic $a {declare $a}
end on
on note ignore_event($EVENT_ID) $a:= 0 while ($a < 13 and $NOTE_HELD = 1) play_note($EVENT_NOTE+$a,$EVENT_VELOCITY,0,$DURATION_QUARTER/2)
 inc($a) wait($DURATION_QUARTER) end while end on
To hear the effect of the polyphonic variable, play and hold an octave: both notes will ascend chro-matically. Then make $a a normal variable and play the octave again: $a will be shared by both executed callbacks, thus both notes will ascend in larger intervals.
on init declare $counter declare polyphonic $polyphonic_counter
end on
on note message($polyphonic_counter & " " & $counter) inc($counter) inc($polyphonic_counter)
end on
Since a polyphonic variable is always unique per callback, $polyphonic_counter will always be 0 in the displayed message


3.11. make_instr_persistent()
make_instr_persistent(<variable>)
Retain the value of a variable only with the instrument
Remarks
make_instr_persistent() is similar to make_persistent(), however the value of a varia-ble is only saved with the instrument, not with snapshots. It can be used to prevent UI elements from being changed when loading snapshots.

Examples
on init
 set_snapshot_type(1) {init callback not executed upon snapshot loading}
 declare ui_knob $knob_1 (0,2,1) set_text($knob_1,"Pers.") make_persistent($knob_1)
 declare ui_knob $knob_2 (0,2,1) set_text($knob_2,"Inst Pers.") make_instr_persistent ($knob_2)
 declare ui_knob $knob_3 (0,2,1) set_text($knob_3,"Not Pers.")
end on
The second knob will not be changed when loading snapshots
See Also
read_persistent_var()
make_persistent()
set_snapshot_type()


3.12. make_persistent()
make_persistent(<variable>)
Retain the value of a variable with the instrument and snapshot
Remarks
.
The state of the variable is saved not only with the patch (or multi or host chunk), but also when a script is saved as a KONTAKT preset (.nkp file).

.
The state of the variables is read at the end of the init callback. To load a stored value manually within the init callback, use read_persistent_var().

.
You can also use the on persistence callback for retrieving the values of persistent varia-bles

.
When replacing script code by copy and replacing the text, the values of persistent variables are also retained.

.
Sometimes, when working on more complex scripts, you'll want to "flush" the variables by re-setting the script. You can do this by applying an empty script in the respective slot.



Examples
on init declare ui_knob $Preset (1,10,1) make_persistent ($Preset)
end on
User interface elements, such as knobs, should usually retain their value when reloading the in-strument

See Also
read_persistent_var()
on persistence_changed
make_instr_persistence()


3.13. read_persistent_var()
read_persistent_var(<variable>)
Instantly reloads the value of a variable that was saved via the make_persistent() command
Remarks
.
This command can only be used within the init callback.

.
The state of the variable is saved not only with the patch (or multi or host chunk), but also when a script is saved as a KONTAKT preset (.nkp file).

.
When replacing script code by copy and replacing the text, the values of persistent variables is also retained.

.
When working on more complex scripts, you might want to "flush" the variables by resetting the script. You can do this by applying an empty script in the respective slot.

.
You can also use the on persistence callback for retrieving the values of persistent varia-bles.



Examples
on init declare ui_label $label (1,1) declare ui_button $button set_text($button,"$a := 10000")
 declare $a make_persistent($a) {read_persistent_var($a)} set_text ($label,$a)
end on
on ui_control ($button) $a := 10000 set_text($label,$a)
end on
After applying this script, click on the button and then save and close the NKI. After reloading it, the label will display 0 because the value of $a is initialized at the very end of the init callback. Now remove the {} around read_persistent_var and apply the script again.

See Also
make_persistent()
on persistence_changed


3.14. watch_var())
 watch_var(<variable>)
sends an event to the Creator Tools Debugger for every change of the watched array cell�fs value
Remarks
.
This command can only be used within the init callback.

.
This command has no effect on Kontakt�fs Status Bar . the events only appear on Creator Tools.

.
This command does not work with built-in variables



Examples
on init declare $intVar watch_var($intVar) make_persistent($intVar)
end on
on note $intVar := $EVENT_VELOCITY end on
Try playing some notes while having Creator Tools running. Make sure you have the Variable Watching panel of the Debugger tool open.


3.15. watch_array_idx()
watch_array_idx(<array>, <array_idx>)
sends an event to the Creator Tools Debugger for every change of the watched array cell�fs value
Remarks
.
This command can only be used within the init callback.

.
This command has no effect on Kontakt�fs Status Bar . the events only appear on Creator Tools.

.
This command does not work with built-in arrays



Examples
on init declare %mykeys[128] watch_array_idx(%mykeys,60) watch_array_idx(%mykeys,61) watch_array_idx(%mykeys,62) watch_array_idx(%mykeys,63) watch_array_idx(%mykeys,64)
 declare ui_button $save
 declare ui_button $load end on
on note
%mykeys[$EVENT_NOTE] := $EVENT_VELOCITY end on
on ui_control($save) save_array(%mykeys,0) end on
on ui_control($load) load_array(%mykeys,0)
end on
Try playing some notes or clicking on the save and load buttons while having Creator Tools run-ning. Make sure you have the Variable Watching panel of the Debugger tool open.



4. USER INTERFACE CONTROLS
4.1. ui_button
declare ui_button $<variable-name>
Create a user interface button
Remarks
.
A button, i.e. its callback, is triggered when releasing the mouse (mouse-up).

.
A button cannot be automated.



Examples
on init declare ui_button $free_sync_button $free_sync_button := 1 set_text ($free_sync_button,"Sync") make_persistent ($free_sync_button)
 read_persistent_var($free_sync_button) if ($free_sync_button = 0) set_text ($free_sync_button,"Free") else set_text ($free_sync_button,"Sync") end if end on
on ui_control ($free_sync_button) if ($free_sync_button = 0) set_text ($free_sync_button,"Free") else set_text ($free_sync_button,"Sync") end if end on
A simple free/sync button implementation

See Also
ui_switch


4.2. ui_knob
declare ui_knob $<variable-name>(<min>,<max>,<display-ratio>)
Create a user interface knob
<min>  The minimum value of the knob
<max>  The maximum value of the knob
<display-ratio>  The knob value is divided by <display-ratio> for
display purposes

Examples
on init declare ui_knob $Knob_1 (0,1000,1) declare ui_knob $Knob_2 (0,1000,10) declare ui_knob $Knob_3 (0,1000,100) declare ui_knob $Knob_4 (0,1000,20) declare ui_knob $Knob_5 (0,1000,-10)
end on
Various display ratios
on init declare $count declare !note_class[12] !note_class[0] := "C" !note_class[1] := "Db" !note_class[2] := "D" !note_class[3] := "Eb" !note_class[4] := "E" !note_class[5] := "F" !note_class[6] := "Gb" !note_class[7] := "G" !note_class[8] := "Ab" !note_class[9] := "A" !note_class[10] := "Bb" !note_class[11] := "B" declare !note_names [128] while ($count < 128) !note_names[$count] := !note_class[$count mod 12] & (($count/12)-2) inc ($count) end while
 declare ui_knob $Note (0,127,1) set_knob_label ($Note,!note_names[$Note]) make_persistent ($Note)
 read_persistent_var($Note)
 set_knob_label ($Note,!note_names[$Note])
end on
on ui_control ($Note) set_knob_label ($Note,!note_names[$Note])
end on
Knob displaying MIDI note names

4.3. ui_file_selector
declare ui_file_selector $<variable-name>
Create a file selector
Remarks
Only three file selectors can be applied per script slot.

Examples
(See next page)
on init set_ui_height(5)
 declare @basepath {set browser path here, for example @basepath := "/Users/username/Desktop/MIDI Files/"}
 declare @file_name declare @file_path
 declare ui_file_selector $file_browser declare $browser_id $browser_id := get_ui_id($file_browser)
 set_control_par_str($browser_id,$CONTROL_PAR_BASEPATH,@basepath) set_control_par($browser_id,$CONTROL_PAR_FILE_TYPE,$NI_FILE_TYPE_MIDI) set_control_par($browser_id,$CONTROL_PAR_COLUMN_WIDTH,180) set_control_par($browser_id,$CONTROL_PAR_HEIGHT,170) set_control_par($browser_id,$CONTROL_PAR_WIDTH,550) move_control_px($file_browser,66,2)
 declare ui_button $prev declare ui_button $next move_control($prev,5,1) move_control($next,6,1)
 declare $load_mf_id $load_mf_id := -1
end on on async_complete
 if ($NI_ASYNC_ID = $load_mf_id) $load_mf_id := -1 if ($NI_ASYNC_EXIT_STATUS = 0)
message("MIDI file not found!") else message("Loaded MIDI File: " & @file_name) end if
 end if
end on
on ui_control ($file_browser) @file_name := fs_get_filename($browser_id,0) @file_path := fs_get_filename($browser_id,2) $load_mf_id := load_midi_file(@file_path)
end on
on ui_control ($prev) fs_navigate($browser_id,0) @file_name := fs_get_filename($browser_id,0) @file_path := fs_get_filename($browser_id,2) $load_mf_id := load_midi_file(@file_path) $prev := 0
end on
on ui_control ($next) fs_navigate($browser_id,1) @file_name := fs_get_filename($browser_id,0) @file_path := fs_get_filename($browser_id,2) $load_mf_id := load_midi_file(@file_path) $next := 0
end on
Loading MIDI files via UI file selector


4.4. ui_label
declare ui_label $<variable-name> (<width>,<height>)
Create a user interface text label
<width> The width of the label in grid units
<height> The height of the label in grid units
Examples
on init
 declare ui_label $label_1 (1,1)
 set_text ($label_1,"Small Label")
 declare ui_label $label_2 (3,6)
 set_text ($label_2,"Big Label")
 add_text_line ($label_2,"�cwith a second text line") end on
Two labels with different sizes
on init
 declare ui_label $label_1 (1,1)
 set_text ($label_1,"Small Label")
 hide_part ($label_1,$HIDE_PART_BG) end on
Hide the background of a label (also possible with other UI elements)

See Also
set_text() add_text_line() hide_part()


4.5. ui_level_meter
declare ui_level_meter $<variable-name>
Create a level meter
Remarks
. The level meter can only be attached to the output levels of buses or the instrument master.

Examples
on init
 declare ui_level_meter $Level1
 declare ui_level_meter $Level2
 attach_level_meter (get_ui_id($Level1),-1,-1,0,-1)
 attach_level_meter (get_ui_id($Level2),-1,-1,1,-1) end on
Creating two volume meters, with each displaying one channel of KONTAKT�fs instrument output

See Also
$CONTROL_PAR_BG_COLOR $CONTROL_PAR_OFF_COLOR $CONTROL_PAR_ON_COLOR $CONTROL_PAR_OVERLOAD_COLOR $CONTROL_PAR_PEAK_COLOR $CONTROL_PAR_VERTICAL attach_level_meter()


4.6. ui_menu
declare ui_menu $<variable-name>
Create a user interface drop-down menu
Examples
on init declare ui_menu $menu add_menu_item ($menu, "First Entry",0) add_menu_item ($menu, "Second Entry",1) add_menu_item ($menu, "Third Entry",2)
end on
A simple menu
on init declare $count declare ui_menu $menu
 $count := 1
 while ($count < 17) add_menu_item ($menu, "Entry Nr: " & $count,$count) inc ($count)
 end while end on
Quickly create a menu with many entries
See Also
add_menu_item()
get_menu_item_str()
get_menu_item_value()
get_menu_item_visibility()
set_menu_item_str()
set_menu_item_value()
set_menu_item_visibility()

4.7. ui_panel
declare ui_panel $<variable-name>
Create a user interface panel
Remarks
A panel is a control that can contain one or multiple controls. Unlike the rest of the controls, panels don�ft have size. They are very useful for grouping controls that are meant to be handled together. Then one can simultaneously modify the Show, Position or zLayer property of all the controls con-tained in that panel. The position of a contained control is relative to the panel�fs position. This means that the control�fs (0,0) position is the current (x,y) position of the panel.
Panels can be nested, so they can contain other panels. If panelA is contained in panelB, then panelA will appear in front of panelB. This is because children panels have a higher zLayer value than their parent panels. One could use this logic to easily create hierarchies in a performance view.

Examples
on init declare ui_panel $mixer declare ui_knob $volume(0,300,1) set_control_par(get_ui_id($volume),$CONTROL_PAR_PARENT_PANEL,get_ui_id($mixer))
end on
Adds the volume knob in the mixer panel

See Also
$CONTROL_PAR_PARENT_PANEL


4.8. ui_slider
declare ui_slider $<variable-name> (<min>,<max>)
Create a user interface slider
<min> The minimum value of the slider
<max> The maximum value of the slider
Examples
on init declare ui_slider $test (0,100) set_control_par(get_ui_id($test),$CONTROL_PAR_DEFAULT_VALUE,50)
end on
Slider with default value
on init declare ui_slider $test (-100,100) $test := 0 declare $id $id := get_ui_id($test)
 set_control_par($id,$CONTROL_PAR_MOUSE_BEHAVIOUR,2000)
set_control_par($id,$CONTROL_PAR_DEFAULT_VALUE,0) set_control_par_str($id,$CONTROL_PAR_PICTURE,"K4_SLIDER_BIP_1") end on
Creating a bipolar slider by loading a different picture background

See Also
ui_knob
set_control_par()
$CONTROL_PAR_MOUSE_BEHAVIOUR


4.9. ui_switch
declare ui_switch $<variable-name>
Create a user interface switch
Remarks
.
A switch, i.e. its callback, is triggered when clicking the mouse (mouse-down).

.
A switch can be automated.



Examples
on init declare ui_switch $rec_button set_text ($rec_button,"Record") declare $rec_button_id $rec_button_id:= get_ui_id ($rec_button)
 set_control_par ($rec_button_id,$CONTROL_PAR_WIDTH,60) set_control_par ($rec_button_id,$CONTROL_PAR_HEIGHT,20)
 set_control_par ($rec_button_id,$CONTROL_PAR_TEXT_ALIGNMENT,1)
 set_control_par ($rec_button_id,$CONTROL_PAR_POS_X,250) set_control_par ($rec_button_id,$CONTROL_PAR_POS_Y,5)
end on
Switch with various settings utilizing set_control_par()
See Also
ui_button


4.10. ui_table
declare ui_table %<array>[columns] (<width>,<height>,<range>)
Create a user interface table
<width> The width of the table in grid units
<height> The height of the table in grid units
<range> The range of the table. If negative values are used, a bipo-lar table is created.
Examples
on init declare ui_table %table_uni[10] (2,2,100) declare ui_table %table_bi[10] (2,2,-100)
end on
Unipolar and bipolar tables
on init declare ui_table %table[128] (5,2,100) declare ui_value_edit $Steps (1,127,1) $Steps := 16 set_table_steps_shown (%table,$Steps)
end on on ui_control ($Steps) set_table_steps_shown (%table,$Steps) end on
Changes the amount of shown steps (columns) in a table
See Also
set_table_steps_shown()
$NI_CONTROL_PAR_IDX

4.11. ui_text_edit
declare ui_text_edit @<variable-name>
Create a text edit field
Examples
on init
 declare ui_text_edit @label_name make_persistent(@label_name)
set_control_par_str(get_ui_id(@label_name),$CONTROL_PAR_TEXT,"empty")
set_control_par(get_ui_id(@label_name),$CONTROL_PAR_FONT_TYPE,25) set_control_par(get_ui_id(@label_name),$CONTROL_PAR_POS_X,73) set_control_par(get_ui_id(@label_name),$CONTROL_PAR_POS_Y,2)
 declare ui_label $pattern_lbl(1,1) set_text($pattern_lbl,"") move_control_px($pattern_lbl,66,2)
end on
on ui_control (@label_name) message(@label_name & " it is!") end on
A text edit field on top of a label

See Also
@ (string variable)


4.12. ui_value_edit
declare ui_value_edit $<varia-ble>(<min>,<max>,<$display-ratio>)
Create a user interface number box
<min> The minimum value of the value edit
<max> The maximum value of the value edit
<display-ratio> The value is divided by <display-ratio> for display purposes
You can also use $VALUE_EDIT_MODE_NOTE_NAMES to display note names instead of numbers.
Examples
on init declare ui_value_edit $test (0,100,$VALUE_EDIT_MODE_NOTE_NAMES) set_text ($test,"") set_control_par (get_ui_id($test),$CONTROL_PAR_WIDTH,45) move_control_px($test,66,2)
end on
on note $test := $EVENT_NOTE end on
Value edit displaying note names
on init declare ui_value_edit $test (0,10000,1000) set_text ($test,"Value")
end on
Value edit with three decimal spaces
See Also
$VALUE_EDIT_MODE_NOTE_NAMES
$CONTROL_PAR_SHOW_ARROWS
4.13. ui_waveform
declare ui_waveform $<variable>(<width>,<height>) Create a waveform control to display zones and slices. This can also be used to control specific parameters per slice and for drag and drop functionality. <width> <height>  The width of the waveform in grid units The height of the waveform in grid units
Examples
on init declare ui_waveform $Waveform(6,6) attach_zone ($Waveform,find_zone(�hTest�h),0) end on
Displays the zone �gTest�h within the waveform control
See Also
set_ui_wf_property() get_ui_wf_property() attach_zone() find_zone() Waveform Flag Constants Waveform Property Constants $CONTROL_PAR_WAVE_COLOR
$CONTROL_PAR_BG_COLOR
$CONTROL_PAR_WAVE_CURSOR_COLOR
$CONTROL_PAR_SLICEMARKERS_COLOR
$CONTROL_PAR_BG_ALPHA
4.14. ui_wavetable
declare ui_wavetable $ <variable> create a wavetable widget, visualizing the state of a zone that is running in wavetable mode


Examples
on init
 declare ui_wavetable $wavetable
 set_control_par(get_ui_id($wavetable), $CONTROL_PAR_WT_ZONE,�c
find_zone(�gWavetable01�h)
end on
displays the zone �gWavetable01�h within the wavetable widget

See Also
set_control_par() find_zone() $CONTROL_PAR_WT_VIS_MODE
$NI_WT_VIS_2D
$NI_WT_VIS_3D $CONTROL_PAR_WAVE_COLOR $CONTROL_PAR_BG_COLOR $CONTROL_PAR_BG_ALPHA $CONTROL_PAR_WAVE_COLOR $CONTROL_PAR_WAVE_ALPHA $CONTROL_PAR_WAVE_END_COLOR $CONTROL_PAR_WAVE_END_ALPHA $CONTROL_PAR_WAVETABLE_COLOR $CONTROL_PAR_WAVETABLE_ALPHA $CONTROL_PAR_WAVETABLE_END_COLOR $CONTROL_PAR_WAVETABLE_END_ALPHA $CONTROL_PAR_PARALLAX_X $CONTROL_PAR_PARALLAX_Y $CONTROL_PAR_WT_ZONE


4.15. ui_xy
declare ui_xy ?<array>[num-of-elements]
Create an XY pad
Remarks
.
The range of each axis on the XY pad is always between 0.0 and 1.0.

.
The number of cursors in the XY pad, i.e. the interactive elements, is defined by the size of the array. Each index in the array represents one axis of one cursor, so two indices are needed for

each cursor. Applying this, if you wanted to create an XY pad with 3 cursors, then the size of the XY array would be 6 elements.

.
The maximum size of the XY array is 32 elements, and so the maximum number of cursors in the XY pad is 16.

.
The even indices of the array hold the X axis value of the cursors, and the odd indices hold the Y axis values. So index 0 is the X value of the first cursor, and index 1 is the Y value of the first cursor.

.
It is possible to define how the XY pad reacts to mouse interaction using the $CON-TROL_PAR_MOUSE_MODE parameter.

.
Querying $NI_MOUSE_EVENT_TYPE within the on ui_control() callback allows identifica-tion of the mouse event type that triggered it.



Examples
on init
 {basic initialization} message("") make_perfview
 set_ui_color(9ddddddh)
 set_ui_height_px(350)
 {create an XY pad with 2 cursors}
 declare ui_xy ?myXY[4]
 {store the UI ID of the XY pad} declare $xyID $xyID := get_ui_id(?myXY)
 {skinning the cursors} set_control_par_str_arr($xyID, $CONTROL_PAR_CURSOR_PICTURE, ... "Picture1", 0) set_control_par_str_arr($xyID, $CONTROL_PAR_CURSOR_PICTURE, ... "Picture2", 2)
 {set automation IDs and names} set_control_par_arr($xyID, $CONTROL_PAR_AUTOMATION_ID, 0, 0) set_control_par_arr($xyID, $CONTROL_PAR_AUTOMATION_ID, 1, 1) set_control_par_arr($xyID, $CONTROL_PAR_AUTOMATION_ID, 2, 2) set_control_par_arr($xyID, $CONTROL_PAR_AUTOMATION_ID, 3, 3)
 set_control_par_str_arr($xyID, $CONTROL_PAR_AUTOMATION_NAME, ... "Cutoff", 0) set_control_par_str_arr($xyID, $CONTROL_PAR_AUTOMATION_NAME, ... "Resonance", 1) set_control_par_str_arr($xyID, $CONTROL_PAR_AUTOMATION_NAME, ... "Delay Pan", 2)
set_control_par_str_arr($xyID, $CONTROL_PAR_AUTOMATION_NAME, ... "Delay Feedback", 3)
 {define the mouse behaviour} set_control_par($xyID, $CONTROL_PAR_MOUSE_MODE, 0) set_control_par($xyID, $CONTROL_PAR_MOUSE_BEHAVIOUR_X, 1000) set_control_par($xyID, $CONTROL_PAR_MOUSE_BEHAVIOUR_Y, 1000)
 {position and size} set_control_par($xyID, $CONTROL_PAR_POS_X, 50) set_control_par($xyID, $CONTROL_PAR_POS_Y, 50) set_control_par($xyID, $CONTROL_PAR_WIDTH, 200) set_control_par($xyID, $CONTROL_PAR_HEIGHT, 200)
 {move the cursors to the center of the XY pad} ?myXY[0] := 0.5 {1st cursor, X axis} ?myXY[1] := 0.5 {1st cursor, Y axis} ?myXY[2] := 0.5 {2nd cursor, X axis} ?myXY[3] := 0.5 {2nd cursor, Y axis}
end on
Creating an XY pad control with two cursors, custom cursor images, and automation information

See Also
$CONTROL_PAR_MOUSE_MODE
$CONTROL_PAR_ACTIVE_INDEX
$CONTROL_PAR_CURSOR_PICTURE
$CONTROL_PAR_MOUSE_BEHAVIOUR_X
$CONTROL_PAR_MOUSE_BEHAVIOUR_Y
set_control_par_arr()
set_control_par_str_arr()
$HIDE_PART_CURSOR
$NI_CONTROL_PAR_IDX



5. CONTROL STATEMENTS
5.1. if�celse�cend if
if�celse�cend if
A conditional if statement
Examples
on controller if (in_range($CC_NUM,0,127)) message("CC Number: "& $CC_NUM&" - Value: " & %CC[$CC_NUM]) else if ($CC_NUM = $VCC_PITCH_BEND)
 message("Pitchbend" & " - Value: " & %CC[$CC_NUM]) end if if ($CC_NUM = $VCC_MONO_AT)
 message("Channel Pressure" &" - Value: "&%CC[$CC_NUM]) end if end if end on
Display different messages depending on the controller number

See Also
select()


5.2. select()
select(<variable>)�cend select
Select statement
Remarks
.
The select statement is similar to the if statement, except that it has an arbitrary number of branches. The expression after the select keyword is evaluated and matched against the single case branches, the first case branch that matches is executed.

.
The case branches may consist of either a single constant number or a number range, ex-pressed by the term "x to y").


Examples
on controller if ($CC_NUM = $VCC_PITCH_BEND) select (%CC[$VCC_PITCH_BEND])
case -8192 to -1 message("Pitch Bend down") case 0 message("Pitch Bend center") case 1 to 8191 message("Pitch Bend up") end select end if end on
Query the state of the pitch bend wheel

See Also
if�celse�cend if


5.3. while()
while(<condition>)�cend while
While loop
Examples
on note
 ignore_event($EVENT_ID)
 while($NOTE_HELD = 1) play_note($EVENT_NOTE,$EVENT_VELOCITY,0,$DURATION_QUARTER/2) wait($DURATION_QUARTER)
 end while
end on
Repeating held notes at the rate of one quarter note
See Also
$NOTE_HELD
wait()

5.4. Boolean Operators
Boolean Operators
x
 > y Greater than

x
 > y Less than


x >= y Greater than or equal
x <= y Less than or equal
x = y  Equal
x # y  Not equal
in_range(x,y,z)  True if x is between y and z
not a  True if a is false and vice versa
a and b  True if a is true and b is true
a or b  True if a is true or b is true

Remarks
. Boolean operators are used in if and while statements, since they return if the condition is either true or false. In the list above. x, y and z denote numerals, a and b stand for Boolean values.



6. ARITHMETIC COMMANDS & OPERATORS
6.1. Basic Operators
Basic operators
The following operators work on both integers and real numbers.
x := y  Assignment (the value of y is assigned to x)
x + y  Addition
x - y  Subtraction
x * y  Multiplication
x / y  Division
-x  Negative value
abs(x)  Absolute value


6.2. Integer Operators & Commands
The following commands and operators can only be performed on integer variables and values.
inc(x)
Increment an expression by 1 (x + 1)
dec(x) Decrement an expression by 1 (x . 1)
x mod y
Modulo; returns the remainder of a division
e.g. 13 mod 8 returns the value 5

6.3. Real Number Commands
The following commands can only be performed on real numbers.
exp(x)
Exponential function (returns the value of e^x)
log(x)
Logarithmic function
pow(x,y)
Power (returns the value of x^y)
sqrt(x)
Square root

6.4. Rounding Commands
Rounding commands can only be performed on real numbers.
ceil(x)
Ceiling (round up) ceil(2.3) = 3.0
floor(x)
Floor (round down) floor(2.8) = 2.0
round(x)
Round (round to nearest) round(2.3) = 2.0 round(2.8) = 3.0

6.5. Trigonometric Commands
Trigonometric commands can only be performed on real numbers.
cos(x) cosine function
sin(x) sine function
tan(x) tangent function
acos(x) arccosine (inverse cosine function)
asin(x) arcsine (inverse sine function)
atan(x) arctangent (inverse tangent function)

6.6. Bit Operators
The following bit operators can be used:
Bit Operators
x .and. y Bitwise and x .or. y Bitwise or
.not. x Bitwise negation
sh_left(<expression>,<shift-Shifts the bits in <expression> by the amount of <shift-bits> to the bits>) left
sh_right(<expression>,<shift-Shifts the bits in <expression> by the amount of <shift-bits> to the bits>) right

6.7. random()
random(<min>,<max>)
Generate a random integer in the range <min> to <max>
Examples
on init declare $rnd_amt declare $new_vel
end on
on note $rnd_amt := $EVENT_VELOCITY * 10/100 $new_vel := random($EVENT_VELOCITY-$rnd_amt,$EVENT_VELOCITY+$rnd_amt) change_velo($EVENT_ID,$new_vel)
end on
Randomly changing velocities in by �}10 percent

6.8. int_to_real()
int_to_real(<integer value>)
Converts an integer value into a real number
Examples
on init declare ~velocity_disp end on
on note ~velocity_disp := int_to_real($EVENT_VELOCITY)/127.0 message(~velocity_disp)
end on
Displays the event velocity in the range 0.0 to 1.0
See Also
real_to_int()

6.9. real_to_int()
real_to_int(<real value>)
Converts a real number into an integer
Remarks
. Using this process without any rounding function will cause the real value to be truncated, so performing this function both 2.2 and 2.8 will return an integer value of 2

Examples
on init declare $test_int declare ~test_real := 2.8
 $test_int := real_to_int(~test_real) message($test_int) end on
Converting a variable from real to integer and then displaying it

See Also
int_to_real()
round()
ceil()
floor()


6.10. msb()
msb(<value>)
Return the MSB portion (most significant byte) of a 14 bit value
Examples
on rpn message(msb($RPN_VALUE)) end on
Commonly used when working with rpn and nrpn messages
on init declare ui_value_edit $Value (0,16383,1) end on
on ui_control ($Value)
message("MSB: " & msb($Value) & " - LSB: " & lsb($Value)) end on
Understanding MSB and LSB

See Also
lsb() $RPN_ADDRESS $RPN_VALUE


6.11. lsb()
lsb(<value>)
Return the LSB portion (least significant byte) of a 14 bit value
Examples
on rpn
 message(lsb($RPN_VALUE)) end on
Commonly used when working with rpn and nrpn messages
 declare ui_value_edit $Value (0,16383,1) end on
on ui_control ($Value)
 message("MSB: " & msb($Value) & " - LSB: " & lsb($Value)) end on
Understanding MSB and LSB

See Also
msb() $RPN_ADDRESS $RPN_VALUE



7. GENERAL COMMANDS
7.1. disable_logging()
disable_logging(<type>)
Disables emission of messages, warnings or watched vari-able events to both the Kontakt Status Bar and Creator Tools
<type> The type of event the emission of which is disabled. Use one of the following: $NI_LOG_MESSAGE, $NI_LOG_WARN-ING or $NI_LOG_WATCHING.

Remarks
. Only supported in the init callback

Examples
on init disable_logging($NI_LOG_MESSAGE) disable_logging($NI_LOG_WARNING) disable_logging($NI_LOG_WATCHING)
end on
Keep the lines above commented out while development and bring them back in right before ship-ping your product to disable any debugging-related content

See Also
watch_var()
watch_array_idx()


7.2. exit
exit
Immediately stops a callback or exits a function
Remarks
.
exit is a very strong command. Be careful when using it, especially when dealing with larger scripts.

.
If used with a function, exit only quits the function but not the entire callback.



Examples
on note if (not(in_range($EVENT_NOTE,60,71)))
exit
 end if
 {from here on, only notes between C3 to B3 will be processed} end on
Useful for quickly setting up key ranges to be affected by the script

See Also
wait()
stop_wait()


7.3. ignore_controller
ignore_controller
Ignore a controller event in a controller callback
Examples
on controller
 if ($CC_NUM = 1)
 ignore_controller
 set_controller($VCC_MONO_AT,%CC[1]
 end if end on
Transform the mod wheel into aftertouch

See Also
ignore_event()
set_controller()
on controller


7.4. message()
message(<variable/text>)
Display text in the status line of KONTAKT
Remarks
.
The message command is intended to be used for debugging and testing while programming a script. Since there is only one status line in KONTAKT, it should not be used as a generic means of communication with the user. Use a label instead.

.
Make it a habit to write message("") at the start of the init callback. You can then be sure that all previous messages (by the script or by the system) are deleted and you see only new mes-sages.

.
Messages defined in the init callback will only be displayed if the user manually applies the script by clicking on the APPLY button. These messages will not be displayed when an instru-ment loads and initializes the script automatically.



Examples
on init message("Hello, world!") end on
The inevitable implementation of "Hello, world!" in KSP
on note message("Note " & $EVENT_NOTE & " received at " & ... $ENGINE_UPTIME & " milliseconds")
end on
Concatenating elements in a message() command

See Also
$ENGINE_UPTIME
$KSP_TIMER
reset_ksp_timer
declare ui_label
set_text()


7.5. note_off()
note_off(<ID-number>)
Send a note off message to a specific note
<ID-number> The ID number of the note event
Remarks
. note_off() is equivalent to releasing a key, thus it will always trigger a release callback as well as the release portion of a volume envelope. Notice the difference between note_off() and fade_out(), since fade_out() works on a voice level.

Examples
on controller if ($CC_NUM = 1) note_off($ALL_EVENTS) end if end on
A custom "All Notes Off" implementation triggered by the mod wheel
on init
 declare polyphonic $new_id end on
on note
 ignore_event($EVENT_ID)
 $new_id := play_note($EVENT_NOTE,$EVENT_VELOCITY,0,0)
end on
on release ignore_event($EVENT_ID) wait(200000) note_off($new_id)
end on
Delaying the release of each note by 200ms

See Also
fade_out()
play_note()


7.6. play_note()
play_note(<note-number>,<velocity>,<sam-ple-offset>,<duration>)
Generate a note, i.e. generate a note-on message fol-lowed by a note-off message
<note-number> <velocity> <sample-offset> <duration>
The note number to be generated (0 - 127) Velocity of the generated note (1 - 127) Sample offset in microseconds Length of the generated note in microseconds
This parameter also accepts two special values: -1: releasing the note which started the callback stops the sample
0: the entire sample is played
Remarks
.
In DFD mode, the sample offset is dependent on the Sample Mod (S.Mod) value of the respec-tive zones. Sample offset value greater than the zone's S.Mod setting will be ignored and no sample offset will be applied.

.
You can retrieve the event ID of the played note in a variable by writing:


variable> := play_note(<note>, <velocity>, <sample-offset>, <dura-tion>)

Examples
on note play_note($EVENT_NOTE+12,$EVENT_VELOCITY,0,-1)
end on
Harmonizes the played note with the upper octave
on init
 declare $new_id end on on controller
 if ($CC_NUM = 64) if (%CC[64] = 127) $new_id := play_note(60,100,0,0) else note_off($new_id) end if end if end on
Trigger a MIDI note by pressing the sustain pedal

See Also
note_off()


7.7. set_controller()
set_controller(<control-
ler>,<value>)
Send a MIDI CC, pitch bend or chan-
nel pressure value
<controller>  This parameter sets the type, and in the case of MIDI CCs, sets the CC number:
. A number from 0 to 127 designates a MIDI CC number
. $VCC_PITCH_BEND indicates pitch bend
. $VCC_MONO_AT indicates channel pressure (monophonic aftertouch)
<value>  The value of the specified controller:
. MIDI CC and channel pressure values go from 0 to 127
. Pitch bend values go from -8192 to 8191

Remarks
. set_controller() should not be used within an init callback.
on note
 if ($EVENT_NOTE = 36) ignore_event($EVENT_ID) set_controller($VCC_MONO_AT,$EVENT_VELOCITY)
 end if end on
on release
 if ($EVENT_NOTE = 36) ignore_event($EVENT_ID) set_controller($VCC_MONO_AT,0)
 end if end on
If you have a keyboard with no aftertouch, press C1 instead

See Also
ignore_controller $VCC_PITCH_BEND $VCC_MONO_AT


7.8. set_rpn()/set_nrpn
set_rpn(<address>,<value>)
Send a rpn or nrpn message <address> The rpn or nrpn address (0 - 16383)
<value> The value of the rpn or nrpn message (0 - 16383)
Remarks
. KONTAKT cannot handle rpn on nrpn messages as external modulation sources. You can how-ever use these message for simple inter-script communication.

See Also
on rpn/nrpn set_controller $RPN_ADDRESS $RPN_VALUE msb() lsb()


7.9. set_snapshot_type()
set_snapshot_type(<type>)
Configures the KSP processor behavior of all five slots when a snapshot is recalled
<type> The available types are:
0: The init callback will always be executed upon snapshot change, after-wards the on persistence_changed callback will be executed (default be-havior)
1: the init callback will not be executed upon loading a snapshot, only the on persistence_callback will be executed
Remarks
.
This command acts globally, i.e. it can applied in any script slot.

.
In snapshot type 1, the value of a non persistent and instrument persistence variable is pre-served.

.
Loading a snapshot always resets KONTAKT's audio engine, i.e. audio is stopped and all ac-tive events are deleted.



Examples
on init set_snapshot_type(1)
 declare ui_knob $knob_1 (0,127,1) set_text($knob_1,"Knob") make_persistent($knob_1)
 declare ui_button $gui_btn
 set_text($gui_btn,"Page 1") end on function show_gui
 if ($gui_btn = 1) $HIDE_PART_NOTHING) else set_control_par(get_ui_id($knob_1),$CONTROL_PAR_HIDE,$HIDE_WHOLE_CONTROL)
 end if end function on persistence_changed
 call show_gui end on on ui_control ($gui_btn)
 call show_gui end on
Retaining the GUI upon loading snapshots
See Also
on init
on persistence_changed



8. EVENT COMMANDS
8.1. by_marks()
by_marks(<bit-mark>)
A user defined group of events (or event IDs)
Remarks
by_marks() is a user defined group of events which can be set with set_event_mark(). It can be used with all commands which utilize event IDs like note_off(), change_tune() etc.

Examples
on note
 if ($EVENT_NOTE mod 12 = 0) {if played note is a c} set_event_mark($EVENT_ID,$MARK_1) change_tune(by_marks($MARK_1),%CC[1]*1000,0)
 end if end on
on controller if($CC_NUM = 1) change_tune(by_marks($MARK_1),%CC[1]*1000,0) end if end on
Moving the mod wheel changes the tuning of all c's (C-2, C-1�cC8)

See Also
set_event_mark()
$EVENT_ID
$ALL_EVENTS
$MARK_1 �c $MARK_28


8.2. change_note()
change_note(<ID-number>,<note-number>)
Change the note number of a specific note event
Remarks
.
Change_note() is only allowed in the note callback and only works before the first wait() statement. If the voice is already running, only the value of the variable changes.

.
Once the note number of a particular note event is changed, it becomes the new


$EVENT_NOTE
. It is not possible to address events via event groups like $ALL_EVENTS

Examples
on init declare %black_keys[5] := (1,3,6,8,10) end on
on note if (search(%black_keys,$EVENT_NOTE mod 12) # -1) change_note($EVENT_ID,$EVENT_NOTE-1) end if end on
Constrain all notes to white keys, i.e. C major

See Also
$EVENT_NOTE
change_velo()


8.3. change_pan()
change_pan(<ID-number>,<pan-orama>,<relative-bit>)
Change the pan position of a specific note event
<ID-number> The ID number of the note event to be changed
<panorama> The pan position of the note event, from -1000 (left) to 1000 (right)
<relative-bit> If the relative bit is set to 0, the amount is absolute, i.e. the amount overwrites any previous set values of that event.
If set to 1, the amount is relative to the actual value of the event.
The different implications are only relevant with more than one change_pan() statement applied to the same event.
Remarks
. change_pan() works on a note event level and does not change any panorama settings in the instrument itself. It is also not related to any modulations regarding panorama.
Examples
on init
 declare $pan_position end on on note
 $pan_position := ($EVENT_NOTE * 2000 / 127) - 1000
change_pan ($EVENT_ID,$pan_position,0) end on
Panning the entire key range from left to right, i.e. C-2 all the way left, G8 all the way right
on note
 if ($EVENT_NOTE < 60) change_pan ($EVENT_ID,1000,0) wait(500000) change_pan ($EVENT_ID,-1000,0) {absolute, pan is at -1000}
 else change_pan ($EVENT_ID,1000,1) wait(500000) change_pan ($EVENT_ID,-1000,1) {relative, pan is at 0}
 end if end on
Notes below C3 utilize a relative-bit of 0. C3 and above utilize a relative bit of 1

See Also
change_vol()
change_tune()


8.4. change_tune()
change_tune(<ID-num-ber>,<tune-amount>,<relative-bit>)
Change the tuning of a specific note event in millicent.
<ID-number> The ID number of the note event to be changed.
<tune-amount> The tune amount in millicents. 100000 equals 100 cent, i.e. a half tone.
<relative-bit> If the relative bit is set to 0, the amount is absolute, i.e. the amount overwrites any previous set values of that event.
If it is set to 1, the amount is relative to the actual value of the event.
The different implications are only relevant with more than one change_tune()statement applied to the same event.
Remarks
. change_tune() works on a note event level and does not change any tune settings in the instrument itself. It is also not related to any modulations regarding tuning.

Examples
on init declare $tune_amount end on
on note $tune_amount := random(-50000,50000) change_tune ($EVENT_ID,$tune_amount,1)
end on
Randomly detune each note by �} 50 cent

See Also
change_vol()
change_pan()


8.5. change_velo()
change_velo(<ID-number>, <velocity>)
Change the velocity of a specific note event
Remarks
.
change_velo() is only allowed in the note callback and only works before the first wait() statement. If the voice is already running, only the value of the variable changes.

.
Once the velocity of a particular note event is changed, it becomes the new $EVENT_VELOCI-TY

.
It is not possible to address events via event groups like $ALL_EVENTS



Examples
on note change_velo ($EVENT_ID,100) message($EVENT_VELOCITY)
end on
All velocities are set to 100. Note that $EVENT_VELOCITY will also change to 100.
See Also
$EVENT_VELOCITY
change_note()


8.6. change_vol()
change_vol(<ID-number>,<vol-ume>,<relative-bit>)
Change the volume of a specific note event in millidecibel
<ID-number> The ID number of the note event to be changed
<volume> The volume change in millidecibel
<relative-bit> If the relative bit is set to 0, the amount is absolute, i.e. the amount overwrites any previous set values of that event.
If it is set to 1, the amount is relative to the actual value of the event.
The different implications are only relevant with more than one change_vol() statement applied to the same event.
Remarks
. change_vol() works on a note event level and does not change any tune settings in the in-strument itself. It is also not related to any MIDI modulations regarding volume (e.g. MIDI CC7).

Example
on init declare $vol_amount end on
on note $vol_amount := (($EVENT_VELOCITY - 1) * 12000/126) - 6000 change_vol ($EVENT_ID,$vol_amount,1)
end on
A simple dynamic expander: lightly played notes will be softer, harder played notes will be louder

See ALSO
change_tune() change_pan() fade_in() fade_out()


8.7. delete_event_mark()
delete_event_mark(<ID-number>,<bit-mark>)
Delete an event mark, i.e. ungroup the specified event from an event group <ID-number> The ID number of the event to be ungrouped <bit-mark> Here you can enter one of 28 marks from $MARK_1 to
$MARK_28, which is assigned to the event.
See Also
set_event_mark() by_marks() $EVENT_ID $ALL_EVENTS $MARK_1 �c $MARK_28

8.8. event_status()
event_status(<ID-number>)
Retrieve the status of a particular note event, or MIDI event in the multi script. The note can either be active, then this function returns. $EVENT_STATUS_NOTE_QUEUE (or $EVENT_STATUS_MIDI_QUEUE in the multi script) or inactive, then the function returns
$EVENT_STATUS_INACTIVE
Remarks
event_status() can be used to find out if a note event is still "alive" or not.

Examples
on init
 declare %key_id[128] end on
on note if (event_status(%key_id[$EVENT_NOTE])= $EVENT_STATUS_NOTE_QUEUE) fade_out(%key_id[$EVENT_NOTE],10000,1) end if %key_id[$EVENT_NOTE] := $EVENT_ID end on
Limit the number of active note events to one per MIDI key

See Also
$EVENT_STATUS_INACTIVE $EVENT_STATUS_NOTE_QUEUE $EVENT_STATUS_MIDI_QUEUE get_event_ids()


8.9. fade_in()
fade_in(<ID-number>,<fade-time>) Perform a fade-in for a specific note event <ID-number> The ID number of the note event to be faded in
<fade-time> The fade-in time in microseconds
Examples
on init declare $note_1_id declare $note_2_id
end on
on note $note_1_id := play_note($EVENT_NOTE+12,$EVENT_VELOCITY,0,-1) $note_2_id := play_note($EVENT_NOTE+19,$EVENT_VELOCITY,0,-1) fade_in ($note_1_id,1000000) fade_in ($note_2_id,5000000)
end on
Fading in the first two harmonics

See Also
change_vol()
fade_out()


8.10. fade_out()
fade_out(<ID-number>,<fade-time>,<stop-voice>)
Perform a fade-out for a specific note event
<ID-number> The ID number of the note event to be faded in
<fade-time> The fade-in time in microseconds
<stop_voice> If set to 1, the voice is stopped after the fade out
If set to 0, the voice will still be running after the fade out
Examples
on controller if ($CC_NUM = 1) if (%CC[1] mod 2 # 0) fade_out($ALL_EVENTS,5000,0) else fade_in($ALL_EVENTS,5000) end if end if end on
Use the mod wheel on held notes to create a stutter effect
on controller if ($CC_NUM = 1) fade_out($ALL_EVENTS,5000,1) end if end on
A custom "All Sound Off" implementation triggered by the mod wheel
See Also
change_vol()
fade_in()

8.11. get_event_ids()
get_event_ids(<array-name>)
Fills the specified array with all active event IDs. The command overwrites all existing values as long as there are events, and writes 0 if no events are active anymore.
<array-name>  Array to be filled with active event IDs
Examples
on init declare const $ARRAY_SIZE := 500 declare %test_array[$ARRAY_SIZE] declare $a declare $note_count end on
on note get_event_ids(%test_array) $a := 0 $note_count := 0 while($a < $ARRAY_SIZE and %test_array[$a] # 0) inc($note_count) inc($a) end while message("Active Events: " & $note_count) end on
Monitoring the number of active events
See Also
event_status()
ignore_event()
8.12. get_event_par()
get_event_par(<ID-number>,<parame-ter>) Return the value of a specific event parameter of the specified event

<ID-number> The ID number of the event
<parameter> The event parameter, either one of four freely assignable event parame-ters:
$EVENT_PAR_0 $EVENT_PAR_1 $EVENT_PAR_2 $EVENT_PAR_3
or the "built-in" parameters of a note event:
$EVENT_PAR_VOLUME $EVENT_PAR_PAN $EVENT_PAR_TUNE $EVENT_PAR_NOTE $EVENT_PAR_VELOCITY $EVENT_PAR_SOURCE $EVENT_PAR_PLAY_POS $EVENT_PAR_ZONE_ID (use with caution, see below)
Remarks
A note event always carries certain information like the note number, the played velocity, but also Volume, Pan and Tune. With set_event_par(), you can set either these parameters or use the freely assignable parameters like $EVENT_PAR_0. This is especially useful when chaining scripts,
i.e. set an event parameter for an event in slot 1, then retrieve this information in slot 2 by using get_event_par().

Examples
(see next page)
on note message(get_event_par($EVENT_ID,$EVENT_PAR_NOTE)) end on
The same functionality as message($EVENT_NOTE)
on note message(get_event_par($EVENT_ID,$EVENT_PAR_SOURCE)) end on
Check if the event comes from outside (-1) or if it was created in one of the five script slots (0-4)
on note wait(1) message(get_event_par($EVENT_ID,$EVENT_PAR_ZONE_ID))
end on
Note that in the above example, an event itself does not carry a zone ID (only a voice has zone IDs), therefore you need to insert wait(1) in order to retrieve the zone ID.

See Also
set_event_par()
ignore_event()
set_event_par_arr()
get_event_par_arr()


8.13. get_event_par_arr()
get_event_par_arr(<ID-number>,<parameter>,<group-index>)
Special form of get_event_par(), used to retrieve the group al-low state of the specified event
<ID-number> The ID number of the note event
<parameter> In this case, only $EVENT_PAR_ALLOW_GROUP
<group-index> The index of the group for retrieving the specified note's group allow state
Remarks
. get_event_par_arr() is a special form (or to be more precise, it's the array variant) of get_event_par(). It is used to retrieve the allow state of a specific event. It will return 1, if the specified group is allowed and 0 if it's disallowed.
Examples
on init declare $count declare ui_label $label (2,4) set_text ($label,"")
end on
on note set_text($label,"") $count := 0 while($count < $NUM_GROUPS)
 if (get_event_par_arr($EVENT_ID,$EVENT_PAR_ALLOW_GROUP,$count) = 1) add_text_line($label,"Group ID " & $count & " allowed") else add_text_line($label,"Group ID " & $count & " disallowed") end if
 inc($count) end while end on
A simple group monitor

See Also
set_event_par_arr()
get_event_par()
$EVENT_PAR_ALLOW_GROUP
%GROUPS_AFFECTED


8.14. ignore_event()
ignore_event(<ID-number>)
Ignore a note event in a note on or note off callback
Remarks
.
If you ignore an event, any volume, tune or pan information is lost. You can however retrieve this infomation with get_event_par(), see the two examples below.

.
ignore_event() is a very "strong" command. Always check if you can get the same results with the various change_xxx() commands without having to ignore the event.



Examples
on note ignore_event($EVENT_ID) wait (500000) play_note($EVENT_NOTE,$EVENT_VELOCITY,0,-1)
end on
Delaying all notes by 0.5s. Not bad, but if you, for example insert a microtuner before this script, the tuning information will be lost.
on init declare $new_id end on
on note ignore_event($EVENT_ID) wait (500000) $new_id := play_note($EVENT_NOTE,$EVENT_VELOCITY,0,-1)
 change_vol($new_id,get_event_par($EVENT_ID,$EVENT_PAR_VOLUME),1) change_tune($new_id,get_event_par($EVENT_ID,$EVENT_PAR_TUNE),1) change_pan($new_id,get_event_par($EVENT_ID,$EVENT_PAR_PAN),1)
end on
Better: the tuning (plus volume and pan to be precise) information is retrieved and applied to the played note

See Also
ignore_controller
get_event_par()


8.15. set_event_mark()
set_event_mark(<ID-number>,<bit-mark>)
Assign the specified event to a specific event group
<ID-number> The ID number of the event to be grouped
<bit-mark> Here you can enter one of 28 marks from $MARK_1 to $MARK_28 which is assigned to the event. You can also assign more than one mark to a single event, either by typing the command or by using the operator +.
Remarks
When dealing with commands that deal with event IDs, you can group events by using by_marks(<bit-mark>) instead of the individual ID, as the program needs to know that you want to address marks and not IDs.

Examples
on init declare $new_id end on
on note
 set_event_mark($EVENT_ID,$MARK_1)
$new_id := play_note($EVENT_NOTE + 12,120,0,-1) set_event_mark($new_id,$MARK_1 + $MARK_2)
 change_pan(by_marks($MARK_1),-1000,1) {both notes panned to left} change_pan(by_marks($MARK_2), 2000,1) {new note panned to right}
end on
The played note belongs to group 1, the harmonized belongs to group 1 and group 2
See Also
by_marks()
delete_event_mark()
$EVENT_ID
$ALL_EVENTS
$MARK_1 �c $MARK_28


8.16. set_event_par()
set_event_par(<ID-number>,<param-
eter>,<value>)
Assign a parameter to a specific event
<ID-number>  The ID number of the event
<parameter>  The event parameter, either one of four freely assignable event parame-
ters:
$EVENT_PAR_0
$EVENT_PAR_1
$EVENT_PAR_2
$EVENT_PAR_3
or the "built-in" parameters of a note event:
$EVENT_PAR_VOLUME
$EVENT_PAR_PAN
$EVENT_PAR_TUNE
$EVENT_PAR_NOTE
$EVENT_PAR_VELOCITY
<value>  The value of the event parameter

Remarks
A note event always "carries" certain information like the note number, the played velocity, but also volume, pan and tune. With set_event_par(), you can set either these parameters or use the freely assignable parameters like $EVENT_PAR_0. This is especially useful when chaining scripts,
i.e. set an event parameter for an event in slot 1, then retrieve this information in slot 2 by using get_event_par().
The event parameters are not influenced by the system scripts anymore.

Examples
on note
set_event_par($EVENT_ID,$EVENT_PAR_NOTE,60) end on
Setting all notes to middle C3, same as change_note($EVENT_ID,60)

See Also
get_event_par() ignore_event()
set_event_par_arr() get_event_par_arr()


8.17. set_event_par_arr()
set_event_par_arr(<ID-number>,<parame-
ter>,<value>,<groupindex>)
Special form of set_event_par(), used to set the
group allow state of the specified event.
<ID-number>  The ID number of the note event.
<parameter>  In this case, only $EVENT_PAR_ALLOW_GROUP can be used.
<value>  If set to 1, the group set with <groupindex> will be allowed for
the event.
If set to 0, the group set with <groupindex> will be disallowed
for the event.
<group-index>  The index of the group for changing the specified note's group al-
low state.

Remarks
. set_event_par_arr() is a special form (or to be more precise, it's the array variant) of set_event_par(). It is used to set the allow state of a specific event.
Examples
on note if (get_event_par_arr($EVENT_ID,$EVENT_PAR_ALLOW_GROUP,0) = 0) set_event_par_arr($EVENT_ID,$EVENT_PAR_ALLOW_GROUP,1,0) end if end on
Making sure the first group is always played

See Also
allow_group()
disallow_group()
get_event_par_arr()
set_event_par()
$EVENT_PAR_ALLOW_GROUP



9. ARRAY COMMANDS
9.1. array_equal()
array_equal(<array-variable>,<array-variable>)
Checks the values of two arrays. True if all values are equal, false if not
Remarks
This command does not work with arrays of real numbers.

Examples
on init declare %array_1[10] declare %array_2[11]
 if (array_equal(%array_1,%array_2)) message($ENGINE_UPTIME) end if
end on
This script will produce an error message as the two arrays don't have the same size

See Also
sort() num_elements() search()


9.2. num_elements()
num_elements(<array-variable>)
Returns the number of elements in an array
Remarks
With this function you can, e.g., check how many groups are affected by the current event by using num_elements(%GROUPS_AFFECTED).

Examples
on note message(num_elements(%GROUPS_AFFECTED)) end on
Outputs the number of groups playing

See Also
array_equal()
sort()
search()
%GROUPS_AFFECTED


9.3. search()
search(<array-variable>,<value>)
Searches the specified array for the specified value and returns the index of its first position. If the value is not found, the function returns -1.
Remarks
This command does not work with arrays of real numbers.

Examples
on init declare ui_table %array[10] (2,2,5) declare ui_button $check set_text ($check,"Zero present?")
end on
on ui_control ($check) if (search(%array,0) = -1) message ("No") else
 message("Yes") end if $check := 0
end on
Checking if a specific value is present
See Also
array_equal()
num_elements()
sort()


9.4. sort()
sort(<array-variable>,<direction>)
Sorts an array in ascending or descending order.
With direction = 0, the array is sorted in ascending order.
With direction # 0, the array is sorted in descending order.
Examples
on init declare $count declare ui_table %array[128] (3,3,127)
 while ($count < 128) %array[$count] := $count inc($count)
 end while declare ui_button $Invert
end on
on ui_control ($Invert) sort(%array,$Invert) end on
Quickly inverting a linear curve display
See Also
array_equal()
num_elements()
sort()



10. GROUP COMMANDS
10.1. allow_group()
allow_group(<group-index>)
Allows the specified group, i.e. makes it available for playback
Remarks
.
The numbering of the group index is zero based, i.e. the first group has the group index 0.

.
The groups can only be changed if the voice is not running.



Examples
on note disallow_group($ALL_GROUPS) allow_group(0)
end on
Only the first group will play back

See Also
$ALL_GROUPS $EVENT_PAR_ALLOW_GROUP disallow_group() set_event_par_arr()


10.2. disallow_group()
disallow_group(<group-index>)
Disallows the specified group, i.e. makes it unavailable for playback
Remarks
.
The numbering of the group index is zero based, i.e. the first group has the group index 0.

.
The groups can only be changed if the voice is not running.



Examples
on init declare $count declare ui_menu $groups_menu
 add_menu_item ($groups_menu,"Play All",-1)
while ($count < $NUM_GROUPS) add_menu_item ($groups_menu,"Mute: " & group_name($count),$count) inc($count)
 end while end on
on note if ($groups_menu # -1) disallow_group($groups_menu) end if end on
Muting one specific group of an instrument

See Also
$ALL_GROUPS
$EVENT_PAR_ALLOW_GROUP
allow_group()
set_event_par_arr()


10.3. find_group()
find_group(<group-name>)
Returns the group index for the specified group name
Remarks
If no group with the specified name is found, this command will return the value zero. This can cause problems as this is the group index of the first group, so be careful when using this com-mand.

Examples
on note disallow_group(find_group("Accordion")) end on
A simple, yet useful script
See Also
allow_group()
disallow_group
group_name()


10.4. get_purge_state()
get_purge_state(<group-index>)
Returns the purge state of the specified group:
0: The group is purged.
1: The group is not purged, i.e. the samples are loaded.
<group-index> The index number of the group that should be checked.
Examples
on init declare ui_button $purge declare ui_button $checkpurge set_text ($purge,"Purge 1st Group") set_text ($checkpurge,"Check purge status")
end on
on ui_control ($purge) purge_group(0,abs($purge-1)) end on
on ui_control ($checkpurge) if (get_purge_state(0) = 0) message(�gGroup is purged.�h) else message(�gGroup is not purged.�h) end if end on
A simple purge check

See Also
purge_group()


10.5. group_name()
group_name(<group-index>)
Returns the group name for the specified group
Remarks
The numbering of the group index is zero based, i.e. the first group has the group index 0.
Examples
on init declare $count
declare ui_menu $groups_menu
 $count := 0
 while ($count < $NUM_GROUPS) add_menu_item ($groups_menu,group_name($count),$count) inc($count)
 end while end on
Quickly creating a menu with all available groups
on init declare $count declare ui_label $label (2,6) set_text($label,"")
end on
on note $count := 0 while ($count < num_elements(%GROUPS_AFFECTED))
 add_text_line($label,group_name(%GROUPS_AFFECTED[$count])) inc($count)
 end while end on on release
 set_text($label,"") end on
Display the names of the sounding groups

See Also
$ALL_GROUPS
$NUM_GROUPS
allow_group()
disallow_group()
find_group()
output_channel_name()


10.6. purge_group()
purge_group(<group-index>,<mode>)
Purges (i.e. unloads from RAM) the samples of the specified group
<group-index> The index number of the group which contains the samples to be purged.
<mode> If set to 0, the samples of the specified group are unloaded.
If set to 1, the samples are reloaded.
Remarks
.
When using purge_group() in a while loop, don�ft use any wait commands within the loop.

.
purge_group() can only be used a UI and persistence_changed callback.

.
It is recommended to not use the purge_group() command in the callback of an automata-ble control.



Examples
on init
 declare ui_button $purge
 set_text ($purge,"Purge 1st Group") end on
on ui_control ($purge)
 purge_group(0,abs($purge-1)) end on
Unloading all samples of the first group
See Also
get_purge_state



11. TIME-RELATED COMMANDS
11.1. change_listener_par()
change_listener_par(<signal-type>,<parameter>)
Changes the parameters of the on listener callback. It can be used
in every callback.
<signal-type>  The signal to be changed, can be either:
$NI_SIGNAL_TIMER_MS
$NI_SIGNAL_TIMER_BEAT
<parameter>  Dependent on the specified signal type:
$NI_SIGNAL_TIMER_MS
Time interval in microseconds
$NI_SIGNAL_TIMER_BEAT
Time interval in fractions of a beat/quarter note

Examples
on init
 declare ui_value_edit $Tempo (20,300,1) $Tempo := 120
 declare ui_switch $Play
 set_listener($NI_SIGNAL_TIMER_MS,60000000 / $Tempo)
end on
on listener if ($NI_SIGNAL_TYPE = $NI_SIGNAL_TIMER_MS and $Play = 1) play_note(60,127,0,$DURATION_EIGHTH) end if end on
on ui_control($Tempo) change_listener_par($NI_SIGNAL_TIMER_MS,60000000 / $Tempo) end on
A very basic metronome
See Also
on listener
set_listener()
$NI_SIGNAL_TYPE

11.2. ms_to_ticks()
ms_to_ticks(<microseconds>)
Converts a microseconds value into a tempo dependent ticks value
Examples
on init declare ui_label $bpm(1,1) set_text($bpm,ms_to_ticks(60000000)/960)
end on
Displaying the current host tempo

See Also
ticks_to_ms() $NI_SONG_POSITION


11.3. set_listener()
set_listener(<signal-type>,<parameter>)
Sets the signals on which the lis-tener callback should react to. Can only be used in the init call-back.
<signal-type>
<parameter>
The event on which the listener callback should react. The following types are availa-ble:
$NI_SIGNAL_TRANSP_STOP $NI_SIGNAL_TRANSP_START $NI_SIGNAL_TIMER_MS $NI_SIGNAL_TIMER_BEAT
User defined parameter, dependant on the specified signal type:
$NI_SIGNAL_TIMER_MS
Time interval in microseconds
$NI_SIGNAL_TIMER_BEAT
Time interval in fractions of a beat/quarter note
$NI_SIGNAL_TRANSP_START
Set to 1 if the listener callback should react to the host's transport start command
$NI_SIGNAL_TRANSP_STOP
Set to 1 if the listener callback should react to the host's transport stop command
Remarks
When using $NI_SIGNAL_TIMER_BEAT, the maxium resolution is 24 ticks per beat/quarter note.

Examples
on init
 set_listener($NI_SIGNAL_TIMER_BEAT,1) end on on listener
 if ($NI_SIGNAL_TYPE = $NI_SIGNAL_TIMER_BEAT) message($ENGINE_UPTIME) end if end on
Triggering the listener callback every beat. Triggering will occur even when transport is stopped.

See Also
change_listener_par()
$NI_SIGNAL_TYPE


11.4. stop_wait()
stop_wait(<callback-ID>,<parameter>)
Stops wait commands in the specified callback
<callback-ID> The callback�fs ID number in which the wait commands will be stopped
<parameter> 0: stops only the current wait
1: stops the current wait and ignores all following wait commands in this callback.
Remarks
. Be careful with while loops when stopping all wait commands in a callback.

Examples
on init declare ui_button $Play declare $id
end on on ui_control ($Play)
 if ($Play = 1) $id := $NI_CALLBACK_ID play_note(60,127,0,$DURATION_QUARTER)
 wait($DURATION_QUARTER) if ($Play = 1) play_note(64,127,0,$DURATION_QUARTER)
end if
 wait($DURATION_QUARTER) if ($Play = 1) play_note(67,127,0,$DURATION_QUARTER) end if
 else stop_wait($id,1) fade_out($ALL_EVENTS,10000,1)
 end if end on
The Play button triggers a simple triad arpeggio. Without the stop_wait() command, parallel call-backs could occur when pressing the Play button quickly after each other resulting in multiple ar-peggios.

See Also
wait()
wait_ticks()
Callback Type Variables and Constants (Built-in variables/Specific)


11.5. reset_ksp_timer
reset_ksp_timer
Resets the KSP timer ($KSP_TIMER) to zero
Remarks
.
Since the built-in variable $KSP_TIMER returns the engine uptime in microseconds (instead of milliseconds as with $ENGINE_UPTIME), the variable $KSP_TIMER will reach its limit after about 30 minutes due to its 32 bit nature. By using reset_ksp_timer, the variable is reset to 0.

.
Since the KSP timer is based on the CPU clock, the main reason to use it is for debugging and optimization. It is a great tool to measure the efficiency of certain script passages. However, it should not be used for �emusical�f timing, as it remains at a real-time constant rate, even if KON-TAKT is being used in an offline bounc



Examples
on init declare $a declare $b declare $c
end on
on note reset_ksp_timer
$c := 0
 while($c < 128) $a := 0 while($a < 128)
 set_event_par($EVENT_ID,$EVENT_PAR_TUNE,random(-1000,1000)) inc($a) end while
 inc($c) end while message($KSP_TIMER) end on
A nested while loop . takes about 5400 to 5800 microseconds

See Also
$ENGINE_UPTIME
$KSP_TIMER


11.6. ticks_to_ms()
ticks_to_ms(<ticks>)
Converts a tempo dependent ticks value into a microseconds value
Remarks
. Since the returned value is in microseconds, the command will reach its limit after about 30 mi-nutes due to its 32 bit nature.

Examples
on init declare ui_label $label (2,1) declare $msec declare $sec declare $min set_listener($NI_SIGNAL_TIMER_MS,1000)
end on
on listener
 if ($NI_SIGNAL_TYPE = $NI_SIGNAL_TIMER_MS) $msec := ticks_to_ms($NI_SONG_POSITION)/1000 $sec := $msec/1000 $min := $sec/60 set_text($label,$min & ":" & $sec mod 60 & "." & $msec mod 1000)
 end if end on
Displaying the song position in real time

See Also
ms_to_ticks() $NI_SONG_POSITION


11.7. wait()
wait(<wait-time>)
Pauses the callback for the specified time in microseconds
Remarks
wait() stops the callback at the position in the script for the specified time. In other words, it freezes the callback, although other callbacks can be accessed or processed. After the specified time period the callback continues.

Examples
on note
 ignore_event($EVENT_ID)
 wait($DURATION_BAR - $DISTANCE_BAR_START)
 play_note($EVENT_NOTE,$EVENT_VELOCITY,0,-1) end on
Quantize all notes to the downbeat of the next measure

See Also
stop_wait() wait_ticks() while() $DURATION_QUARTER


11.8. wait_ticks()
wait_ticks(<wait-time>)
Pauses the callback for the specified time in ticks
Remarks
Same as wait(), but with ticks as the wait time parameter.
See Also
stop_wait() wait()



12. USER INTERFACE COMMANDS
12.1. add_menu_item()
add_menu_item(<variable>,<text>,<value>)
Create a menu entry <variable> The variable of the UI menu <text> The text of the menu entry
<value> The value of the menu entry
Remarks
.
You can create menu entries only in the init callback but you can change their text and value afterwards by using set_menu_item_str() and set_menu_item_value(). You can add as many menu entries as you want and then show or hide them dynamically by using set_menu_item_visibility().

.
Using the $CONTROL_PAR_VALUE constant in the get_control_par() command will return the menu index and not the value. If you want to get the menu value, use the get_menu_item_value() command.



Examples
on init declare ui_menu $menu add_menu_item ($menu, "First Entry",0) add_menu_item ($menu, "Second Entry",1) add_menu_item ($menu, "Third Entry",2)
end on
A simple menu

See Also
$CONTROL_PAR_SELECTED_ITEM_IDX
$CONTROL_PAR_NUM_ITEMS
get_menu_item_str()
get_menu_item_value()
get_menu_item_visibility()
set_menu_item_str()
set_menu_item_visibility()
ui_menu
12.2. add_text_line()
add_text_line(<variable>,<text>) Add a new text line in the specified label without erasing existing text <variable> <text>  The variable of the UI label The text to be displayed


Examples
on init declare ui_label $label (1,4) set_text($label,"") declare $count
end on
on note inc($count) select ($count)
 case 1
set_text($label, $count & ": " & $EVENT_NOTE) case 2 to 4
 add_text_line($label, $count & ": " & $EVENT_NOTE)
end select if ($count = 4) $count := 0 end if end on
Monitoring the last four played notes

See Also
set_text()
ui_label


12.3. attach_level_meter()
attach_level_meter(<ui-
ID>,<group>,<slot>,<channel>,<bus>)
Attach a level meter to a certain position within the in-
strument to read volume data
<ui-ID>  The ID number of the level meter
<group>  The index of the group you want to access. Should be set to -1
if not using the group level
<slot>  The index of the fx slot you wish to access. Should be set to -1
if you do not wish to access an fx slot.
<channel>  Select either the left (0) or right (1) channel
<bus>  The index of the instrument bus you wish to access. Should be
set to -1 if you are not accessing the bus level.

Remarks
.
Currently, the level meters can only be attached to the output level of the instrument buses and the instrument master. Consequently, the group index and slot index should always be set to -1.

.
The instrument volume has the following syntax: attach_level_meter (<uiID>,-1,-1,<channelIdx>,-1)



Examples
on init declare ui_level_meter $Level1 declare ui_level_meter $Level2 attach_level_meter (get_ui_id($Level1),-1,-1,0,-1) attach_level_meter (get_ui_id($Level2),-1,-1,1,-1)
end on
Creating two volume meters, each one displaying one side of KONTAKT�fs instrument output

See Also
$CONTROL_PAR_BG_COLOR
$CONTROL_PAR_OFF_COLOR
$CONTROL_PAR_ON_COLOR
$CONTROL_PAR_OVERLOAD_COLOR
$CONTROL_PAR_PEAK_COLOR
$CONTROL_PAR_VERTICAL
ui_level_meter


12.4. attach_zone()
attach_zone(<varia-ble>,<zone_id>,<flags>)
Connects the corresponding zone to the waveform so that it shows up within the display
<variable> The variable of the UI waveform
<zone_id> The ID number of the zone that you want to attach to the waveform display
<flags> You can control different settings of the UI waveform via its flags. The following flags are available: $UI_WAVEFORM_USE_SLICES $UI_WAVEFORM_USE_TABLE $UI_WAVEFORM_TABLE_IS_BIPOLAR $UI_WAVEFORM_USE_MIDI_DRAG
Remarks
.
Use the bitwise .or. to combine flags.

.
The $UI_WAVEFORM_USE_TABLE and $UI_WAVEFORM_USE_MIDI_DRAG flags will only work if $UI_WAVEFORM_USE_SLICES is already set.



Examples
on init declare ui_waveform $Waveform(6,6) attach_zone ($Waveform,find_zone(�hTest�h),... $UI_WAVEFORM_USE_SLICES .or. $UI_WAVEFORM_USE_TABLE)
end on
Attaches the zone �gTest�h to the waveform and displays the zone�fs slices and a table

See Also
set_ui_wf_property() get_ui_wf_property() ui_waveform() find_zone() Waveform Flag Constants Waveform Property Constants


12.5. fs_get_filename()
fs_get_filename(<ui-ID>,<return-parameter>)
Return the filename of the last selected file in the UI file browser. <ui-ID> The ID number of the UI control
<return-parameter> 0: Returns the filename without extension
1: Returns the filename with extension
2: Returns the whole path
See Also
fs_navigate() ui_file_selector

12.6. fs_navigate()
fs_navigate(<ui-ID>,<direction>)
Jump to the next/previous file in a UI file selector and trigger its callback.
<ui-ID> The ID number of the UI control
<direction> 0: The previous file (in relation to the currently selected one) is selec-ted
1: The next file (in relation to the currently selected one) is selected
See Also
fs_get_filename() ui_file_selector

12.7. get_control_par()
get_control_par(<ui-ID>,<control-parameter>)
Retrieve various parameters of the specified GUI control
<ui-ID> The ID number of the UI control. You can retrieve the ID number with get_ui_id()
<control-parameter> The control parameter variable, $CONTROL_PAR_WIDTH
Remarks
get_control_par() comes in one additional flavor, get_control_par_arr() for working with arrays.

Examples
on init declare ui_value_edit $Test (0,100,1) message(get_control_par(get_ui_id($Test),... $CONTROL_PAR_WIDTH))
end on
Retrieving the width of a value edit in pixels

See Also
set_control_par() $CONTROL_PAR_KEY_SHIFT $CONTROL_PAR_KEY_ALT $CONTROL_PAR_KEY_CONTROL


12.8. get_font_id()
get_font_id(<file_name>)
returns a font ID from an image file; the font ID can used on any control that has dynamic text elements
<file_name> The filename of the image file, without the file exten-sion. The image has to be in PNG format and residing in the pictures subfolder of the resource container.
Remarks
The images need to be formatted in a special way to be interpreted correctly as sprite fonts. All characters need to be placed side-by-side, following the Windows-1252 character set, with a red pixel on the top left of every character frame.

Examples
on init
 declare ui_text_edit @textEdit
 set_control_par(get_ui_id(@textEdit),$CONTROL_PAR_FONT_TYPE,�c
 get_font_id("Font1")) end on
using a custom font on a ui_text_edit control

See Also
set_control_par() $CONTROL_PAR_FONT_TYPE


12.9. get_menu_item_str()
get_menu_item_str(<menu-id>,<index>)
Returns the string value of the menu�fs entry <menu-id> The ID of the menu that you want to modify
<index> The index (not value) of the menu item
Remarks
The <index> is defined by the order in which the menu items are added within the init callback; it can�ft be changed afterwards.

Examples
on init declare ui_menu $menu add_menu_item ($menu, "First Entry",0) add_menu_item ($menu, "Second Entry",5) add_menu_item ($menu, "Third Entry",10) declare ui_button $button
end on
on ui_control ($button) message(get_menu_item_str (get_ui_id($menu),1)) end on
Displays the message �gSecond Entry�h when clicking on the button

See Also
$CONTROL_PAR_SELECTED_ITEM_IDX $CONTROL_PAR_NUM_ITEMS add_menu_item() get_menu_item_value() get_menu_item_visibility() set_menu_item_str() set_menu_item_value() set_menu_item_visibility()


12.10. get_menu_item_value()
get_menu_item_value(<menu-id>,<index>)
Returns the value of the menu�fs entry <menu-id> The ID of the menu that you want to modify
<index> The index of the menu item
Remarks
The <index> is defined by the order in which the menu items are added within the init callback; it can�ft be changed afterwards.

Examples
on init declare ui_menu $menu add_menu_item ($menu, "First Entry",0) add_menu_item ($menu, "Second Entry",5) add_menu_item ($menu, "Third Entry",10) declare ui_button $button
end on
on ui_control ($button) message (get_menu_item_value (get_ui_id($menu),1)) end on
Displays the number 5

See Also
$CONTROL_PAR_SELECTED_ITEM_IDX
$CONTROL_PAR_NUM_ITEMS
add_menu_item()
get_menu_item_str()
get_menu_item_visibility()
set_menu_item_str() set_menu_item_value() set_menu_item_visibility()


12.11. get_menu_item_visibility()
get_menu_item_visibility(<menu-id>,<index>)
Returns 1 if the menu entry is visible, otherwise 0 <menu-id> The ID of the menu that you want to modify
<index> The index of the menu entry
Remarks
The <index> is defined by the order in which the menu items are added within the init callback; it can�ft be changed afterwards.

Examples
on init
 declare ui_menu $menu
 add_menu_item ($menu, "First Entry",0)
 add_menu_item ($menu, "Second Entry",5)
 add_menu_item ($menu, "Third Entry",10)
 declare ui_button $button end on
on ui_control ($button)
 message (get_menu_item_visibility (get_ui_id($menu),1)) end on
Displays the value 1

See Also
$CONTROL_PAR_SELECTED_ITEM_IDX $CONTROL_PAR_NUM_ITEMS add_menu_item() get_menu_item_str() get_menu_item_value() set_menu_item_str() set_menu_item_value() set_menu_item_visibility()


12.12. get_ui_id()
get_ui_id(<variable>)
Retrieve the ID number of a UI control
Examples
on init declare ui_knob $Knob_1 (0,100,1) declare ui_knob $Knob_2 (0,100,1) declare ui_knob $Knob_3 (0,100,1) declare ui_knob $Knob_4 (0,100,1)
 declare ui_value_edit $Set(0,100,1) declare $a declare %knob_id[4] %knob_id[0] := get_ui_id ($Knob_1) %knob_id[1] := get_ui_id ($Knob_2) %knob_id[2] := get_ui_id ($Knob_3) %knob_id[3] := get_ui_id ($Knob_4)
end on
on ui_control ($Set) $a := 0 while ($a < 4)
 set_control_par(%knob_id[$a],$CONTROL_PAR_VALUE,$Set) inc($a) end while end on
Store IDs in an array
See Also
set_control_par()
get_control_par()

12.13. get_ui_wf_property()
get_ui_wf_property(<variable>,<property>,<index>)
Returns the value of the waveform�fs different properties
<variable> The variable of the UI waveform
<property>  The following properties are available:
$UI_WF_PROP_PLAY_CURSOR
$UI_WF_PROP_FLAGS
$UI_WF_PROP_TABLE_VAL
$UI_WF_PROP_TABLE_IDX_HIGHLIGHT
$UI_WF_PROP_MIDI_DRAG_START_NOTE
<index>  The index of the slice

Examples
on init declare $play_pos declare ui_waveform $Waveform(6,6) attach_zone ($Waveform,find_zone ("Test"),0)
end on
on note
 while ($NOTE_HELD = 1) $play_pos := get_event_par($EVENT_ID,$EVENT_PAR_PLAY_POS) set_ui_wf_property($Waveform,$UI_WF_PROP_PLAY_CURSOR,... 0,$play_pos) message(get_ui_wf_property($Waveform,... $UI_WF_PROP_PLAY_CURSOR,0)) wait (10000)
 end while end on
Displays the current play position value

See Also
set_ui_wf_property()
ui_waveform()
attach_zone()
find_zone()
Waveform Flag Constants
Waveform Property Constants


12.14. hide_part()
hide_part(<variable>,<hide-mask>)
Hide specific parts of user interface controls
<variable> The name of the UI control
<hide-mask> Bit by bit combination of the following constants:
$HIDE_PART_BG {Background of knobs, labels, value edits and tables}
$HIDE_PART_VALUE {value of knobs}
$HIDE_PART_TITLE {title of knobs}
$HIDE_PART_MOD_LIGHT {mod ring light of knobs}
Examples
on init declare ui_knob $Knob (0,100,1)
 hide_part($Knob,$HIDE_PART_BG... .or. $HIDE_PART_MOD_LIGHT... .or. $HIDE_PART_TITLE... .or. $HIDE_PART_VALUE)
end on
A naked knob
on init declare ui_label $label_1 (1,1) set_text ($label_1,"Small Label") hide_part ($label_1,$HIDE_PART_BG)
end on
Hide the background of a label. This is also possible with other UI elements.

See Also
$CONTROL_PAR_HIDE
$HIDE_PART_NOTHING
$HIDE_WHOLE_CONTROL


12.15. load_performance_view()
load_performance_view(<filename>)
Loads a performance view file (NCKP) that was created in the Creator Tools GUI Designer <filename>. The filename of the NCKP file, without extension, as a string (in quotation marks)
Remarks
.
Only one performance view file can be loaded per script slot

.
The performance view file should be in the performance_view subfolder of the resource con-tainer

.
All contained controls are then accessible as if they were declared and set up in KSP; variable names can be identified in Creator Tools


. More information in the Creator Tools documentation

Examples
on init load_performance_view(�gperformanceView�h) end on
on ui_control ($testButton) if ($testButton = 0) set_control_par(get_ui_id($testSlider), $CONTROL_PAR_HIDE, $HIDE_PART_WHOLE_CONTROL) else set_control_par(get_ui_id($testSlider), $CONTROL_PAR_HIDE, $HIDE_PART_NOTHING) end if end on
Loads a performance view file and then defines some basic behavior involving two of the con-tained controls


12.16. make_perfview
make_perfview
Activates the performance view for the respective script
Remarks
.
make_perfview is only available in the init callback.

.
Cannot be used alongside the connect_view() command.



Examples
on init make_perfview set_script_title("Performance View") set_ui_height(6) message("")
end on
Many performance view scripts start like this
See Also
set_skin_offset()
set_ui_height()
set_ui_height_px()


12.17. move_control()
move_control(<variable>,<x-position>,<y-posi-tion>)
Position UI elements in the standard KONTAKT grid
<variable> The name of the UI control
<x-position> The horizontal position of the control (0 to 6) in grid units
<y-position> The vertical position of the control (0 to 16) in grid units
Remarks
.
move_control() can be used in the init and other callbacks.

.
Note that the usage of move_control() in other callbacks than the init callback is more CPU intensive, so handle with care.

.
move_control(<variable>,0,0) will hide the UI element.



Examples
on init set_ui_height(3) declare ui_label $label (1,1) set_text ($label,"Move the wheel!") move_control ($label,3,6)
end on on controller if ($CC_NUM = 1) move_control ($label,3,(%CC[1] * (-5) / (127)) + 6 ) end if end on
Move a UI element with the modwheel
See Also
move_control_px()
$CONTROL_PAR_HIDE


12.18. move_control_px()
move_control_px(<variable>,<x-position>,<y-position>)
Position UI elements in pixels
<variable> The name of the UI control
<x-position> The horizontal position of the control in pixels
<y-position> The vertical position of the control in pixels
Remarks
.
Once you position a control in pixel, you have to make all other adjustments in pixels too, i.e. you cannot change between "pixel" and "grid" mode for a specific control.

.
move_control_px() can be used in the init and other callbacks.

.
Note that the usage of move_control_px() in other callbacks than the init callback is more


CPU intensive, so handle with care. . move_control_px(<variable>,66,2) equals move_control(variable>,1,1)

Examples
on init declare ui_label $label (1,1) set_text ($label,"Move the wheel!") move_control_px ($label,66,2)
end on on controller if ($CC_NUM = 1) move_control_px ($label,%CC[1]+66,2) end if end on
Transform CC values into pixel. This might be useful for reference.

See Also
move_control()
$CONTROL_PAR_POS_X
$CONTROL_PAR_POS_Y


12.19. set_control_help()
set_control_help(<variable>,<text>)
Assigns a text string to be displayed when hovering the UI control. The text will appear in KONTAKT's info pane.
<variable> The name of the UI control
<text> The info text to be displayed
Examples
on init declare ui_knob $Knob(0,100,1) set_control_help($Knob,"I'm the only knob, folks")
end on
set_control_help() in action

See Also
set_script_title() $CONTROL_PAR_HELP


12.20. set_control_par()
set_control_par(<ui-ID>,<control-parame-
ter>,<value>)
Change various parameters of the specified GUI con-
trol
<ui-ID>  The ID number of the UI control. You can retrieve the ID num-
ber with get_ui_id()
<control-parameter>  The control parameter variable, for example $CON-
TROL_PAR_WIDTH
<value>  The (integer) value

Remarks
set_control_par_str() is a variation of the command for usage with text strings.

Examples
on init declare ui_value_edit $test (0,100,$VALUE_EDIT_MODE_NOTE_NAMES) set_text ($test,"") set_control_par (get_ui_id($test),$CONTROL_PAR_WIDTH,45) move_control_px($test,100,10)
end on
Changing the width of a value edit to 45 pixels. Note that you also have to specify its position in pixels once you enter "pixel-mode".
on init declare ui_label $test (1,1) set_control_par_str(get_ui_id($test),$CONTROL_PAR_TEXT,"This is Text") set_control_par(get_ui_id($test),$CONTROL_PAR_TEXT_ALIGNMENT,1)
end on
Set and center text in labels

See Also
get_control_par()
get_ui_id()


12.21. set_control_par_arr()
set_control_par_arr(<ui-ID>,<control-parame-ter>,<value>,<index>)
Change various parameters of an element within an array based GUI control, e.g. cursors in the XY pad
<ui-ID> The ID number of the UI control. You can retrieve the ID number with get_ui_id()
<control-parameter> The control parameter variable, e.g. $CON-TROL_PAR_AUTOMATION_ID
<value> The (integer) value
<index> The element index
Remarks
set_control_par_str_arr() is a variation of the command for usage with text strings.

Examples
on init make_perfview set_ui_height_px(350)
 declare ui_xy ?myXY[4] declare $xyID $xyID := get_ui_id(?myXY)
 set_control_par_arr($xyID, $CONTROL_PAR_AUTOMATION_ID, 0, 0) set_control_par_arr($xyID, $CONTROL_PAR_AUTOMATION_ID, 1, 1) set_control_par_arr($xyID, $CONTROL_PAR_AUTOMATION_ID, 2, 2) set_control_par_arr($xyID, $CONTROL_PAR_AUTOMATION_ID, 3, 3)
 set_control_par_str_arr($xyID, $CONTROL_PAR_AUTOMATION_NAME, ... "Cutoff", 0) set_control_par_str_arr($xyID, $CONTROL_PAR_AUTOMATION_NAME, ... "Resonance", 1) set_control_par_str_arr($xyID, $CONTROL_PAR_AUTOMATION_NAME, ... "Delay Pan", 2) set_control_par_str_arr($xyID, $CONTROL_PAR_AUTOMATION_NAME, ... "Delay Feedback", 3) end on
Setting automation IDs and names of an XY pad with two cursors
See Also
$CONTROL_PAR_CURSOR_PICTURE
$CONTROL_PAR_AUTOMATION_ID
$CONTROL_PAR_AUTOMATION_NAME
$HIDE_PART_CURSOR


12.22. set_knob_defval()
set_knob_defval(<variable>,<value>)
Assign a default value to a knob to which the knob is reset when Cmd-clicking (Mac) or Ctrl-clicking (PC) the knob.
Remarks
In order to assign a default value to a slider, use
set_control_par(<ui-ID>,$CONTROL_PAR_DEFAULT_VALUE,<value>)

Examples
on init declare ui_knob $Knob(-100,100,0) set_knob_defval ($Knob,0) $Knob := 0
 declare ui_slider $Slider (-100,100) set_control_par(get_ui_id($Slider),$CONTROL_PAR_DEFAULT_VALUE,0) $Slider := 0
end on
Assigning default values to a knob and slider

See Also
$CONTROL_PAR_DEFAULT_VALUE


12.23. set_knob_label()
set_knob_label(<variable>,<text>)
Assign a text string to a knob
Examples
on init declare !rate_names[18] !rate_names[0] := "1/128" !rate_names[1] := "1/64" !rate_names[2] := "1/32" !rate_names[3] := "1/16 T" !rate_names[4] := "3/64" !rate_names[5] := "1/16" !rate_names[6] := "1/8 T" !rate_names[7] := "3/32" !rate_names[8] := "1/8" !rate_names[9] := "1/4 T" !rate_names[10] := "3/16" !rate_names[11] := "1/4"
!rate_names[12] := "1/2 T" !rate_names[13] := "3/8" !rate_names[14] := "1/2" !rate_names[15] := "3/4" !rate_names[16] := "4/4" !rate_names[17] := "Bar"
 declare ui_knob $Rate (0,17,1) set_knob_label($Rate,!rate_names[$Rate])
 read_persistent_var($Rate) set_knob_label($Rate,!rate_names[$Rate])
end on
on ui_control ($Rate) set_knob_label($Rate,!rate_names[$Rate])
end on
Useful for displaying rhythmical values

See Also
$CONTROL_PAR_LABEL


12.24. set_knob_unit()
set_knob_unit(<variable>,<knob-unit-constant>)
Assign a unit mark to a knob.
The following constants are available:
$KNOB_UNIT_NONE
$KNOB_UNIT_DB
$KNOB_UNIT_HZ
$KNOB_UNIT_PERCENT
$KNOB_UNIT_MS
$KNOB_UNIT_OCT
$KNOB_UNIT_ST
Examples
on init declare ui_knob $Time (0,1000,10) set_knob_unit ($Time,$KNOB_UNIT_MS)
 declare ui_knob $Octave (1,6,1) set_knob_unit ($Octave,$KNOB_UNIT_OCT)
declare ui_knob $Volume (-600,600,100) set_knob_unit ($Volume,$KNOB_UNIT_DB)
 declare ui_knob $Scale (0,100,1) set_knob_unit ($Scale,$KNOB_UNIT_PERCENT)
 declare ui_knob $Tune (4300,4500,10) set_knob_unit ($Tune,$KNOB_UNIT_HZ)
end on
Various knob unit marks

See Also
$CONTROL_PAR_UNIT


12.25. set_menu_item_str()
set_menu_item_str(<menu-id>,<index>,<string>)
Sets the value of a menu entry
<menu-id> The ID of the menu that you want to modify
<index> The index of the menu item
<string> The text you wish to set for the selected menu item
Remarks
The <index> is defined by the order in which the menu items are added within the init callback; it can�ft be changed afterwards.

Examples
on init declare ui_menu $menu declare ui_button $button add_menu_item ($menu, "First Entry",0) add_menu_item ($menu, "Second Entry",5) add_menu_item ($menu, "Third Entry",10)
end on
on ui_control ($button) set_menu_item_str (get_ui_id($menu),1,"Renamed") end on
Renaming the second menu entry

See Also
$CONTROL_PAR_SELECTED_ITEM_IDX
$CONTROL_PAR_NUM_ITEMS
add_menu_item()
get_menu_item_str()
get_menu_item_value()
get_menu_item_visibility()
set_menu_item_value()
set_menu_item_visibility()
12.26. set_menu_item_value()
set_menu_item_value(<menu-id>,<index>,<value>)
Sets the value of a menu entry
<menu-id>  The ID of the menu that you want to modify
<index>  The index of the menu item

<value> The value you want to give the menu item

Remarks
The <index> is defined by the order in which the menu items are added within the init callback; it can�ft be changed afterwards. The <value> is set by the third parameter of the add_menu_item() command.

Examples
on init
 declare ui_menu $menu
 add_menu_item ($menu, "First Entry",0)
 add_menu_item ($menu, "Second Entry",5)
 add_menu_item ($menu, "Third Entry",10)
 set_menu_item_value (get_ui_id($menu),1,20) end on
Changing the value of the second menu entry to 20

See Also
$CONTROL_PAR_SELECTED_ITEM_IDX $CONTROL_PAR_NUM_ITEMS add_menu_item() get_menu_item_str() get_menu_item_value() get_menu_item_visibility() set_menu_item_str() set_menu_item_visibility()
12.27. set_menu_item_visibility()
set_menu_item_visibility(<menu-id>,<index>,<visibility>)
Sets the visibility of a menu entry
<menu-id>  The ID of the menu that you want to modify
<index>  The index of the menu item

<visibility> Set to either 0 (invisible) or 1 (visible)

Remarks
The <index> is defined by the order in which the menu items are added within the init callback; it can�ft be changed afterwards. The <value> is set by the third parameter of the add_menu_item() command.
Add as many menu entries as you would possibly need within the init callback, then show or hide them dynamically by using set_menu_item_visibility().
If you set the currently selected menu item to invisible, the item will remain visible until it is no lon-ger selected.

Examples
on init
 declare ui_menu $menu
 declare ui_button $button
 add_menu_item ($menu, "First Entry",0)
 add_menu_item ($menu, "Second Entry",5)
 add_menu_item ($menu, "Third Entry",10) end on
on ui_control ($button)
 set_menu_item_visibility (get_ui_id($menu),1,0) end on
Hiding the second menu entry
See Also
$CONTROL_PAR_SELECTED_ITEM_IDX
$CONTROL_PAR_NUM_ITEMS
add_menu_item()
get_menu_item_str()
get_menu_item_value()
get_menu_item_visibility()
set_menu_item_str()
set_menu_item_visibility()


12.28. set_table_steps_shown()
set_table_steps_shown(<variable>,<num-of-steps>)
Changes the number of displayed columns in a UI table <variable> The name of the UI table
<num-of-steps> The number of displayed steps
Examples
on init declare ui_table %table[32] (2,2,127)
 declare ui_value_edit $Steps (8,32,1) $Steps := 16 set_table_steps_shown(%table,$Steps)
end on
on ui_control($Steps) set_table_steps_shown(%table,$Steps) end on
Changing the number of shown steps

See Also
ui_table


12.29. set_script_title()
set_script_title(<text>)
Set the script title
Remarks
. This command overrides any manually set script titles.

Examples
on init make_perfview set_script_title("Performance View") set_ui_height(6) message("")
end on
Many performance view scripts start like this

See Also
make_perfview


12.30. set_skin_offset()
set_skin_offset(<offset-in-pixel>)
Offsets the chosen background picture file by the specified number of pixels
Remarks
If a background tga/png graphic file has been selected in the instrument options and it is larger than the maximum height of the performance view, you can use this command to offset the back-ground graphic, thus creating separate backgrounds for each of the script slots while only using one picture file.

Examples
on init make_perfview set_ui_height(1)
end on
on controller if ($CC_NUM = 1) set_skin_offset(%CC[1]) end if end on
Try this with the wallpaper called "Sunrise.tga" (Kontakt 6/presets/wallpaper/Sunrise.tga)
See Also
make_perfview
set_ui_height_px()


12.31. set_text()
set_text(<variable>,<text>)
When applied to a label: delete the text currently visible in the specified label and add new text.
When applied to knobs, buttons, switches and value edits: set the display name of the UI element.
Examples
on init declare ui_label $label_1 (1,1) set_text ($label_1,"Small Label")
declare ui_label $label_2 (3,6) set_text ($label_2,"Big Label") add_text_line ($label_2,"�cwith a second text line")
end on
Two labels with different sizes
on init declare ui_label $label_1 (1,1) set_text ($label_1,"Small Label") hide_part ($label_1,$HIDE_PART_BG)
end on
Hide the background of a label. This is also possible with other UI elements.

See Also
add_text_line()
$CONTROL_PAR_TEXT
set_control_par_str()


12.32. set_ui_color()
set_ui_color(<hex value>)
Set the main background color of the performance view
<hex value>  The hexadecimal color value in the following format:
9ff0000h {red}
The 9 at the start lets KONTAKT know the value is a number.
The h at the end indicates that it is a hexadecimal value.

Remarks
Can be used in all callbacks.

Examples
on init make_perfview set_ui_color(9000000h)
end on
Creates a black interface

See Also
set_ui_height() set_ui_height_px()


12.33. set_ui_height()
set_ui_height(<height>)
Set the height of a script performance view in grid units
<height> The height of script in grid units (1 to 8)
Remarks
Only possible in the init callback.

Examples
on init make_perfview set_script_title("Performance View") set_ui_height(6) message("")
end on
Many performance view scripts start like this

See Also
set_ui_height_px()


12.34. set_ui_height_px()
set_ui_height_px(<height>)
Set the height of a script performance view in pixels
<height> The height of script in pixels (50 to 750)
Remarks
Only possible in the init callback.

Examples
on init make_perfview declare const $SIZE := 1644 {size of tga file} declare const $NUM_SLIDES := 4 {amount of slides in tga file}
 declare ui_value_edit $Slide (1,$NUM_SLIDES,1)
 declare const $HEADER_SIZE := 93
 set_ui_height_px(($SIZE/$NUM_SLIDES)-$HEADER_SIZE) set_skin_offset (($Slide-1)*($SIZE/$NUM_SLIDES))
end on
on ui_control ($Slide)
 set_skin_offset (($Slide-1)*($SIZE/$NUM_SLIDES)) end on
Try this with some of the wallpaper tga files of the Kontakt 4 Factory Library, e.g. /Kontakt 4 Library/Choir/Z - Samples/Wallpaper/pv_choir_bg.tga

See Also
set_ui_height() set_ui_width_px()


12.35. set_ui_width_px()
set_ui_width_px(<width>)
Set the width of a script performance view in pixels <width> The width of the script in pixels (633 to 1000)
Remarks
Only possible in the init callback.

Examples
on init
 make_perfview
 set_ui_height_px(750)
set_ui_width_px(1000) end on
Making a performance view with the largest possible dimensions

See Also
set_ui_height_px()


12.36. set_ui_wf_property()
set_ui_wf_property(<variable>,<property>,<index>,<val-ue>)
Sets different properties for the waveform control <variable> The variable of the ui waveform <property> The following properties are available:
$UI_WF_PROP_PLAY_CURSOR
$UI_WF_PROP_FLAGS
$UI_WF_PROP_TABLE_VAL
$UI_WF_PROP_TABLE_IDX_HIGHLIGHT
$UI_WF_PROP_MIDI_DRAG_START_NOTE
<index> The index of the slice
<value> The (integer) value
Examples
on init declare $play_pos declare ui_waveform $Waveform(6,6) attach_zone ($Waveform,find_zone("Test"),0)
end on
on note
 while ($NOTE_HELD = 1) $play_pos := get_event_par($EVENT_ID,$EVENT_PAR_PLAY_POS) set_ui_wf_property($Waveform,$UI_WF_PROP_PLAY_CURSOR,... 0,$play_pos) wait (10000)
 end while end on
Attaches the zone �gTest�h to the waveform and displays a play cursor within the waveform as long as you play a note
See Also
get_ui_wf_property()
ui_waveform()
attach_zone()
find_zone()
Waveform Flag Constants
Waveform Property Constants



13. KEYBOARD COMMANDS
13.1. get_key_color()
get_key_color(<note-nr>)
Returns the color constant of the specified note number
Examples
on init message("") declare $count while ($count < 128)
 set_key_color($count,$KEY_COLOR_INACTIVE) inc($count) end while
 declare $random_key $random_key := random(60,71)
 set_key_color($random_key,$KEY_COLOR_RED)
end on
on note if (get_key_color($EVENT_NOTE) = $KEY_COLOR_RED) message("Bravo!")
 set_key_color($random_key,$KEY_COLOR_INACTIVE) $random_key := random(60,71) set_key_color($random_key,$KEY_COLOR_RED)
 else message("Try again!") end if end on
on release message("") end on
Catch me if you can
See Also
set_key_color()

13.2. get_key_name()
get_key_name(<note-nr>)
Returns the name of the specified key
Examples
on init
 declare $count
 while ($count < 128) set_key_name($count,"") inc($count)
 end while
 set_key_name(60,"Middle C")
end on
on note message(get_key_name($EVENT_NOTE)) end on

See Also
set_key_name()


13.3. get_key_triggerstate()
get_key_triggerstate(<note-nr>)
Returns the pressed state of the specified note number, i.e. key, on the KONTAKT keyboard. It can be either 1 (key pressed) or 0 (key released).
Remarks
get_key_triggerstate() only works with set_key_pressed_support() set to 1.

Examples
on init
 set_key_pressed_support(1) end on on note
 set_key_pressed($EVENT_NOTE,1)
 message(get_key_triggerstate($EVENT_NOTE)) end on on release
 set_key_pressed($EVENT_NOTE,0)
message(get_key_triggerstate($EVENT_NOTE)) end on

See Also
set_key_pressed()
set_key_pressed_support()


13.4. get_key_type()
get_key_type(<note-nr>)
Returns the key type constant of the specified key
See Also
set_key_type()

13.5. get_keyrange_min_note()
get_keyrange_min_note(<note-nr>)
Returns the lowest note of the specified key range
Remarks
Since a key range cannot have overlapping notes, it is sufficient with all get_keyrange_xxx() commands to specify the key range with one note number only.

Examples
on init
 declare $count while ($count < 128)
 remove_keyrange($count) inc($count) end while
 set_keyrange(36,72,"Middle Range")
end on
on note message(get_keyrange_min_note($EVENT_NOTE)) end on
See Also
set_keyrange()


13.6. get_keyrange_max_note()
get_keyrange_max_note(<note-nr>)
Returns the highest note of the specified key range
Remarks
Since a key range cannot have overlapping notes, it is sufficient with all get_keyrange_xxx() commands to specify the key range with one note number only.

Examples
on init
 declare $count while ($count < 128)
 remove_keyrange($count) inc($count) end while
 set_keyrange(36,72,"Middle Range")
end on
on note message(get_keyrange_min_note($EVENT_NOTE)) end on

See Also
set_keyrange()


13.7. get_keyrange_name()
get_keyrange_name(<note-nr>)
Returns the name of the specified key range
Remarks
Since a key range cannot have overlapping notes, it is sufficient with all get_keyrange_xxx() commands to specify the key range with one note number only.

Examples
on init
 declare $count while ($count < 128)
remove_keyrange($count) inc($count) end while
 set_keyrange(36,72,"Middle Range")
end on
on note message(get_keyrange_name($EVENT_NOTE)) end on

See Also
set_keyrange()


13.8. set_key_color()
set_key_color(<note-nr>,<key-color-constant>)
Sets the color of the specified key, i.e. MIDI note, on the KONTAKT keyboard. The following colors are available:
$KEY_COLOR_RED $KEY_COLOR_ORANGE $KEY_COLOR_LIGHT_ORANGE $KEY_COLOR_WARM_YELLOW $KEY_COLOR_YELLOW $KEY_COLOR_LIME $KEY_COLOR_GREEN $KEY_COLOR_MINT $KEY_COLOR_CYAN $KEY_COLOR_TURQUOISE $KEY_COLOR_BLUE $KEY_COLOR_PLUM $KEY_COLOR_VIOLET $KEY_COLOR_PURPLE $KEY_COLOR_MAGENTA $KEY_COLOR_FUCHSIA $KEY_COLOR_DEFAULT sets the key to KONTAKT's standard color for mapped notes $KEY_COLOR_INACTIVE resets the key to standard black and white $KEY_COLOR_NONE resets the key to its normal KONTAKT color, e.g. red for internal keyswitches
Remarks
The keyboard colors reside outside of KSP, i.e. changing the color of a key is similar to changing a KONTAKT knob with set_engine_par(). It is therefore a good practice to set all keys to either $KEY_COLOR_INACTIVE or $KEY_COLOR_NONE in the init callback or whenever changed later.

Example
(see next page)
on init message("") declare ui_button $Color
 declare $count declare $note_count declare $color_count declare %white_keys[7] := (0,2,4,5,7,9,11) declare %colors[16] := (... $KEY_COLOR_RED,$KEY_COLOR_ORANGE,$KEY_COLOR_LIGHT_ORANGE,... $KEY_COLOR_WARM_YELLOW,$KEY_COLOR_YELLOW,$KEY_COLOR_LIME,... $KEY_COLOR_GREEN,$KEY_COLOR_MINT,$KEY_COLOR_CYAN,... $KEY_COLOR_TURQUOISE,$KEY_COLOR_BLUE,$KEY_COLOR_PLUM,... $KEY_COLOR_VIOLET,$KEY_COLOR_PURPLE,$KEY_COLOR_MAGENTA,$KEY_COLOR_FUCHSIA)
 $count := 0
 while ($count < 128) set_key_color($count,$KEY_COLOR_NONE) inc($count)
 end while end on
on ui_control ($Color) if ($Color = 1)
 $count := 0
 while ($count < 128) set_key_color($count,$KEY_COLOR_INACTIVE) inc($count)
 end while
 $note_count := 0 $color_count := 0 while ($color_count < 16)
 if (search(%white_keys,(60 + $note_count) mod 12) # -1) set_key_color(60 + $note_count,%colors[$color_count]) inc ($color_count)
 end if
inc($note_count)
 end while
 else
 $count := 0
 while ($count < 128) set_key_color($count,$KEY_COLOR_NONE) inc($count)
 end while
 end if
end on
KONTAKT rainbow

See Also
set_control_help()
get_key_color()
set_key_name()
set_keyrange()


13.9. set_key_name()
set_key_name(<note-nr>,<name>)
Assigns a text string to the specified key
Remarks
Key names are instrument parameters and reside outside KSP, i.e. changing the key name is simi-lar to changing a KONTAKT knob with set_engine_par(). Make sure to always reset all key names in the init callback or whenever changed later.
Key names and ranges are displayed in KONTAKT's info pane when hovering the mouse over the key on the KONTAKT keyboard.

Examples
on init
 declare $count
 while ($count < 128) set_key_name($count,"") inc($count)
 end while
set_key_name(60,"Middle C")
end on

See Also
set_keyrange()
get_key_name()


13.10. set_key_pressed()
set_key_pressed(<note-nr>,<value>)
Sets the trigger state of the specified key on KONTAKT's keyboard either to pressed/on (1) or released/off (0).
Remarks
By using set_key_pressed() in combination with set_key_pressed_support() it is possi-ble to show script generated notes on KONTAKT's keyboard. The typical use case would be if an instrument features an in-built sequencer/harmonizer and the triggered notes should be shown on the keyboard.

Examples
on init
 set_key_pressed_support(1) end on on note
 set_key_pressed($EVENT_NOTE,1) end on on release
 set_key_pressed($EVENT_NOTE,0) end on
Insert this after an arpeggiator or harmonizer script
See Also
set_key_pressed_support()
get_key_triggerstate()


13.11. set_key_pressed_support()
set_key_pressed_support(<mode>)
Sets the pressed state support mode for KONTAKT'S keyboard. The available modes are:
0: KONTAKT handles all pressed states. set_key_pressed() commands are ignored (default mode).
1: KONTAKT's keyboard is only affected by set_key_pressed()commands.
Remarks
The pressed state mode resides outside KSP, i.e. changing the mode is similar to changing a KONTAKT knob with set_engine_par(). Make sure to always set the desired mode in the init callback.

Examples
on init declare ui_button $Enable set_key_pressed_support(0)
end on
on ui_control ($Enable) set_key_pressed_support($Enable) end on
on note play_note($EVENT_NOTE+4,$EVENT_VELOCITY,0,-1) play_note($EVENT_NOTE+7,$EVENT_VELOCITY,0,-1)
 set_key_pressed($EVENT_NOTE,1) set_key_pressed($EVENT_NOTE+4,1) set_key_pressed($EVENT_NOTE+7,1)
end on
on release set_key_pressed($EVENT_NOTE,0) set_key_pressed($EVENT_NOTE+4,0) set_key_pressed($EVENT_NOTE+7,0)
end on
Press the button and you will see what you hear
See Also
set_key_pressed()
get_key_triggerstate()


13.12. set_key_type()
set_key_type(<note-nr>,<key-type-constant>)
Assigns a key type to the specified key.
The following key types are available:
$NI_KEY_TYPE_DEFAULT i.e. normal mapped notes that produce sound.
$NI_KEY_TYPE_CONTROL i.e. key switches or other notes that do not produce sound.
$NI_KEY_TYPE_NONE resets the key to its normal KONTAKT behaviour.
Remarks
Setting the key type is useful for supported hosts like KOMPLETE KONTROL, where keys with control functionality, e.g. key switches, should not be affected by any note processing.

Examples
on init
 declare $count
 $count := 0
 while ($count < 128) set_key_type($count,$NI_KEY_TYPE_NONE) inc($count)
 end while
 $count := 36 while ($count <= 96)
 select ($count)
 case 36 to 47 {e.g. key switch} set_key_type($count,$NI_KEY_TYPE_CONTROL)
 case 48 to 96 {e.g. main notes} set_key_type($count,$NI_KEY_TYPE_DEFAULT)
 end select
 inc($count) end while end on

See Also
get_key_type()


13.13. set_keyrange()
set_keyrange(<min-note>,<max-note>,<name>)
Assigns a text string to the specified range of keys
Remarks
Key ranges are instrument parameters and reside outside KSP, i.e. changing the key range is simi-lar to changing a KONTAKT knob with set_engine_par(). Make sure to always remove all key ranges in the init callback or whenever changed later.
There can be up to 16 key ranges per instrument.
Key names and ranges are displayed in KONTAKT's info pane when hovering the mouse over the key on the KONTAKT keyboard. The range name is followed by the key name, separated by a dash.

Examples
on init
 declare $count while ($count < 128)
 remove_keyrange($count) inc($count) end while
 set_keyrange(36,72,"Middle Range")
end on

See Also
remove_keyrange()
set_key_name()


13.14. remove_keyrange()
remove_keyrange(<note-nr>)
Assigns a text string to the specified range of keys
Remarks
Key ranges are instrument parameters and reside outside KSP, i.e. changing the key range is simi-lar to changing a KONTAKT knob with set_engine_par(). Make sure to always remove all key ranges in the init callback or whenever changed later.

Examples
on init
 declare $count while ($count < 128)
 remove_keyrange($count) inc($count) end while
 set_keyrange(36,72,"Middle Range")
end on

See Also
set_keyrange()



14. ENGINE PARAMETER COMMANDS
14.1. find_mod()
find_mod(<group-index>,<mod-name>)
Returns the slot index of an internal modulator
or external modulation slot
<group-index>  The index of the group
<mod-name>  The name of the modulator or modulation slot.
Each modulator or modulation slot has a predefined name, based on
the modulation source and target.
The name can be changed with the script editor's edit area open and
right-clicking on the modulator or modulation slot.

Examples
on init declare $grp_idx $grp_idx := 0
 declare $env_idx
 $env_idx := find_mod(0,"VOL_ENV") declare ui_knob $Attack (0,1000000,1) set_knob_unit($Attack,$KNOB_UNIT_MS)
 $Attack := get_engine_par($ENGINE_PAR_ATTACK,$grp_idx,$env_idx,-1) set_knob_label($Attack,get_engine_par_disp... ($ENGINE_PAR_ATTACK,$grp_idx,$env_idx,-1)) end on
on ui_control ($Attack) set_engine_par($ENGINE_PAR_ATTACK,$Attack,$grp_idx,$env_idx,-1) set_knob_label($Attack,get_engine_par_disp...
 ($ENGINE_PAR_ATTACK,$grp_idx,$env_idx,-1)) end on
Controlling the attack time of the volume envelope of the first group. Note: the envelope has been manually renamed to "VOL_ENV"
on init declare $count
declare ui_slider $test (0,1000000) $test := get_engine_par($ENGINE_PAR_MOD_TARGET_INTENSITY,0,... find_mod(0,"VEL_VOLUME"),-1)
end on
on ui_control ($test)
 $count := 0
 while($count < $NUM_GROUPS) set_engine_par($ENGINE_PAR_MOD_TARGET_INTENSITY,$test,$count,... find_mod($count,"VEL_VOLUME"),-1) inc($count)
 end while
end on
Creating a slider which controls the velocity to volume modulation intensity of all groups

See Also
find_target()
set_engine_par()


14.2. find_target()
find_target(<group-in-dex>,<mod-index>,<target-name>)
Returns the slot index of a modulation slot of an internal modulator
<group-index> The index of the group
<mod-index> The slot index of the internal modulator. Can be retrieved with find_mod(<group-idx>,<mod-name>)
<target-name> The name of the modulation slot
Each modulation slot has a predefined name, based on the modulation source and target.
The name can be changed with the script editor's edit area open and right-clicking on the modulation slot.
Examples
on init declare ui_knob $Knob (-100,100,1) declare $mod_idx $mod_idx := find_mod(0,"FILTER_ENV")
 declare $target_idx $target_idx := find_target(0,$mod_idx,"ENV_AHDSR_CUTOFF")
end on
on ui_control ($Knob) if ($Knob < 0) set_engine_par ($MOD_TARGET_INVERT_SOURCE,... 1,0,$mod_idx,$target_idx) else set_engine_par ($MOD_TARGET_INVERT_SOURCE,... 0,0,$mod_idx,$target_idx) end if set_engine_par($ENGINE_PAR_MOD_TARGET_INTENSITY,... abs($Knob*10000),0,$mod_idx,$target_idx)
end on
Controlling the filter envelope amount of an envelope to filter cutoff modulation in the first group. Note: the the filter envelope has been manually renamed to "FILTER_ENV".

See Also
find_mod()
set_engine_par()


14.3. get_engine_par()
get_engine_par(<parame-ter>,<group>,<slot>,<gener-ic>)
Returns the value of a specific engine parameter
<parameter> Specifies the engine parameter by using one of the built in engine parameter variables.
<group> The index (zero based) of the group in which the specified parameter resides.
If the specified parameter resides on an Instrument level, enter -1.
<slot> The slot index (zero based) of the specified parameter. It applies only to group/ instrument effects, modulators and modulation intensities.
For group/instrument effects, this parameter specifies the slot in which the effect resides (zero-based).
For modulators and modulation intensities, this parameters specifies the index which you can retrieve by using:
find_mod(<group-idx>,<mod-name>)
For all other applications, set this parameter to -1.
<generic> This parameter applies to instrument effects and to internal modulators.
For instrument effects, this parameter distinguishes between:
1: Insert Effect
0: Send Effect
For busses, this parameter specifies the actual bus:
$NI_BUS_OFFSET + [0-15] one of the 16 busses
For internal modulators, this parameter specifies the modulation slider which you can retrieve by using:
find_target(<group-idx>,<mod-idx>,<target-name>)
For all other applications, set this parameter to -1.
Examples
on init declare $a
 declare ui_label $label (2,6) set_text ($label,"Release Trigger Groups:")
 while ($a < $NUM_GROUPS) if(get_engine_par($ENGINE_PAR_RELEASE_TRIGGER ,$a,-1,-1)=1)
 add_text_line($label,group_name($a)&" (Index: "&$a&")") end if inc($a)
 end while end on
Output the name and index of release trigger group
on init declare ui_label $label (2,6)
 declare ui_button $Refresh
 declare !effect_name[128] !effect_name[$EFFECT_TYPE_NONE] := "None" !effect_name[$EFFECT_TYPE_PHASER] := "Phaser" !effect_name[$EFFECT_TYPE_CHORUS] := "Chorus" !effect_name[$EFFECT_TYPE_FLANGER] := "Flanger" !effect_name[$EFFECT_TYPE_REVERB] := "Reverb" !effect_name[$EFFECT_TYPE_DELAY] := "Delay" !effect_name[$EFFECT_TYPE_IRC] := "Convolution" !effect_name[$EFFECT_TYPE_GAINER] := "Gainer"
 declare $count while ($count < 8) add_text_line($label,"Slot: " & $count+1 & ": " & ...
!effect_name[get_engine_par($ENGINE_PAR_SEND_EFFECT_TYPE,-1,$count,-1)])
inc($count)
 end while
end on
on ui_control ($Refresh) set_text($label,"") $count := 0 while ($count < 8) add_text_line($label,"Slot: " & $count+1 & ": " & ... !effect_name[get_engine_par($ENGINE_PAR_SEND_EFFECT_TYPE,-1,$count,-1)]) inc($count) end while
 $Refresh := 0 end on
Output the effect types of all eight slots of send effects

See Also
Module Status Retrieval


14.4. get_engine_par_disp()
get_engine_par_disp(<parame-ter>,<group>,<slot>,<gener-ic>)
Returns the displayed string of a spe-cific engine parameter
<parameter> Specifies the engine parameter.
<group> The index (zero based) of the group in which the specified parameter resides.
If the specified parameter resides on an Instrument level, enter -1.
<slot> The slot index (zero based) of the specified parameter. It applies only to group/ instrument effects, modulators and modulation intensities.
For group/instrument effects, this parameter specifies the slot in which the effect resides (zero-based).
For modulators and modulation intensities, this parameters specifies the index which you can retrieve by using:
find_mod(<group-idx>,<mod-name>)
For all other applications, set this parameter to -1.
<generic> this parameter applies to instrument effects and to internal modulators. For instrument effects, this parameter distinguishes between
1: Insert Effect
0: Send Effect For busses, this parameter specifies the actual bus:
$NI_BUS_OFFSET + [0-15] one of the 16 busses
For internal modulators, this parameter specifies the modulation slider which you can retrieve by using:
find_target(<group-idx>,<mod-idx>,<target-name>)
For all other applications, set this parameter to -1
Examples
on init declare $a
 declare ui_label $label (2,6) set_text ($label,"Group Volume Settings:")
 while ($a < $NUM_GROUPS) add_text_line($label,group_name($a) & ": " & ... get_engine_par_disp($ENGINE_PAR_VOLUME,$a,-1,-1) & " dB") inc($a) end while
end on
Query the group volume settings in an instrument

14.5. get_voice_limit()
get_voice_limit(<voice-type>)
Returns the voice limit for the Time Machine Pro mode of the source
module
<voice-type> The voice type, can be one one of the following: $NI_VL_TMPRO_STANDARD {Standard Mode} $NI_VL_TMRPO_HQ {High Quality Mode}
Examples
on init declare ui_label $label (3,2)
 add_text_line($label,"Standard Voice Limit: " & ... get_voice_limit($NI_VL_TMPRO_STANDARD))
add_text_line($label,"HQ Voice Limit: " & ... get_voice_limit($NI_VL_TMPRO_HQ))
end on
Displaying TM Pro voice limits

See Also
set_voice_limit ()


14.6. output_channel_name()
output_channel_name(<output-number>)
Returns the channel name for the specified output
<output-number>  The number of the output channel (zero based, i.e. the first output is
0)

Examples
on init declare $count declare ui_menu $menu add_menu_item($menu,"Default",-1)
 $count := 0
 while($count < $NUM_OUTPUT_CHANNELS) add_menu_item($menu,output_channel_name($count),$count) inc($count)
 end while
 $menu := get_engine_par($ENGINE_PAR_OUTPUT_CHANNEL,0,-1,-1) end on
on ui_control ($menu) set_engine_par($ENGINE_PAR_OUTPUT_CHANNEL,$menu,0,-1,-1) end on
Mirroring the output channel assignment menu of the first group

See Also
$NUM_OUTPUT_CHANNELS
$ENGINE_PAR_OUTPUT_CHANNEL


14.7. set_engine_par()
set_engine_par(<parame-ter>,<val-ue>,<group>,<slot>,<gener-ic>)
Control automatable KONTAKT pa-rameters and bypass buttons
<parameter>
<value>
<group>
<slot>
<generic>
The parameter to be controlled with a built-in variable, e.g. $ENGINE_PAR_CUT-OFF
The value to which the specified parameter is set. The range of values is always 0 to 1000000, except for switches in which case it is
0 or 1. The index (zero based) of the group in which the specified parameter resides. If the specified parameter resides on an Instrument level, enter -1. Busses also reside on Instrument level, so you need to set <group> to -1 if you
want to address a bus. The slot index (zero based) of the specified parameter. This applies only to group/ instrument effects, modulators and modulation intensities. For group/instrument effects, this parameter specifies the slot in which the effect resides (zero-based). For modulators and modulation intensities, this parameters specifies the index which you can retrieve by using:
find_mod(<group-idx>,<mod-name>)
For all other applications, set this parameter to -1. This parameter applies to instrument effects and to internal modulators. For instrument effects, this parameter distinguishes between:
1: Insert Effect
0: Send Effect For busses, this parameter specifies the actual bus:
$NI_BUS_OFFSET + [0-15] one of the 16 busses
For internal modulators, this parameter specifies the modulation slider which you can retrieve by using:
find_target(<group-idx>,<mod-idx>,<target-name>)
For all other applications, set this parameter to -1
Examples
on init
 declare ui_knob $Volume (0,1000000,1000000) end on on ui_control ($Volume)
 set_engine_par($ENGINE_PAR_VOLUME,$Volume,-1,-1,-1) end on
Controlling instrument volume
on init declare ui_knob $Freq (0,1000000,1000000) declare ui_button $Bypass
end on
on ui_control ($Freq) set_engine_par($ENGINE_PAR_CUTOFF,$Freq,0,0,-1) end on
on ui_control ($Bypass) set_engine_par($ENGINE_PAR_EFFECT_BYPASS,$Bypass,0,0,-1) end on
Controlling the cutoff and bypass button of any filter module in the first slot of the first group
on init declare ui_knob $Knob (-100,100,1) declare $mod_idx $mod_idx := find_mod(0,"FILTER_ENV")
 declare $target_idx $target_idx := find_target(0,$mod_idx,"ENV_AHDSR_CUTOFF") end on
on ui_control ($Knob)
 if ($Knob < 0) set_engine_par ($MOD_TARGET_INVERT_SOURCE,... 1,0,$mod_idx,$target_idx)
 else set_engine_par ($MOD_TARGET_INVERT_SOURCE,... 0,0,$mod_idx,$target_idx)
 end if set_engine_par($ENGINE_PAR_MOD_TARGET_INTENSITY,... abs($Knob*10000),0,$mod_idx,$target_idx)
end on
Controlling the filter envelope amount of an envelope to filter cutoff modulation in the first group. Note: the the filter envelope has been manually renamed to "FILTER_ENV".
on init declare ui_knob $Vol (-0,1000000,1) end on
on ui_control ($Vol) set_engine_par($ENGINE_PAR_VOLUME,$Vol,-1,-1,$NI_BUS_OFFSET + 15) end on
Controlling the amplifier volume of the 16th bus

14.8. set_voice_limit()
set_voice_limit(<voice-type>,<value>)
Sets the voice limit for the Time Machine Pro mode of the source
module
<voice-type>  The voice type, can be one one of the following:
$NI_VL_TMPRO_STANDARD {Standard Mode}
$NI_VL_TMRPO_HQ {High Quality Mode}

<value> The voice limit of the Time Machine Pro mode
Remarks
. Changing voice limits is an asynchronous operation. This means, that one cannot reliably ac-cess the newly allocated voices immediately after instantiation. To resolve this, the set_voice_limit() command returns an $NI_ASYNC_ID and triggers the on async_complete callback.

Examples
on init declare ui_value_edit $Voices (1,8,1) make_persistent($Voices)
 declare $change_voices_id
end on
on ui_control ($Voices) $change_voices_id := set_voice_limit($NI_VL_TMPRO_STANDARD,$Voices) end on
on async_complete if ($NI_ASYNC_ID = $change_voices_id) message("New TM Pro Standard Voice Limit: " & ... get_voice_limit($NI_VL_TMPRO_STANDARD)) end if end on
Changing TM Pro voice limits
See Also
get_voice_limit ()



15. LOAD/SAVE COMMANDS
15.1. General Information
File Formats
It is possible to load and save the following file formats:
.
KONTAKT arrays (.nka files)

.
MIDI files (.mid) to be used with the file commands in KSP

.
IR samples (.wav) to be used with KONTAKT's convolution effect (loading only)



Async Handling
Loading and saving files cannot be executed in real time. This is why all load/save commands re-turn a unique value upon completion of their action. You can use this value in combination with $NI_ASYNC_ID and $NI_ASYNC_EXIT_STATUS within the on_async_complete callback to check whether the the command has completed its action, and whether or not the loading or sav-ing was successful.

Path Handling
All file paths in KSP use a slash character (/) as a folder separator. Backslash characters are not supported. The full path has to start with a slash character �g/�h.

Examples
Factory folder on OS X:
/Library/Application Support/Native Instruments/Kontakt 6/
Factory folder on Windows:
/C:/Program Files/Common Files/Native Instruments/Kontakt 6/
When loading or saving files with an absolute path as opposed to loading from the Resource Con-tainer, always use path variables in combination with get_folder().

See Also
$NI_ASYNC_ID $NI_ASYNC_EXIT_STATUS on async_complete


15.2. get_folder()
get_folder(<path-variable>)
Returns the path specified with the built-in path variable
<path-variable> The following path variables are available: $GET_FOLDER_LIBRARY_DIR
If used with an nki belonging to an encoded library: library folder. If used with an unencoded nki: the user content directory.
$GET_FOLDER_FACTORY_DIR
The factory folder of KONTAKT, mainly used for loading factory IR samples. Note: this is not the factory library folder!
$GET_FOLDER_PATCH_DIR
The directory in which the patch was saved. If the patch was not saved before, an empty string is returned.
Remarks
. The behaviour $GET_FOLDER_LIBRARY_DIR changed from KONTAKT 5 on. If the NKI be-longs to an encoded library, it will point to its library folder. Otherwise, the user content directory is returned.

Example
on init message(get_folder($GET_FOLDER_FACTORY_DIR)) end on
Displaying the path of the factory folder of KONTAKT

See Also
load_ir_sample() $GET_FOLDER_LIBRARY_DIR $GET_FOLDER_FACTORY_DIR $GET_FOLDER_PATCH_DIR


15.3. load_array()
load_array(<array-variable>,<mode>)
Loads an array from an ex-ternal file (.nka file)
<array-variable> The array variable, this name must be present in the .nka file
<mode> 0: A dialog window pops up, allowing you to select an .nka file. Can only be used in UI, pgs and persistence_changed callbacks.
1: The array is directly loaded from the "Data" folder.
For user instruments, the "Data" folder is located beside the resource container.
For library instruments, the "Data" folder is located here:
OS X: <UserName>/Library/Application Support/<Library Name>/
Win: C:\User\<UserName>\AppData\Local\<Library Name>\
Can be used in UI, pgs, init (synchronous) and persistence_changed callbacks.
2: The array is directly loaded from the "data" folder inside the resource container. Can be used in UI, pgs, init (synchronous) and persistence_changed callbacks.
Remarks
.
It is also possible to load string arrays from .nka files.

.
It is not possible to load an array with %xyz in its .nka file into array %abc.

.
The array data is not directly available after the load_array() command has been executed since the command works asynchronous. The only situation in which the values are instantly available is when using mode 1 or mode 2 within an init callback.

.
When using mode 0 the callback continues even if the loading dialog is still open.

.
Mode 2 is only available for loading arrays, i.e. save_array() does not have this option.

.
When loading an array within the init callback, please remember that the loaded data will be overwritten at the end of the callback if the array is persistent. Use read_persistent_var() before loading the array to avoid this problem.

.
.nka files loaded from the resource container should always have a newline character at the end of the file. If this last newline is missing, then KONTAKT will not know the file has ended and will continue to try and load other data from the resources container. Files generated by the save_array() command have this automatically, but if you are creating files manually, then this is something to take care of.



Example
(see next page)
on init
 declare $count
 declare ui_button $Load
 declare ui_button $Save
 declare ui_table %table[8] (2,2,100)
 make_persistent(%table)
 declare %preset[8]
 declare $load_arr_id
 $load_arr_id := -1
 declare $save_arr_id
 $save_arr_id := -1 end on
on ui_control (%table)
$count := 0
 while($count < 8) %preset[$count] := %table[$count] inc($count)
 end while end on
on ui_control ($Load) $load_arr_id := load_array(%preset,0) end on
on ui_control ($Save) $save_arr_id := save_array(%preset,0) end on
on async_complete
 if ($NI_ASYNC_ID = $load_arr_id) $load_arr_id := -1 $Load := 0 if ($NI_ASYNC_EXIT_STATUS = 1)
 $count := 0
 while($count < 8) %table[$count] := %preset[$count] inc($count)
 end while
 end if end if if ($NI_ASYNC_ID = $save_arr_id)
 $save_arr_id := -1 $Save := 0 end if end on
Exporting and loading the contents of a UI table
See Also
$NI_ASYNC_ID
$NI_ASYNC_EXIT_STATUS
on async_complete
save_array()


15.4. load_array_str()
load_array_str(<array-variable>,<path>)
Loads an array from an external file (.nka file) using the file's absolute path
<array-variable> The array variable. This name must be present in the .nka file
<path> The absolute path of the .nka file
Remarks
.
The behaviour is similar to load_array() with mode set to 0, but instead of manually choos-ing an .nka file you can specify it with an absolute path.

.
Can be used in init (synchronous), persistence_changed, UI and pgs callbacks.



Example
(see next page)
on init set_ui_height(2)
 declare @basepath_browser {set browser path here, for example @basepath_browser := "/Users/<username>/Desktop/Arrays"}
 declare @file_path make_persistent(@file_path)
 declare @file_name make_persistent(@file_name)
 declare ui_file_selector $file_browser declare $browser_id $browser_id := get_ui_id($file_browser) set_control_par_str($browser_id,$CONTROL_PAR_BASEPATH,@basepath_browser) set_control_par($browser_id,$CONTROL_PAR_WIDTH,112) set_control_par($browser_id,$CONTROL_PAR_HEIGHT,68) set_control_par($browser_id,$CONTROL_PAR_COLUMN_WIDTH,110) set_control_par($browser_id,$CONTROL_PAR_FILE_TYPE,$NI_FILE_TYPE_ARRAY) move_control_px($file_browser,66,2)
 declare ui_table %table[8] (2,2,100) make_persistent(%table) move_control(%table,3,1)
 declare %preset[8]
 declare $load_arr_id $load_arr_id := -1 declare $count
end on
on async_complete
if ($NI_ASYNC_ID = $load_arr_id)
 $load_arr_id := -1
 if ($NI_ASYNC_EXIT_STATUS = 0) message("Array not found!")
 else message("") $count := 0 while($count < 8)
 %table[$count] := %preset[$count] inc($count) end while end if end if end on
on ui_control ($file_browser) @file_name := fs_get_filename($browser_id,0) @file_path := fs_get_filename($browser_id,2) $load_arr_id := load_array_str(%preset,@file_path)
end on
Loading different table presets with a browser. Make sure to first set the browser path of the file selector to point to a folder with compatible .nka files


15.5. load_ir_sample()
load_ir_sample(<file-path>,<slot>,<generic>)
Loads an impulse response sam-ple into KONTAKT's convolution effect
<file-path>
The absolute file path of the IR sample.
If no path is specified, the command will look for the specified sample within the �gir_samples�h folder of the Resource Container. If no Resource Container is available, the folder "ir_samples" within the KONTAKT
user folder will be checked. The KONTAKT user folder is loacated here: OS X: /Users/<username>/Documents/Native Instruments/Kontakt 6/ Windows: C:/Users/<username>/Documents/Native Instruments/
Kontakt 6/
<slot> The slot index of the convolution effect (zero-based)
<generic>  Specifies whether the convolution effect is used as an: 1: Insert Effect 0: Send Effect For busses, this parameter specifies the actual bus: $NI_BUS_OFFSET + [0-15] one of the 16 busses
Remarks

. Please note that sub directories inside the "ir_samples" folder will not be scanned and it is not recommended to add them manually via text strings. Doing so could lead to problems because subfolders are being ignored during the creation of a Resource Container monolith.
Example
(see next page)
on init declare ui_button $Load declare $load_ir_id $load_ir_id := -1
end on
on ui_control ($Load) $load_ir_id := load_ir_sample("Small Ambience.wav",0,0) $Load := 0
end on
on async_complete
 if ($NI_ASYNC_ID = $load_ir_id)
 $load_ir_id := -1
 if ($NI_ASYNC_EXIT_STATUS = 0) message("IR sample not found!") else message("IR sample loaded!") end if
 end if
end on
Load an IR sample into a convolution send effect in the first slot
See Also
$NI_ASYNC_ID
get_folder()
on async_complete

15.6. save_array()
save_array(<array-var-iable>,<mode>)
Saves an array to an external file, i.e. an .nka file
<array-variable> The array to be saved
<mode> 0: A dialog window pops up, allowing you to save the .nka file. Can only be used in UI, pgs and persistence_changed callbacks.
1: The array is directly loaded from the "Data" folder.
For user instruments, the "Data" folder is located beside the resource container.
For library instruments, the "Data" folder is located here:
OS X: <UserName>/Library/Application Support/<Library Name>/
Win: C:\User\<UserName>\AppData\Local\<Library Name>\
Can be used in UI, pgs, and persistence_changed callbacks.
Remarks
.
It is also possible to save string arrays into .nka files.

.
The exported .nka file consists of the name of the array followed its values.

.
When using mode 0 the callback continues even if the loading dialog is still open.



See Also
$NI_ASYNC_ID $NI_ASYNC_EXIT_STATUS on async_complete load_array()


15.7. save_array_str()
save_array_str(<array-variable>,<path>)
Saves an array to an external file, i.e. an .nka file, using the specified absolute path
<array-variable> The array to be saved
<path> The absolute path of the .nka file to be saved
Remarks
.
The behaviour is similar to save_array(), but instead of manually choosing a save location, you can directly save the file to the specified location.

.
If the file does not exist but the folder does, a new .nka file will be created.

.
Can be used in persistence_changed, UI and pgs callbacks.



Example
(see next page)
on init declare $count
 declare @path {set save path here, for example @path := "/Users/<username>/Desktop/Arrays/"}
 declare ui_button $Save
 declare ui_table %table[8] (2,2,100) make_persistent(%table)
 declare %preset[8]
 declare $save_arr_id $save_arr_id := -1
 declare ui_text_edit @preset_name make_persistent(@preset_name)
 set_control_par_str(get_ui_id(@preset_name),$CONTROL_PAR_TEXT,"empty") set_control_par(get_ui_id(@preset_name),$CONTROL_PAR_FONT_TYPE,25) set_control_par(get_ui_id(@preset_name),$CONTROL_PAR_POS_X,73 + 3*92) set_control_par(get_ui_id(@preset_name),$CONTROL_PAR_POS_Y,2)
 declare ui_label $pattern_lbl(1,1) set_text($pattern_lbl,"") move_control_px($pattern_lbl,66 + 3*92,2)
end on
on ui_control (%table) $count := 0 while($count < 8)
 %preset[$count] := %table[$count] inc($count) end while end on
on ui_control ($Save) $save_arr_id := save_array_str(%preset,@path & @preset_name & ".nka") end on
on async_complete
 if ($NI_ASYNC_ID = $save_arr_id) $save_arr_id := -1 $Save := 0
 end if end on
Save table presets with custom names. Make sure to set the path where the .nka files will be saved.

See Also
save_array()
load_array_str()


15.8. save_midi_file()
save_midi_file(<path>)
Saves a file with a range specified by the mf_set_export_area() command.
<path> The absolute path of the file
Example
on init declare @path {set save path here, for example @path := "/Users/<username>/Desktop/MIDI Files/"}
 declare ui_text_edit @file_name set_control_par_str(get_ui_id(@file_name),$CONTROL_PAR_TEXT,"<empty>") set_control_par(get_ui_id(@file_name),$CONTROL_PAR_FONT_TYPE,25) make_persistent(@file_name) move_control_px(@file_name,73,2)
 declare ui_label $file_name_lbl(1,1) set_text($file_name_lbl,"") move_control_px($file_name_lbl,66,2)
 declare ui_button $Save move_control($Save,2,1)
 declare $save_mf_id $save_mf_id := -1
end on
on ui_control ($Save) $save_mf_id := save_midi_file(@path & @file_name & ".mid")
end on
on async_complete
 if ($NI_ASYNC_ID = $save_mf_id) $save_mf_id := -1 $Save := 0
 end if end on
Saving a MIDI file
See Also
mf_insert_file()
mf_set_export_area()



16. MIDI OBJECT COMMANDS
16.1. General Information
Please note that in KONTAKT version 5.2, the MIDI file handling has been significantly updated. Commands and working methods from before the 5.2 release will remain in order to keep back-wards compatibility; however this reference will document the post 5.2 working method.
You can only use one MIDI object at a time within an NKI. The MIDI object is held in memory and can be accessed by any of the script slots. It is possible to add, remove and edit MIDI events with-in the object, as well as import and export MIDI files.
The Multi Script can also hold one MIDI object, and handles it in the same way as an NKI.
Creating, Importing and Exporting MIDI files
When you initialize an instrument, an empty MIDI object is initialized with it. You can either start editing the object by defining a buffer size and inserting events, or by inserting a whole MIDI file.
If you want to create a MIDI sequence from scratch, you first need to assign a buffer size, which effectively creates a number of inactive MIDI events. From this point you can activate, i.e. insert, and edit MIDI events using the MIDI event commands.
You can also load a MIDI file to use or edit the data in a script. Depending on the command and variables you use, this will either be combined with any existing MIDI data, or will replace the exist-ing data. It should be noted that loading a MIDI file is an asynchronous command, and thus the common asynchronous loading commands and working methods apply.
MIDI objects can be exported from KONTAKT either by using the save_midi_file() command, or via a drag and drop enabled label element. In either case, it is possible to define the export area, both in terms of start and end times, as well as the start and end tracks, by using the mf_set_export_area() command.

Navigating and Editing
MIDI events in KONTAKT�fs MIDI object are given event parameters, which are accessed using ei-ther the mf_get_event_par() or mf_set_event_par() commands. A unique event ID can be used to access a specific event, or you can navigate through events by position. The event ID is assigned whenever a MIDI event is created or loaded.
In order to access the event data of a loaded MIDI file, you can navigate around the MIDI events with a position marker, something analogous to a play-head. The position marker will focus on one single event at a time, allowing you to use a variety of commands to access or edit the event�es parameters. You have the option to either navigate from one event to the next, or to specify exact positions in MIDI ticks.
It should be noted that MIDI note off messages are not used. When you load a MIDI file using the mf_insert_file() command, the note off events are used to give a length parameter to the re-spective note on event, and are then discarded.


16.2. mf_insert_file()
mf_insert_file(<path>,<track-offset>,<posi-tion-offset>,<mode>)
Inserts a MIDI file into the object
<path> The absolute path of the MIDI file, including the file name
<track-offset> Applies a track offset to the MIDI data
<position-offset> Applies a position offset, in ticks, to the MIDI data
<mode> Defines the mode of insertion:
0: Replace all existing events
1: Replace only overlapping events
2: Merge all events
Remarks
.
The loading of MIDI files with this command is asynchronous, so it is advised to use the async_complete callback to check the status of the load. However, the async_complete callback will not be called if this command is used in the init callback.

.
This command will pair Note On and Note Off events to a single Note On with a Note Length parameter. The Note Off events will be discarded.



Example
(see next page)
on init declare @file_name declare @filepath
 @file_name := "test.mid" @filepath := get_folder($GET_FOLDER_FACTORY_DIR) & @file_name
 declare $load_mf_id declare ui_button $load_file end on
on ui_control($load_file) $load_mf_id := mf_insert_file(@filepath,0,0,0) end on
on async_complete if ($NI_ASYNC_ID = $load_mf_id)
 $load_mf_id := -1
 if ($NI_ASYNC_EXIT_STATUS = 0) message("FATAL ERROR: MIDI file not found!") else
message("Loaded MIDI File: " & @file_name) end if end if end on
Loading a MIDI file with a button. In order for this to work you will need to put a MIDI file called "test.mid" into your KONTAKT Factory folder. Otherwise the defined error message will be dis-
played.

See Also
$NI_ASYNC_ID $NI_ASYNC_EXIT_STATUS on async_complete save_midi_file() mf_set_event_par() mf_get_event_par()


16.3. mf_set_export_area()
mf_set_export_area(<name>,<start-pos>,<end-
pos>,<start-track>,<end-track>)
Defines the part of the object that will be exported when using a
drag and drop area, or the save_midi_file() command.
<name>  Sets the name of the exported file.
<start-pos>  Defines the start position (in ticks) of the export area.
Use -1 to set this to the start of the object.
<end-pos>  Defines the end position (in ticks) of the export area.
Use -1 to set this to the end of the object.
<start-track>  Defines the first track to be included in the export area.
Use -1 to set this to the first track of the object.
<end-track>  Defines the last track to be included in the export area.
Use -1 to set this to the last track of the object.

Remarks
.
If a start point is given a value greater than the end point, the values will be swapped.

.
When this command is executed, the events in the range are checked if they are valid MIDI commands. The command will return a value of 0 if all events are valid, otherwise it will return the event ID of the first invalid event.



Example
on init @filepath := get_folder($GET_FOLDER_FACTORY_DIR) & "test.mid" mf_insert_file(@filepath,0,0,0)
declare ui_button $check_area declare $area_status end on
on ui_control($check_area) $area_status := mf_set_export_area(�gname�h,-1,-1,-1,-1) if($area_status = 0)
 message(�gAll Good�h) else
 message(�gError: check event with ID �h & $area_status) end if end on
A simple script, using this command to check if all events in a MIDI file are valid. If there is an error it will display the event ID of the first invalid event. In order for this to work you will have to put a MIDI file called "test.mid" into your KONTAKT Factory folder.

See Also
mf_insert_file()
$CONTROL_PAR_DND_BEHAVIOUR
save_midi_file()


16.4. mf_set_buffer_size()
mf_set_buffer_size(<size>)
Defines a number of inactive MIDI events, that can be activated and edited
<size> The size of the MIDI object edit buffer
Remarks
.
Using the mf_insert_event() and mf_remove_event() technically activate or deactivate events in the buffer.

.
It is not possible to insert MIDI events without first setting a buffer size.

.
The maximum buffer size is 1,000,000 events, including both active and inactive events.

.
If this command is called outside of the init callback, it is asynchronous, and thus calls the async_complete callback.

.
Inserting a MIDI event will decrease the buffer size by one. Removing an event will increase it by one.

.
Inserting a MIDI file will not affect the buffer.


See Also
mf_insert_file()
mf_get_buffer_size()
mf_reset()
mf_insert_event() mf_remove_event() save_midi_file()

16.5. mf_get_buffer_size()
mf_get_buffer_size()
Returns the size of the MIDI event buffer
Remarks
.
The maximum buffer size is 1,000,000 events, including both active and inactive events.

.
Inserting a MIDI event will decrease the buffer size by one. Removing an event will increase it by one.



See Also
mf_insert_file() mf_set_buffer_size() mf_reset() mf_insert_event() mf_remove_event() save_midi_file()


16.6. mf_reset()
mf_reset()
Resets the MIDI object, sets the event buffer to zero, and removes all events
Remarks
.
This command purges all MIDI data. Use with caution.

.
This command is also asynchronous, and thus calls the async_complete callback.



See Also
mf_insert_file() mf_set_buffer_size() mf_reset() mf_insert_event() mf_remove_event() save_midi_file()


16.7. mf_insert_event()
mf_insert_event(<track>,<pos>,<com-mand>,<byte1>,<byte2>)
Activates an inactive MIDI event in the MIDI object. However, because the command and position are defined in this com-mand, it can be considered as an insertion.
<track> The track into which the event will be inserted
<pos> The position at which the event will be inserted, in ticks
<command> Defines the command type of the event, can be one of the following:
$MIDI_COMMAND_NOTE_ON
$MIDI_COMMAND_POLY_AT
$MIDI_COMMAND_CC
$MIDI_COMMAND_PROGRAM_CHANGE
$MIDI_COMMAND_MONO_AT
$MIDI_COMMAND_PITCH_BEND <byte1> The first byte of the command <byte2> The second byte of the command
Remarks
.
It is not possible to insert MIDI events without first setting an event buffer size with the mf_set_buffer_size() command.

.
Using this command when the buffer is full, i.e. has a size of zero, will do nothing.

.
You can retrieve the event ID of the inserted event in a variable by writing:


<variable> := mf_insert_event(<track>,<pos>,<command>,<byte1>,<byte2>)

See Also
mf_insert_file() mf_set_buffer_size() mf_get_buffer_size() mf_reset() mf_remove_event() save_midi_file()


16.8. mf_remove_event()
mf_remove_event(<event-id>)
Deactivates an event in the MIDI object, effectively removing it <event-id> The ID of the event to be deactivated
Remarks
. Using this command will increase the MIDI event buffer size by one.

See Also
mf_insert_file() mf_set_buffer_size() mf_get_buffer_size() mf_reset() mf_insert_event() save_midi_file()


16.9. mf_set_event_par()
mf_set_event_par(<event-id>,<pa-rameter>,<value>)
Sets an event parameter <event-id>  The ID of the event to be edited
<parameter>  The event parameter, either one of four freely assignable event parame-ters:
$EVENT_PAR_0
$EVENT_PAR_1
$EVENT_PAR_2
$EVENT_PAR_3
Or the "built-in" parameters of a event:
$EVENT_PAR_MIDI_CHANNEL
$EVENT_PAR_MIDI_COMMAND
$EVENT_PAR_MIDI_BYTE_1
$EVENT_PAR_MIDI_BYTE_2
$EVENT_PAR_POS
$EVENT_PAR_NOTE_LENGTH
$EVENT_PAR_TRACK_NR
<value>  The value of the event parameter

Remarks
.
You can control all events in the MIDI object by using the $ALL_EVENTS constant as the event ID.

.
You can access the currently selected event by using the $CURRENT_EVENT constant.

.
You can also control events by track, or group them with markers by using the by_track() and by_mark() commands.



See Also
mf_insert_file() mf_insert_event() mf_remove_event() $ALL_EVENTS $CURRENT_EVENT by_marks() by_track() mf_set_mark() mf_get_id() save_midi_file()


16.10. mf_get_event_par()
mf_get_event_par(<event-id>,<param-eter>)
Returns the value of an event parameter
<event-id> <parameter>
The ID of the event to be edited
The event parameter, either one of four freely assignable event param-eter:
$EVENT_PAR_0 $EVENT_PAR_1 $EVENT_PAR_2 $EVENT_PAR_3
Or the "built-in" parameters of a event:
$EVENT_PAR_MIDI_CHANNEL $EVENT_PAR_MIDI_COMMAND $EVENT_PAR_MIDI_BYTE_1 $EVENT_PAR_MIDI_BYTE_2 $EVENT_PAR_POS $EVENT_PAR_NOTE_LENGTH $EVENT_PAR_ID $EVENT_PAR_TRACK_NR
Remarks
.
You can access all events in the MIDI object by using the $ALL_EVENTS constant as the event ID.

.
You can access the currently selected event by using the $CURRENT_EVENT constant.

.
You can also access events by track, or group them with markers by using the by_track() and by_mark() commands.



See Also
mf_insert_file() mf_insert_event() mf_remove_event() $CURRENT_EVENT mf_get_id() save_midi_file()


16.11. mf_get_id()
mf_get_id()
Returns the ID of the currently selected event, when using the navigation commands like mf_get_first() and mf_get_next(), etc
See Also
mf_get_first() mf_get_next() mf_get_next_at() mf_get_prev() mf_get_prev_at() mf_get_last()

16.12. mf_set_mark()
mf_set_mark(<event-id>,<mark>,<status>)
Marks an event, so that you may group events together and process that group quickly
<event-id> The ID of the event to be marked
<mark> The mark number. Use the constants $MARK_1 to $MARK_10
<status> Set this to 1 to mark an event or to 0 to unmark an event
See Also
mf_insert_file() mf_insert_event() mf_remove_event() $ALL_EVENTS $CURRENT_EVENT mf_get_mark() by_marks()
by_track() mf_get_mark() mf_get_id() save_midi_file()

16.13. mf_get_mark()
mf_get_mark(<event-id>,<mark>)
Checks if an event is marked or not. Returns 1 if it is marked or 0 if it is
not.
<event-id>  The ID of the event to be edited
<mark>  The mark number. Use the constants
$MARK_1 to $MARK_10

See Also
mf_insert_file() mf_insert_event() mf_remove_event() $ALL_EVENTS $CURRENT_EVENT mf_set_mark() by_marks() by_track() mf_get_mark() mf_get_id() save_midi_file()

16.14. by_marks()
by_marks(<mark>)
Can be used to access a user defined group of events <mark> The mark number. Use the constants $MARK_1 to $MARK_10
See Also
mf_insert_file() mf_insert_event() mf_remove_event() $ALL_EVENTS $CURRENT_EVENT mf_set_mark()
mf_get_mark() by_marks() by_track() mf_get_mark() mf_get_id() save_midi_file()

16.15. by_track()
by_track(<track>)
Can be used to group events by their track number <track> The track number of the events you wish to access
Remarks
. Similar in functionality as the by_marks() command.

See Also
mf_insert_file() mf_insert_event() mf_remove_event() $ALL_EVENTS $CURRENT_EVENT mf_set_mark() mf_get_mark() by_marks() mf_get_mark() mf_get_id() save_midi_file()


16.16. mf_get_first()
mf_get_first(<track-index>)
Moves the position marker to the first event in the MIDI track
<track-index> The number of the track you want to edit. -1 refers to the whole file.
Remarks
. Using this command will also select the event at the position marker for editing.
See Also
mf_insert_file() mf_get_next() mf_get_next_at() mf_get_num_tracks() mf_get_last() mf_get_prev() mf_get_prev_at() save_midi_file()

16.17. mf_get_last()
mf_get_last(<track-index>)
Moves the position marker to the last event in the MIDI track
<track-index> The number of the track you want to edit. -1 refers to the whole file.
Remarks
. Using this command will also select the event at the position marker for editing.

See Also
load_midi_file() mf_get_first() mf_get_next() mf_get_next_at() mf_get_num_tracks() mf_get_prev() mf_get_prev_at() save_midi_file()


16.18. mf_get_next()
mf_get_next(<track-index>)
Moves the position marker to the next event in the MIDI track
<track-index> The number of the track you want to edit. -1 refers to the whole file.
Remarks
. Using this command will also select the event at the position marker for editing.
See Also
load_midi_file()
mf_get_first()
mf_get_next_at()
mf_get_num_tracks()
mf_get_last()
mf_get_prev()
mf_get_prev_at()
save_midi_file()
16.19. mf_get_next_at()
mf_get_next_at(<track-index>,<pos>)
Moves the position marker to the next event in the MIDI track right after the
defined position.
<track-index>  The number of the track you want to edit.
-1 refers to the whole file

<pos> Position in ticks

Remarks
. Using this command will also select the event at the position marker for editing.

See Also
load_midi_file() mf_get_first() mf_get_next() mf_get_num_tracks() mf_get_last() mf_get_prev() mf_get_prev_at() save_midi_file()


16.20. mf_get_prev()
mf_get_prev(<track-index>)
Moves the position marker to the previous event in the MIDI track
<track-index> The number of the track you want to edit. -1 refers to the whole file
Remarks
. Using this command will also select the event at the position marker for editing.

See Also
load_midi_file() mf_get_first() mf_get_next() mf_get_next_at() mf_get_num_tracks() mf_get_last() mf_get_prev_at() save_midi_file()


16.21. mf_get_prev_at()
mf_get_prev_at(<track-index>,<pos>)
Moves the position marker to the first event before the defined position
<track-index> The number of the track you want to edit. -1 re-fers to the whole file
<pos> Position in ticks
Remarks
. Using this command will also select the event at the position marker for editing.

See Also
load_midi_file() mf_get_first() mf_get_next() mf_get_next_at() mf_get_num_tracks() mf_get_last() mf_get_prev() save_midi_file()


16.22. mf_get_num_tracks()
mf_get_num_tracks()
Returns the number of tracks in a MIDI object
See Also
mf_insert_file() mf_get_first() mf_get_next() mf_get_next_at() mf_get_last() mf_get_prev() mf_get_prev_at() save_midi_file()



17. BUILT-IN VARIABLES AND CONSTANTS
17.1. General
$CURRENT_SCRIPT_SLOT
The script slot of the current script (zero based, i.e. the first script slot is 0).
%GROUPS_SELECTED[<group-idx>]
An array with each array index pointing to the group with the same index.
If a group is selected for editing, the corresponding array cell contains a 1, otherwise 0.
$NI_ASYNC_EXIT_STATUS
Returns a value of 1 if the command that triggered the on async_complete callback has successfully completed its action. 0 if the command could not complete its action, e.g. file not found.
$NI_ASYNC_ID Returns the ID of the command that triggered the on async_complete callback.
$NI_BUS_OFFSET
To be used in the <generic> part of the engine parameter commands to point to the instrument bus level. Add the index of the bus you wish to address, e.g. $NI_BUS_OFFSET + 2 will point to instrument bus 3.
$NUM_GROUPS
Total amount of groups in an instrument. This is not a constant and thus cannot be used to define the size of an array.
$NUM_OUTPUT_CHANNELS
Total amount of output channels of the respective KONTAKT Multi, not counting Aux channels.
$NUM_ZONES
Total amount of zones in an instrument.
$PLAYED_VOICES_INST
The amount of played voices of the respective instrument.
$PLAYED_VOICES_TOTAL
The amount of played voices all instruments.
Path Variables
$GET_FOLDER_LIBRARY_DIR
If used with an NKI belonging to an encoded library: library folder. If used with an unencoded NKI: the user content directory.
$GET_FOLDER_FACTORY_DIR
The factory folder of KONTAKT, mainly used for loading factory IR samples. Note: this is not the factory library folder!
$GET_FOLDER_PATCH_DIR
The directory in which the patch was saved. If the patch was not saved before, an empty string is returned.
Time Machine Pro Variables Used access the two voice limits (Standard and High Quality) of the Tme Machine Pro, to be used with set_voice_lim-it() and get_voice_limit(). $NI_VL_TMPRO_STANDARD $NI_VL_TMRPO_HQ
$REF_GROUP_IDX
Group index number of the currently viewed group

17.2. Events and MIDI
$ALL_GROUPS Addresses all groups in a disallow_group() and allow_group() function.
$ALL_EVENTS
Addresses all events in functions which deal with an event ID number. This constant also works with MIDI event commands that require a MIDI event ID.
Bit Mark Constants
Bit mark of an event group, to be used with by_marks() $MARK_1 $MARK_2
�c
$MARK_28
%CC[<controller-number>]
Current controller value for the specified controller
$CC_NUM
Controller number of the controller which triggered the callback
%CC_TOUCHED[<controller-number>]
1 if the specified controller value has changed, 0 otherwise
$EVENT_ID
Unique ID number of the event which triggered the callback
$CURRENT_EVENT
The currently selected MIDI event, i.e. the MIDI event at the position marker
$EVENT_NOTE
Note number of the event which triggered the callback
$EVENT_VELOCITY
Velocity of the note which triggered the callback

Event Parameter Constants
Event parameters to be used with set_event_par() and get_event_par() $EVENT_PAR_0 $EVENT_PAR_1 $EVENT_PAR_2 $EVENT_PAR_3 $EVENT_PAR_VOLUME $EVENT_PAR_PAN $EVENT_PAR_TUNE $EVENT_PAR_NOTE $EVENT_PAR_VELOCITY To be used with set_event_par_arr() and get_event_par_arr(): $EVENT_PAR_ALLOW_GROUP To be used with get_event_par(): $EVENT_PAR_SOURCE (-1 if event originates from outside, otherwise slot number 0 - 4) $EVENT_PAR_PLAY_POS (returns the value of the play cursor within a zone) $EVENT_PAR_ZONE_ID (returns the zone ID of the event and can only be used with active events returns -1 if no zone is
triggered; returns the highest zone id if more than one zone is triggered by the event, make sure the voice is running by writ-
ing e.g. wait(1) before retrieving the zone ID.)
Event Parameter Constants
Event parameters to be used with mf_set_event_par() and mf_get_event_par() $EVENT_PAR_0 $EVENT_PAR_1 $EVENT_PAR_2 $EVENT_PAR_3 $EVENT_PAR_MIDI_CHANNEL $EVENT_PAR_MIDI_COMMAND $EVENT_PAR_MIDI_BYTE_1 $EVENT_PAR_MIDI_BYTE_2 $EVENT_PAR_POS $EVENT_PAR_NOTE_LENGTH $EVENT_PAR_ID $EVENT_PAR_TRACK_NR

Event Status Constants
$EVENT_STATUS_INACTIVE $EVENT_STATUS_NOTE_QUEUE $EVENT_STATUS_MIDI_QUEUE
%GROUPS_AFFECTED
An array with the group indices of those groups that are affected by the current Note On or Note Off events.
The size of the array changes depending on the number of groups the event affects, so use the num_elements() command to get the correct array size.
The returned indices come before any allow or disallow group commands, and so it can be used to analyze the mapping of the instrument.
$NOTE_HELD
1 if the key which triggered the callback is still held, 0 otherwise
%POLY_AT[<note-number>]
The polyphonic aftertouch value of the specified note number
$POLY_AT_NUM
The note number of the polyphonic aftertouch note which triggered the callback
$RPN_ADDRESS
The parameter number of a received rpn/nrpn message (0 . 16383)
$RPN_VALUE
The value of a received rpn or nrpn message (0 . 16383)
$VCC_MONO_AT
The value of the virtual CC controller for mono aftertouch (channel pressure)
$VCC_PITCH_BEND
The value of the virtual CC controller for pitch bend
%KEY_DOWN[<note-number>]
Array which contains the current state of all keys. 1 if the key is held, 0 otherwise
%KEY_DOWN_OCT[<note-number>]
1 if a note, independent of the octave, is held. 0 otherwise. Due to this, the note number should be a value between 0 (C) and 11 (B).


17.3. Transport and Timing
$DISTANCE_BAR_START
Returns the time of a note on message in ��sec from the beginning of the current bar with respect to the current tempo.
$DURATION_BAR
Returns the duration in ��sec of one bar with respect to the current tempo.
This variable only works if the clock is running, otherwise it will return a value of zero.
You can also retrieve the duration of one bar by using $SIGNATURE_NUM and $SIGNATURE_DENOM in combination with $DURATION_QUARTER.

$ENGINE_UPTIME
Returns the time period in milliseconds (not microseconds) that has passed since the start of KONTAKT. The engine uptime is calculated from the sample rate and can thus be used in �emusical�f contexts, (eg. building arpeggiators or sequencers) as it remains in sync, even in an offline bounce.
$KSP_TIMER
Returns the time period in microseconds that has passed since the start of KONTAKT.
Can be reset with reset_ksp_timer.
The KSP timer is based on the CPU clock and thus runs at a constant rate, regardless of whether or not KONTAKT is being used in real-time. As such, it should be used to test the efficiency of script and not to make musical calculations, as musical calculations use the $ENGINE_UPTIME timer.
$NI_SONG_POSITION
Returns the host�fs current song position in 960 ticks per quarter note.
$NI_TRANSPORT_RUNNING
1 if the host's transport is running, 0 otherwise
$SIGNATURE_NUM
Numerator of the current time signature, i.e. 4/4
$SIGNATURE_DENOM
Denominator of the current time signature, i.e. 4/4
Tempo Unit Variables
Used to control the unit parameter of time-related controls (e.g. Delay Time, Attack etc.) with engine parameter variables like $ENGINE_PAR_DL_TIME_UNIT. $NI_SYNC_UNIT_ABS $NI_SYNC_UNIT_WHOLE $NI_SYNC_UNIT_WHOLE_TRIPLET $NI_SYNC_UNIT_HALF $NI_SYNC_UNIT_HALF_TRIPLET $NI_SYNC_UNIT_QUARTER $NI_SYNC_UNIT_QUARTER_TRIPLET $NI_SYNC_UNIT_8TH $NI_SYNC_UNIT_8TH_TRIPLET $NI_SYNC_UNIT_16TH $NI_SYNC_UNIT_16TH_TRIPLET $NI_SYNC_UNIT_32ND $NI_SYNC_UNIT_32ND_TRIPLET $NI_SYNC_UNIT_64TH $NI_SYNC_UNIT_64TH_TRIPLET $NI_SYNC_UNIT_256TH $NI_SYNC_UNIT_ZONE (Only applies to the Source Module Speed parameter)
%NOTE_DURATION[<note-number>]
Note length since note-start in microseconds for each key

17.4. Callbacks and UI
Callback Type Variables and Constants
$NI_CALLBACK_ID
Returns the ID number of the callback. Every callback has a unique ID number which remains the same within a function.
$NI_CALLBACK_TYPE
Returns the callback type. Useful for retrieving the callback that triggered a specific function. The following constants are available:
$NI_CB_TYPE_ASYNC_OUT $NI_CB_TYPE_CONTROLLER $NI_CB_TYPE_INIT $NI_CB_TYPE_LISTENER $NI_CB_TYPE_NOTE $NI_CB_TYPE_PERSISTENCE_CHANGED $NI_CB_TYPE_PGS $NI_CB_TYPE_POLY_AT $NI_CB_TYPE_RELEASE $NI_CB_TYPE_RPN/$NI_CB_TYPE_NRPN $NI_CB_TYPE_UI_CONTROL $NI_CB_TYPE_UI_UPDATE $NI_CB_TYPE_MIDI_IN
Listener Constants
Can be used with set_listener() or change_listener_par() to set which signals will trigger the on listener call-back. Can also be used with $NI_SIGNAL_TYPE to determine which signal type triggered the callback. $NI_SIGNAL_TRANSP_STOP $NI_SIGNAL_TRANSP_START $NI_SIGNAL_TIMER_MS $NI_SIGNAL_TIMER_BEAT

Knob Unit Mark Constants
To be used with set_knob_unit(). $KNOB_UNIT_NONE $KNOB_UNIT_DB $KNOB_UNIT_HZ $KNOB_UNIT_PERCENT $KNOB_UNIT_MS $KNOB_UNIT_ST $KNOB_UNIT_OCT
$NI_SIGNAL_TYPE Can be used in the on listener callback to determine which signal type triggered the callback.


17.5. Mathemetical Constants
~NI_MATH_PI
Returns the mathematical constant pi (approx. 3.14159�c)
~NI_MATH_E
Returns the mathematical constant e (approx. 2.71828�c)


18. CONTROL PARAMETER VARIABLES
18.1. General
$CONTROL_PAR_NONE
Nothing will be applied to the control
$CONTROL_PAR_HELP
Sets the help text which is displayed in the info pane when hovering the control
$CONTROL_PAR_PARENT_PANEL
Places a control to a panel. The value should be the UI ID of the panel
Size, Position, and Look
$CONTROL_PAR_POS_X
Sets the horizontal position in pixels
$CONTROL_PAR_POS_Y
Sets the vertical position in pixels
$CONTROL_PAR_GRID_X
Sets the horizontal position in grid units
$CONTROL_PAR_GRID_Y
Sets the vertical position in grid units
$CONTROL_PAR_WIDTH
Sets the width of the control in pixels
$CONTROL_PAR_HEIGHT
Sets the height of the control in pixels
$CONTROL_PAR_GRID_WIDTH
Sets the width of the control in grid units
$CONTROL_PAR_GRID_HEIGHT
Sets the height of the control in grid units
$CONTROL_PAR_HIDE
Sets the hide status. Can be used with the following built in constants: $HIDE_PART_BG (background of knobs, labels, value edits and tables) $HIDE_PART_VALUE (value of knobs) $HIDE_PART_TITLE (title of knobs) $HIDE_PART_MOD_LIGHT (mod ring light of knobs) $HIDE_PART_NOTHING (show all) $HIDE_WHOLE_CONTROL
$CONTROL_PAR_PICTURE
Sets the picture name. An extension is not required for the picture name, neither is the full path. If the NKI references a re-source container, KONTAKT will look for the file in the pictures subfolder. If the NKI does not reference a resource container, it will first look in the user pictures folder (located in user/documents/Native Instruments/Kontakt 6/pictures), then in the KON-TAKT pictures folder.
$CONTROL_PAR_PICTURE_STATE
The picture state of the control for tables, value edits and labels
$CONTROL_PAR_Z_LAYER
Sets the Z layer position of the control. Controls can be placed in one of three layers. Within these layers they are then posi-tioned by type, and then by declaration order.
0: Default layer. All controls are assigned to this layer by default -1: Back layer. Controls in this layer are placed below the default layer
1: Front layer. Controls in this layer are placed on top of the default and back layers.

Values
$CONTROL_PAR_VALUE
Sets/returns the value
$CONTROL_PAR_DEFAULT_VALUE
Sets the default value

Text
$CONTROL_PAR_TEXT Sets the control text, similar to set_text()
$CONTROL_PAR_TEXTLINE Adds a text line, similar to add_text_line()
$CONTROL_PAR_LABEL Sets the knob label, similar to set_knob_label(). This is also the value/string published to the host when using automation. This also works for switches.
$CONTROL_PAR_UNIT Sets the knob unit, similar to set_knob_unit()
$CONTROL_PAR_FONT_TYPE
Sets the font type. Numbers 0 to 24 are used to select any of the 25 factory fonts. Combine with get_font_id() to use custom fonts.
For responsive controls (buttons, switches and menus) the font can also be set separately for each of the control�fs states via the following control parameters:
$CONTROL_PAR_FONT_TYPE_ON $CONTROL_PAR_FONT_TYPE_OFF_PRESSED $CONTROL_PAR_FONT_TYPE_ON_PRESSED $CONTROL_PAR_FONT_TYPE_OFF_HOVER $CONTROL_PAR_FONT_TYPE_ON_HOVER Not using any of the five additional state fonts will result in the default ($CONTROL_PAR_FONT_TYPE) being used for that
state.
$CONTROL_PAR_DISABLE_TEXT_SHIFTING
Deactivates text position shifting when clicking on buttons and switches
$CONTROL_PAR_TEXTPOS_Y
Shifts the vertical position in pixels of text in buttons, menus, switches and labels
$CONTROL_PAR_TEXT_ALIGNMENT
The text alignment in buttons, menus, switches and labels:
0: left
1: centered
2: right

Automation
$CONTROL_PAR_AUTOMATION_NAME Assigns an automation name to a UI control when used with set_control_par_str() $CONTROL_PAR_LABEL can be used to set the automation value string When assigning automation names to XY pad cursors, use the set_control_par_str_arr() command with this param-eter.
$CONTROL_PAR_ALLOW_AUTOMATION
Defines if an ui_control can be automated (1) or not (0). By default automation is enabled for all automatable controls. Can only be used in the init callback.
$CONTROL_PAR_AUTOMATION_ID
Assigns an automation ID to a UI control (range 0 to 511). Can only be used in the init callback. Automation IDs can only be assigned to automatable controls (sliders, switches, and knobs) When assigning automation IDs to XY pad cursors, use the set_control_par_arr() command with this parameter.

Key Modifiers
$CONTROL_PAR_KEY_SHIFT
Returns 1 when the shift key was pressed (0 otherwise) while clicking the UI control. Menus and value edits are not supported. The basic shift modifier functionality on sliders and knobs is preserved.
$CONTROL_PAR_KEY_ALT
Returns 1 if the ALT key (PC) or OPT key (Mac) was pressed (0 otherwise) while clicking the UI control. Menus and value edits are not supported.
$CONTROL_PAR_KEY_CONTROL
Returns 1 if the CTRL key (PC) or Cmd key (Mac) was pressed (0 otherwise) while clicking the UI control. Menus and value edits are not supported.


18.2. Specific Tables
$NI_CONTROL_PAR_IDX Returns the index of the table column that triggered the on ui_control() callback
Tables and Waveform
$CONTROL_PAR_BAR_COLOR
Sets the color of the step bar in UI tables and UI waveforms Colors are set using a hex value in the following format:
9ff0000h {red}
The 9 at the start is just to let KONTAKT know the value is a number. The h at the end is to indicate that it is a hexadecimal value.
$CONTROL_PAR_ZERO_LINE_COLOR
Sets the color of the middle line in UI tables

Menus
$CONTROL_PAR_NUM_ITEMS
Returns the number of menu entries of a specific dropdown menu. Only works with get_control_par().
$CONTROL_PAR_SELECTED_ITEM_IDX
Returns the index of the currently selected menu entry. Only works with get_control_par().

Labels
$CONTROL_PAR_DND_BEHAVIOUR
Using a value of 1 with this variable sets the label as a �gDrag and Drop�h area, allowing the user to export the MIDI object currently held in the script memory by a simple drag and drop action. See the section on MIDI Object Commands for more information on MIDI handling in KSP.

Value Edit
$CONTROL_PAR_SHOW_ARROWS
Hides the arrows of value edits:
0: arrows are hidden
1: arrows are shown

Level Meters
$CONTROL_PAR_BG_COLOR
Sets the background color of the UI level meter.
Colors are set using a hex value in the following format:
9ff0000h {red}
The 9 at the start is just to let KONTAKT know the value is a number. The h at the end is to indicate that it is a hexadecimal value.
$CONTROL_PAR_OFF_COLOR
Sets the second background color of the UI level meter
$CONTROL_PAR_ON_COLOR
Sets the main level meter color of the UI level meter
$CONTROL_PAR_OVERLOAD_COLOR
Sets the color of the level meter�fs overload section
$CONTROL_PAR_PEAK_COLOR
Sets the color of the little bar showing the current peak level
$CONTROL_PAR_VERTICAL
Aligns a UI level meter vertically (1) or horizontally (0, default)

File Browser
$CONTROL_PAR_BASEPATH
Sets the basepath of the UI file browser. This control par can only be used in the init callback. Be careful with the number of subfolders of the basepath as it might take too long to scan the sub file system. The scan process takes place every time the NKI is loaded.
$CONTROL_PAR_COLUMN_WIDTH
Sets the width of the browser columns. This control par can only be used in the init callback.
$CONTROL_PAR_FILEPATH
Sets the actual path of the UI file browser which must be a subpath of the basepath. This control par is useful for recalling the last status of the browser upon loading the instrument. Can only be used in the init callback.
$CONTROL_PAR_FILE_TYPE
Sets the file type for file selector. Can only be used in the init callback. The following file types are available:
$NI_FILE_TYPE_MIDI $NI_FILE_TYPE_AUDIO $NI_FILE_TYPE_ARRAY

Instrument Icon and Wallpaper
$INST_ICON_ID
The (fixed) ID of the instrument icon. It's possible to hide the instrument icon:
set_control_par($INST_ICON_ID,$CONTROL_PAR_HIDE,$HIDE_WHOLE_CONTROL)
It's also possible to load a different picture file for the instrument icon:
set_control_par_str($INST_ICON_ID,$CONTROL_PAR_PICTURE,<file-name>)
$INST_WALLPAPER_ID The (fixed) ID of the instrument wallpaper. It is used in a similar way as $INST_ICON_ID: set_control_par_str ($INST_WALLPAPER_ID,$CONTROL_PAR_PICTURE,<file_name>)
This command can only be used in the init callback. Note that a wallpaper set via script replaces the one set in the instrument options and it will not be checked in the samples missing dialog when loading the wallpaper from a resource container. This command only supports wallpapers that are located within the resource container. If you use it in different script slots then the last wallpaper set will be the one that is loaded.
Waveform
Waveform Flag Constants
To be used with attach_zone()
You can combine flat constants using the bitwise .or.
$UI_WAVEFORM_USE_SLICES  Display the zone�fs slice markers
$UI_WAVEFORM_USE_TABLE  Display a per slice table
Note: this only works if the slice markers are also active
$UI_WAVEFORM_TABLE_IS_BIPOLAR  Make the table bipolar

$UI_WAVEFORM_USE_MIDI_DRAG  Display a MIDI drag and drop icon
Note: this only works if the slice markers are also active
Waveform Property Constants
To be used with get/set_ui_wf_property()
$UI_WF_PROP_PLAY_CURSOR  Sets or returns the play head position

$UI_WF_PROP_FLAGS Used to set new flag constants after the attach_zone() command is used
$UI_WF_PROP_TABLE_VAL Sets or returns the value of the indexed slice�fs table $UI_WF_PROP_TABLE_IDX_HIGHLIGHT Highlights the indexed slice within the UI waveform
$UI_WF_PROP_MIDI_DRAG_START_NOTE Defines the start note for the midi drag & drop function
$CONTROL_PAR_WF_VIS_MODE
Changes the way the waveform is drawn. Valid values:
$NI_WF_VIS_MODE_1 (default) $NI_WF_VIS_MODE_2
$NI_WF_VIS_MODE_3
$CONTROL_PAR_BG_COLOR
Sets the background color of the waveform display Colors are set using a hex value in the following format:
9ff0000h {red}
The 9 at the start is just to let KONTAKT know the value is a number. The h at the end is to indicate that it is a hexadecimal value.
$CONTROL_PAR_WAVE_COLOR
Sets the color of the waveform
$CONTROL_PAR_WAVE_CURSOR_COLOR
Sets the color of the playback cursor
$CONTROL_PAR_SLICEMARKERS_COLOR
Sets the color of the slice markers
$CONTROL_PAR_BG_ALPHA
Sets the alpha channel (opacity) of the background of the widget. Range: 0 (fully transparent) to 255 (fully opaque)

Wavetable
$CONTROL_PAR_WT_VIS_MODE
Sets the mode of the wavetable widget. Can be set to the following values: $NI_WT_VIS_2D (2D, oscilloscope-style visualization, only showing the current wavetable position) $NI_WT_VIS_3D (3D visualization displaying the whole wavetable as well as the the current position)
$CONTROL_PAR_PARALLAX_X
Sets the x-axis parallax of the wavetable control (only applicable to 3D mode) Range: -1000000 to 1000000
$CONTROL_PAR_PARALLAX_Y
Sets the y-axis parallax of the wavetable control (only applicable to 3D mode) Range: -1000000 to 1000000
$CONTROL_PAR_WAVE_COLOR
Sets the color of the waveform
$CONTROL_PAR_WAVE_ALPHA
Sets the alpha channel (opacity) of the waveform. Range: 0 (fully transparent) to 255 (fully opaque)
$CONTROL_PAR_WAVETABLE_COLOR
Sets the color of the whole wavetable
$CONTROL_PAR_WAVETABLE_ALPHA
Sets the alpha channel (opacity) of the whole wavetable Range: 0 (fully transparent) to 255 (fully opaque)
$CONTROL_PAR_BG_COLOR
Sets the background color of the wavetable widget. Colors are set using a hex value in the following format:
9ff0000h {red}
The 9 at the start is just to let KONTAKT know the value is a number. The h at the end is to indicate that it is a hexadecimal value.
$CONTROL_PAR_BG_ALPHA
Sets the alpha channel (opacity) of the background of the widget. Range: 0 (fully transparent) to 255 (fully opaque)
Additional Color and Alpha Parameters
To be paired with the ones above to create gradient effects; if not ex-
plicitly set, they inherit the value of their match from above, resulting in
no gradient.
$CONTROL_PAR_WAVE_END_COLOR  Sets or returns the play head position
$CONTROL_PAR_WAVE_END_ALPHA  Used to set new flag constants after the at-
tach_zone() command is used
$CONTROL_PAR_WAVETABLE_END_COLOR  Sets or returns the value of the indexed slice�fs
table

$CONTROL_PAR_WAVETABLE_END_ALPHA Highlights the indexed slice within the UI wave-form

Slider
$CONTROL_PAR_MOUSE_BEHAVIOUR
A value from -5000 to 5000, setting the move direction of a slider and its drag-scale. Settings are relative to the size of the slider picture. Negative values give a vertical slider behavior, positive values give a horizontal behavior.

XY Pad
$CONTROL_PAR_MOUSE_BEHAVIOUR_X
Mouse behavior, i.e the drag scale, of the x axis of all cursors
$CONTROL_PAR_MOUSE_BEHAVIOUR_Y
Mouse behavior, i.e the drag scale, of the y axis of all cursors
$CONTROL_PAR_MOUSE_MODE
Sets the way the XY pad responds to mouse clicks and drags.
0: Clicks anywhere other than on a cursor are ignored. Clicking on a cursor and dragging, sets new values respecting the usual $CONTROL_PAR_MOUSE_BEHAVIOR settings.
1: Clicks anywhere on the XY pad are registered but don't change the values. Clicking anywhere and dragging, sets new values; the cursor moves parallel to the mouse cursor with distances scaled based on the $CONTROL_PAR_MOUSE_BEHAV-IOR settings.
2: Clicks anywhere on the XY pad are registered and immediately change the values, with the cursor immediately matching the mouse cursor. Clicking anywhere and dragging has a similar effect; the $CONTROL_PAR_MOUSE_BEHAVIOR settings are ignored; cursor always follows mouse cursor one-to-one.
$CONTROL_PAR_ACTIVE_INDEX
Sets and gets the index of the active cursor. Only relevant in multi-cursor set-ups. The $CONTROL_PAR_MOUSE_MODE setting will influence how this parameter behaves:
Mouse Mode = 0 and 1: the active cursor can only be changed manually, by setting this control parameter. Inactive cursors don't receive any clicks.
Mouse Mode = 2: it is set automatically based on the last clicked cursor. Setting it manually from within the ui_control callback of the XY pad can result in unexpected results, but using it in other callbacks is fully encouraged and makes sense in many scenarios. The value is -1 when not clicking on any cursor.
The index can only be an even number (with the exception of the -1 value) that matches the index of the X axis of the cursor in the main array representing the XY control, e.g. the first cursor has an index of 0, the second one has an index of 2, etc
$CONTROL_PAR_CURSOR_PICTURE Sets the cursor image. Each cursor can have its own image set using the set_control_par_str_arr() command. Using $CONTROL_PAR_PICTURE with the XY pad will set the background image of the control. The cursor images can have up to 6 frames, corresponding to the following states. Frame selection is automatic as with but-tons/switches.
1: Inactive
2: Active
3: Inactive pressed
4: Active pressed
5: Inactive mouse over
6: Active mouse over
$HIDE_PART_CURSOR
When used with set_control_par_arr(), this can be used to hide specific cursors in the XY pad. Below is a simple syn-tax example:
if($hide = 1)
 set_control_par_arr($id, $CONTROL_PAR_HIDE, $HIDE_PART_CURSOR, $index) else
 set_control_par_arr($id, $CONTROL_PAR_HIDE, $HIDE_PART_NOTHING, $index) end if
The index should be an even number that matches the index of the X axis of the cursor in the main array representing the XY control, so the first cursor has an index of 0, the second has an index of 2, and so on.
$NI_CONTROL_PAR_IDX
Returns the index of the cursor that triggered the on ui_control() callback for the XY pad. Note that indices are always even numbers starting from 0, so the first cursor has an index of 0, the second has an index of 2, and so on.
$NI_MOUSE_EVENT_TYPE
Returns the type of mouse event that triggered the on ui_control() callback for the XY pad. Can only be used within a on ui_control()callback.
The following file types are available:
$NI_MOUSE_EVENT_TYPE_LEFT_BUTTON_DOWN (click)
$NI_MOUSE_EVENT_TYPE_LEFT_BUTTON_UP (release)
$NI_MOUSE_EVENT_TYPE_DRAG (drag)



19. ENGINE PARAMETER VARIABLES
19.1. Instrument, Source and Amp Module
$ENGINE_PAR_VOLUME
Instrument/group/bus volume
$ENGINE_PAR_PAN
Instrument/group/bus panorama
$ENGINE_PAR_TUNE
Instrument/group/bus tuning
Source Module
$ENGINE_PAR_SMOOTH $ENGINE_PAR_FORMANT $ENGINE_PAR_SPEED $ENGINE_PAR_GRAIN_LENGTH $ENGINE_PAR_SLICE_ATTACK $ENGINE_PAR_SLICE_RELEASE $ENGINE_PAR_TRANSIENT_SIZE $ENGINE_PAR_ENVELOPE_ORDER $ENGINE_PAR_FORMANT_SHIFT $ENGINE_PAR_SPEED_UNIT
$ENGINE_PAR_WT_POSITION $ENGINE_PAR_WT_FORM $ENGINE_PAR_WT_PHASE $ENGINE_PAR_WT_PHASE_RAND
$ENGINE_PAR_WT_QUALITY $NI_WT_QUALITY_LOFI $NI_WT_QUALITY_MEDIUM $NI_WT_QUALITY_HIGH $NI_WT_QUALITY_BEST
$ENGINE_PAR_WT_FORM_MODE $NI_WT_FORM_LINEAR $NI_WT_FORM_SYNC1 $NI_WT_FORM_SYNC2 $NI_WT_FORM_SYNC3 $NI_WT_FORM_BENDP $NI_WT_FORM_BENDM $NI_WT_FORM_BENDMP $NI_WT_FORM_PWM $NI_WT_FORM_ASYMP $NI_WT_FORM_ASYMM $NI_WT_FORM_ASYMMP $NI_WT_FORM_FLIP $NI_WT_FORM_MIRROR $NI_WT_FORM_QUANTIZE
$ENGINE_PAR_WT_INHARMONIC_MODE $ENGINE_PAR_WT_INHARMONIC
$ENGINE_PAR_OUTPUT_CHANNEL
Designates the output for the group or bus. 0 routes to one of KONTAKT�fs outputs. This bypasses the instrument insert effects. -1 routes to the instrument output (default). -2 routes to the instrument output with the instrument insert effects bypassed. $NI_BUS_OFFSET + [0 . 15] routes to one of the busses. Busses cannot be routed to other busses.

19.2. Insert Effects
$ENGINE_PAR_EFFECT_BYPASS
Bypass button of all insert effects
$ENGINE_PAR_INSERT_EFFECT_OUTPUT_GAIN
Output gain of all insert effects
Compressor
$ENGINE_PAR_THRESHOLD $ENGINE_PAR_RATIO $ENGINE_PAR_COMP_ATTACK $ENGINE_PAR_COMP_DECAY
Limiter
$ENGINE_PAR_LIM_IN_GAIN $ENGINE_PAR_LIM_RELEASE
Surround Panner
$ENGINE_PAR_SP_OFFSET_DISTANCE $ENGINE_PAR_SP_OFFSET_AZIMUTH $ENGINE_PAR_SP_OFFSET_X $ENGINE_PAR_SP_OFFSET_Y $ENGINE_PAR_SP_LFE_VOLUME $ENGINE_PAR_SP_SIZE $ENGINE_PAR_SP_DIVERGENCE
Saturation
$ENGINE_PAR_SHAPE
Lo-Fi
$ENGINE_PAR_BITS $ENGINE_PAR_FREQUENCY $ENGINE_PAR_NOISELEVEL $ENGINE_PAR_NOISECOLOR
Stereo Modeller
$ENGINE_PAR_STEREO $ENGINE_PAR_STEREO_PAN
Distortion
$ENGINE_PAR_DRIVE $ENGINE_PAR_DAMPING
Send Levels
$ENGINE_PAR_SENDLEVEL_0 $ENGINE_PAR_SENDLEVEL_1 $ENGINE_PAR_SENDLEVEL_2
<...>
$ENGINE_PAR_SENDLEVEL_7
Skreamer
$ENGINE_PAR_SK_TONE $ENGINE_PAR_SK_DRIVE $ENGINE_PAR_SK_BASS $ENGINE_PAR_SK_BRIGHT $ENGINE_PAR_SK_MIX
Rotator
$ENGINE_PAR_RT_SPEED $ENGINE_PAR_RT_BALANCE $ENGINE_PAR_RT_ACCEL_HI $ENGINE_PAR_RT_ACCEL_LO $ENGINE_PAR_RT_DISTANCE $ENGINE_PAR_RT_MIX
Twang
$ENGINE_PAR_TW_VOLUME $ENGINE_PAR_TW_TREBLE $ENGINE_PAR_TW_MID $ENGINE_PAR_TW_BASS $ENGINE_PAR_TW_BRIGHT $ENGINE_PAR_TW_MONO
Cabinet
$ENGINE_PAR_CB_SIZE $ENGINE_PAR_CB_AIR $ENGINE_PAR_CB_TREBLE $ENGINE_PAR_CB_BASS $ENGINE_PAR_CABINET_TYPE
AET Filter Module
$ENGINE_PAR_EXP_FILTER_MORPH $ENGINE_PAR_EXP_FILTER_AMOUNT
Tape Saturator
$ENGINE_PAR_TP_GAIN $ENGINE_PAR_TP_WARMTH $ENGINE_PAR_TP_HF_ROLLOFF $ENGINE_PAR_TP_QUALITY
Transient Master
$ENGINE_PAR_TR_INPUT $ENGINE_PAR_TR_ATTACK $ENGINE_PAR_TR_SUSTAIN $ENGINE_PAR_TR_SMOOTH
Solid Bus Comp
$ENGINE_PAR_SCOMP_THRESHOLD $ENGINE_PAR_SCOMP_RATIO $ENGINE_PAR_SCOMP_ATTACK $ENGINE_PAR_SCOMP_RELEASE $ENGINE_PAR_SCOMP_MAKEUP $ENGINE_PAR_SCOMP_MIX
Jump Amp
$ENGINE_PAR_JMP_PREAMP $ENGINE_PAR_JMP_BASS $ENGINE_PAR_JMP_MID $ENGINE_PAR_JMP_TREBLE $ENGINE_PAR_JMP_MASTER $ENGINE_PAR_JMP_PRESENCE $ENGINE_PAR_JMP_HIGAIN $ENGINE_PAR_JMP_MONO
Feedback Compressor
$ENGINE_PAR_FCOMP_INPUT $ENGINE_PAR_FCOMP_RATIO $ENGINE_PAR_FCOMP_ATTACK $ENGINE_PAR_FCOMP_RELEASE $ENGINE_PAR_FCOMP_MAKEUP $ENGINE_PAR_FCOMP_MIX $ENGINE_PAR_FCOMP_HQ_MODE $ENGINE_PAR_FCOMP_LINK
ACBox
$ENGINE_PAR_AC_NORMALVOLUME $ENGINE_PAR_AC_BRILLIANTVOLUME $ENGINE_PAR_AC_BASS $ENGINE_PAR_AC_TREBLE $ENGINE_PAR_AC_TONECUT $ENGINE_PAR_AC_TREMOLOSPEED $ENGINE_PAR_AC_TREMOLODEPTH $ENGINE_PAR_AC_MONO
Cat
$ENGINE_PAR_CT_VOLUME $ENGINE_PAR_CT_DISTORTION $ENGINE_PAR_CT_FILTER $ENGINE_PAR_CT_BASS $ENGINE_PAR_CT_BALLS $ENGINE_PAR_CT_TREBLE $ENGINE_PAR_CT_TONE $ENGINE_PAR_CT_MONO
DStortion
$ENGINE_PAR_DS_VOLUME $ENGINE_PAR_DS_TONE $ENGINE_PAR_DS_DRIVE $ENGINE_PAR_DS_BASS $ENGINE_PAR_DS_MID $ENGINE_PAR_DS_TREBLE $ENGINE_PAR_DS_MONO
HotSolo
$ENGINE_PAR_HS_PRENORMAL $ENGINE_PAR_HS_PREOVERDRIVE $ENGINE_PAR_HS_BASS $ENGINE_PAR_HS_MID $ENGINE_PAR_HS_TREBLE $ENGINE_PAR_HS_MASTER $ENGINE_PAR_HS_PRESENCE $ENGINE_PAR_HS_DEPTH $ENGINE_PAR_HS_OVERDRIVE $ENGINE_PAR_HS_MONO
Van51
$ENGINE_PAR_V5_PREGAINRHYTHM $ENGINE_PAR_V5_PREGAINLEAD $ENGINE_PAR_V5_BASS $ENGINE_PAR_V5_MID $ENGINE_PAR_V5_TREBLE $ENGINE_PAR_V5_POSTGAIN $ENGINE_PAR_V5_RESONANCE $ENGINE_PAR_V5_PRESENCE $ENGINE_PAR_V5_LEADCHANNEL $ENGINE_PAR_V5_HIGAIN $ENGINE_PAR_V5_BRIGHT $ENGINE_PAR_V5_CRUNCH $ENGINE_PAR_V5_MONO
Cry Wah
$ENGINE_PAR_CW_MONO $ENGINE_PAR_CW_PEDAL

19.3. Filter and EQ
$ENGINE_PAR_CUTOFF
Cutoff frequency of all filters
$ENGINE_PAR_RESONANCE
Resonance of all filters
$ENGINE_PAR_EFFECT_BYPASS
Bypass button of all filters/EQ
$ENGINE_PAR_GAIN
Gain control for the Ladder and Daft filter types
$ENGINE_PAR_FILTER_LADDER_HQ
High Quality mode for the Ladder filter types
$ENGINE_PAR_BANDWIDTH
Bandwidth control, found on the following filter types: SV Par. LP/HP SV Par. BP/BP SV Ser. LP/HP
3x2 Versatile
$ENGINE_PAR_FILTER_SHIFTB $ENGINE_PAR_FILTER_SHIFTC $ENGINE_PAR_FILTER_RESB $ENGINE_PAR_FILTER_RESC $ENGINE_PAR_FILTER_TYPEA $ENGINE_PAR_FILTER_TYPEB $ENGINE_PAR_FILTER_TYPEC $ENGINE_PAR_FILTER_BYPA $ENGINE_PAR_FILTER_BYPB $ENGINE_PAR_FILTER_BYPC $ENGINE_PAR_FILTER_GAIN
Formant Filters
$ENGINE_PAR_FORMANT_TALK $ENGINE_PAR_FORMANT_SHARP $ENGINE_PAR_FORMANT_SIZE
Simple Filter
$ENGINE_PAR_LP_CUTOFF $ENGINE_PAR_HP_CUTOFF
EQ
$ENGINE_PAR_FREQ1 $ENGINE_PAR_BW1 $ENGINE_PAR_GAIN1 $ENGINE_PAR_FREQ2 $ENGINE_PAR_BW2 $ENGINE_PAR_GAIN2 $ENGINE_PAR_FREQ3 $ENGINE_PAR_BW3 $ENGINE_PAR_GAIN3
Solid G-EQ
$ENGINE_PAR_SEQ_LF_GAIN $ENGINE_PAR_SEQ_LF_FREQ $ENGINE_PAR_SEQ_LF_BELL $ENGINE_PAR_SEQ_LMF_GAIN $ENGINE_PAR_SEQ_LMF_FREQ $ENGINE_PAR_SEQ_LMF_Q $ENGINE_PAR_SEQ_HMF_GAIN $ENGINE_PAR_SEQ_HMF_FREQ $ENGINE_PAR_SEQ_HMF_Q $ENGINE_PAR_SEQ_HF_GAIN $ENGINE_PAR_SEQ_HF_FREQ $ENGINE_PAR_SEQ_HF_BELL

19.4. Send Effects
$ENGINE_PAR_SEND_EFFECT_BYPASS
Bypass button of all send effects
$ENGINE_PAR_SEND_EFFECT_DRY_LEVEL
Dry amount of send effects when used in an insert chain
$ENGINE_PAR_SEND_EFFECT_OUTPUT_GAIN
When used with send effects, this controls either: Wet amount of send effects when used in an insert chain Return amount of send effects when used in a send chain
Phaser
$ENGINE_PAR_PH_DEPTH $ENGINE_PAR_PH_SPEED $ENGINE_PAR_PH_SPEED_UNIT $ENGINE_PAR_PH_PHASE $ENGINE_PAR_PH_FEEDBACK
Flanger
$ENGINE_PAR_FL_DEPTH $ENGINE_PAR_FL_SPEED $ENGINE_PAR_FL_SPEED_UNIT $ENGINE_PAR_FL_PHASE $ENGINE_PAR_FL_FEEDBACK $ENGINE_PAR_FL_COLOR
Chorus
$ENGINE_PAR_CH_DEPTH $ENGINE_PAR_CH_SPEED $ENGINE_PAR_CH_SPEED_UNIT $ENGINE_PAR_CH_PHASE
Reverb
$ENGINE_PAR_RV2_TYPE
 $NI_REVERB2_TYPE_ROOM
 $NI_REVERB2_TYPE_HALL $ENGINE_PAR_RV2_TIME $ENGINE_PAR_RV2_SIZE $ENGINE_PAR_RV2_DAMPING $ENGINE_PAR_RV2_MOD $ENGINE_PAR_RV2_DIFF $ENGINE_PAR_RV2_PREDELAY $ENGINE_PAR_RV2_HIGHCUT $ENGINE_PAR_RV2_LOWSHELF $ENGINE_PAR_RV2_STEREO $ENGINE_PAR_RV2_TYPE
Plate Reverb
$ENGINE_PAR_PR_DECAY $ENGINE_PAR_PR_LOWSHELF $ENGINE_PAR_PR_HIDAMP $ENGINE_PAR_PR_PREDELAY $ENGINE_PAR_PR_STEREO
Legacy Reverb
$ENGINE_PAR_RV_PREDELAY $ENGINE_PAR_RV_SIZE $ENGINE_PAR_RV_COLOUR $ENGINE_PAR_RV_STEREO $ENGINE_PAR_RV_DAMPING
Replika Delay
$ENGINE_PAR_RDL_TYPE
$NI_REPLIKA_TYPE_MODERN
 $NI_REPLIKA_TYPE_TAPE
$NI_REPLIKA_TYPE_VINTAGE
 $NI_REPLIKA_TYPE_DIFFUSION
$NI_REPLIKA_TYPE_ANALOGUE $ENGINE_PAR_RDL_TIME $ENGINE_PAR_RDL_TIME_UNIT $ENGINE_PAR_RDL_FEEDBACK $ENGINE_PAR_RDL_LOWCUT $ENGINE_PAR_RDL_HIGHCUT $ENGINE_PAR_RDL_SATURATION $ENGINE_PAR_RDL_TAPEAGE $ENGINE_PAR_RDL_FLUTTER $ENGINE_PAR_RDL_QUALITY $ENGINE_PAR_RDL_DEPTH $ENGINE_PAR_RDL_RATE $ENGINE_PAR_RDL_TYPE $ENGINE_PAR_RDL_STEREO $ENGINE_PAR_RDL_NOISE $ENGINE_PAR_RDL_PINGPONG $ENGINE_PAR_RDL_AMOUNT $ENGINE_PAR_RDL_SIZE $ENGINE_PAR_RDL_DENSE $ENGINE_PAR_RDL_MODULATION $ENGINE_PAR_RDL_BBDTYPE
Legacy Delay
$ENGINE_PAR_DL_TIME $ENGINE_PAR_DL_TIME_UNIT $ENGINE_PAR_DL_DAMPING $ENGINE_PAR_DL_PAN $ENGINE_PAR_DL_FEEDBACK
Convolution
$ENGINE_PAR_IRC_PREDELAY $ENGINE_PAR_IRC_LENGTH_RATIO_ER $ENGINE_PAR_IRC_FREQ_LOWPASS_ER $ENGINE_PAR_IRC_FREQ_HIGHPASS_ER $ENGINE_PAR_IRC_LENGTH_RATIO_LR $ENGINE_PAR_IRC_FREQ_LOWPASS_LR $ENGINE_PAR_IRC_FREQ_HIGHPASS_LR
Gainer
$ENGINE_PAR_GN_GAIN

19.5. Modulation
$ENGINE_PAR_MOD_TARGET_INTENSITY
The intensity slider of a modulation assignment. This controls the modulation amount.
$MOD_TARGET_INVERT_SOURCE
The Invert button of a modulation assignment. This inverts the modulation amount.
$ENGINE_PAR_INTMOD_BYPASS
The bypass button of an internal modulator, e.g. AHDSR envelope, LFO
$ENGINE_PAR_INTMOD_RETRIGGER
The Retrigger button of a modulation assignment. This restarts the envelope every time a note is received.
AHDSR
$ENGINE_PAR_ATK_CURVE $ENGINE_PAR_ATTACK $ENGINE_PAR_ATTACK_UNIT $ENGINE_PAR_HOLD $ENGINE_PAR_HOLD_UNIT $ENGINE_PAR_DECAY $ENGINE_PAR_DECAY_UNIT $ENGINE_PAR_SUSTAIN $ENGINE_PAR_RELEASE $ENGINE_PAR_RELEASE_UNIT
DBD
$ENGINE_PAR_DECAY1 $ENGINE_PAR_DECAY1_UNIT $ENGINE_PAR_BREAK $ENGINE_PAR_DECAY2 $ENGINE_PAR_DECAY2_UNIT
LFO For all LFOs:
$ENGINE_PAR_INTMOD_FREQUENCY $ENGINE_PAR_INTMOD_FREQUENCY_UNIT $ENGINE_PAR_LFO_DELAY $ENGINE_PAR_LFO_DELAY_UNIT
For Rectangle:
$ENGINE_PAR_INTMOD_PULSEWIDTH
For Multi:
$ENGINE_PAR_LFO_SINE $ENGINE_PAR_LFO_RECT $ENGINE_PAR_LFO_TRI $ENGINE_PAR_LFO_SAW $ENGINE_PAR_LFO_RAND
Glide
$ENGINE_PAR_GLIDE_COEF $ENGINE_PAR_GLIDE_COEF_UNIT

19.6. Module Types and Subtypes
$ENGINE_PAR_EFFECT_TYPE
Used to query the type of a group insert or instrument insert effect. Can be any of the following:
$EFFECT_TYPE_FILTER $EFFECT_TYPE_COMPRESSOR $EFFECT_TYPE_LIMITER $EFFECT_TYPE_INVERTER $EFFECT_TYPE_SURROUND_PANNER $EFFECT_TYPE_SHAPER (Saturation) $EFFECT_TYPE_LOFI $EFFECT_TYPE_STEREO (Stereo Modeller) $EFFECT_TYPE_DISTORTION $EFFECT_TYPE_SEND_LEVELS $EFFECT_TYPE_PHASER $EFFECT_TYPE_CHORUS $EFFECT_TYPE_FLANGER $EFFECT_TYPE_REVERB $EFFECT_TYPE_REVERB2 $EFFECT_TYPE_PLATEREVERB $EFFECT_TYPE_REPLIKA $EFFECT_TYPE_DELAY $EFFECT_TYPE_IRC (Convolution) $EFFECT_TYPE_GAINER $EFFECT_TYPE_SKREAMER $EFFECT_TYPE_ROTATOR $EFFECT_TYPE_TWANG $EFFECT_TYPE_CABINET $EFFECT_TYPE_AET_FILTER $EFFECT_TYPE_TRANS_MASTER $EFFECT_TYPE_BUS_COMP $EFFECT_TYPE_TAPE_SAT $EFFECT_TYPE_SOLID_GEQ $EFFECT_TYPE_JUMP $EFFECT_TYPE_FB_COMP $EFFECT_TYPE_ACBOX $EFFECT_TYPE_CAT $EFFECT_TYPE_DSTORTION $EFFECT_TYPE_HOTSOLO $EFFECT_TYPE_VAN51 $EFFECT_TYPE_CRYWAH $EFFECT_TYPE_NONE (Empty slot)
$ENGINE_PAR_SEND_EFFECT_TYPE
Used to query the type of a send effect, can be any of the following:
$EFFECT_TYPE_PHASER $EFFECT_TYPE_CHORUS $EFFECT_TYPE_FLANGER $EFFECT_TYPE_REVERB $EFFECT_TYPE_DELAY $EFFECT_TYPE_IRC (Convolution) $EFFECT_TYPE_GAINER $EFFECT_TYPE_REPLIKA $EFFECT_TYPE_REVERB2 $EFFECT_TYPE_PLATEREVERB
$EFFECT_TYPE_NONE {empty slot}
$ENGINE_PAR_EFFECT_SUBTYPE
Used to query the type of filter/EQ. Can be any of the following:
$FILTER_TYPE_LP1POLE $FILTER_TYPE_HP1POLE $FILTER_TYPE_BP2POLE $FILTER_TYPE_LP2POLE $FILTER_TYPE_HP2POLE $FILTER_TYPE_LP4POLE $FILTER_TYPE_HP4POLE $FILTER_TYPE_BP4POLE $FILTER_TYPE_BR4POLE $FILTER_TYPE_LP6POLE $FILTER_TYPE_PHASER $FILTER_TYPE_VOWELA $FILTER_TYPE_VOWELB $FILTER_TYPE_PRO52 $FILTER_TYPE_LADDER $FILTER_TYPE_VERSATILE $FILTER_TYPE_EQ1BAND $FILTER_TYPE_EQ2BAND $FILTER_TYPE_EQ3BAND $FILTER_TYPE_DAFT_LP $FILTER_TYPE_SV_LP1 $FILTER_TYPE_SV_LP2 $FILTER_TYPE_SV_LP4 $FILTER_TYPE_LDR_LP1 $FILTER_TYPE_LDR_LP2 $FILTER_TYPE_LDR_LP3 $FILTER_TYPE_LDR_LP4 $FILTER_TYPE_AR_LP2 $FILTER_TYPE_AR_LP4 $FILTER_TYPE_AR_LP24 $FILTER_TYPE_SV_HP1 $FILTER_TYPE_SV_HP2 $FILTER_TYPE_SV_HP4 $FILTER_TYPE_LDR_HP1 $FILTER_TYPE_LDR_HP2 $FILTER_TYPE_LDR_HP3 $FILTER_TYPE_LDR_HP4
$FILTER_TYPE_AR_HP2 $FILTER_TYPE_AR_HP4 $FILTER_TYPE_AR_HP24 $FILTER_TYPE_DAFT_HP $FILTER_TYPE_SV_BP2 $FILTER_TYPE_SV_BP4 $FILTER_TYPE_LDR_BP2 $FILTER_TYPE_LDR_BP4 $FILTER_TYPE_AR_BP2 $FILTER_TYPE_AR_BP4 $FILTER_TYPE_AR_BP24 $FILTER_TYPE_SV_NOTCH4 $FILTER_TYPE_LDR_PEAK $FILTER_TYPE_LDR_NOTCH $FILTER_TYPE_SV_PAR_LPHP $FILTER_TYPE_SV_PAR_BPBP $FILTER_TYPE_SV_SER_LPHP $FILTER_TYPE_FORMANT_1 $FILTER_TYPE_FORMANT_2 $FILTER_TYPE_SIMPLE_LPHP Note that the Solid G-EQ is not treated as a filter/EQ subtype, but as an effect.
$ENGINE_PAR_INTMOD_TYPE
Used to query the type of internal modulators, can be any of the following:
$INTMOD_TYPE_NONE $INTMOD_TYPE_LFO $INTMOD_TYPE_ENVELOPE $INTMOD_TYPE_STEPMOD $INTMOD_TYPE_ENV_FOLLOW $INTMOD_TYPE_GLIDE
$ENGINE_PAR_INTMOD_SUBTYPE
Used to query the sub type of envelopes and LFOs. Can be any of the following:
$ENV_TYPE_AHDSR $ENV_TYPE_FLEX $ENV_TYPE_DBD $LFO_TYPE_RECTANGLE $LFO_TYPE_TRIANGLE $LFO_TYPE_SAWTOOTH $LFO_TYPE_RANDO $LFO_TYPE_MULTI
$ENGINE_PAR_DISTORTION_TYPE
Used to query the sub type of the distortion effect. Can be any of the following:
$NI_DISTORTION_TYPE_TUBE $NI_DISTORTION_TYPE_TRANS Can also be used in the set_engine_par() command to change the distortion type
$ENGINE_PAR_SHAPE_TYPE
Used to query the sub type of saturator (shape) effec. Can be any of the following:
$NI_SHAPE_TYPE_CLASSIC $NI_SHAPE_TYPE_ENHANCED $NI_SHAPE_TYPE_DRUMS Can also be used in the set_engine_par() command to change the saturator type

19.7. Group Start Options Query
Group Start Options Variables
$ENGINE_PAR_START_CRITERIA_MODE $ENGINE_PAR_START_CRITERIA_KEY_MIN $ENGINE_PAR_START_CRITERIA_KEY_MAX $ENGINE_PAR_START_CRITERIA_CONTROLLER $ENGINE_PAR_START_CRITERIA_CC_MIN $ENGINE_PAR_START_CRITERIA_CC_MAX $ENGINE_PAR_START_CRITERIA_CYCLE_CLASS $ENGINE_PAR_START_CRITERIA_ZONE_IDX $ENGINE_PAR_START_CRITERIA_SLICE_IDX $ENGINE_PAR_START_CRITERIA_SEQ_ONLY $ENGINE_PAR_START_CRITERIA_NEXT_CRIT
$ENGINE_PAR_START_CRITERIA_MODE can return one of the following values: $START_CRITERIA_NONE $START_CRITERIA_ON_KEY $START_CRITERIA_ON_CONTROLLER $START_CRITERIA_CYCLE_ROUND_ROBIN $START_CRITERIA_CYCLE_RANDOM $START_CRITERIA_SLICE_TRIGGER
$ENGINE_PAR_START_CRITERIA_NEXT_CRIT can return one of the following values: $START_CRITERIA_AND_NEXT $START_CRITERIA_AND_NOT_NEXT $START_CRITERIA_OR_NEXT


20. ADVANCED CONCEPTS
20.1. Preprocessor & System Scripts
SET_CONDITION(<condition-symbol>)
Define a symbol to be used as a condition
RESET_CONDITION(<condition-symbol>)
Delete a definition
USE_CODE_IF(<condition-symbol>)
...
END_USE_CODE Interpret code when <condition> is defined
USE_CODE_IF_NOT(<condition-symbol>)
...
END_USE_CODE Interpret code when <condition> is not defined
NO_SYS_SCRIPT_GROUP_START Condition; if defined with SET_CONDITION(), the system script which handles all group start options
NO_SYS_SCRIPT_PEDAL
Condition; if defined with SET_CONDITION(), the system script which sustains notes when CC# 64 is received will be by-passed
NO_SYS_SCRIPT_RLS_TRIG
Condition; if defined with SET_CONDITION(), the system script which triggers samples upon the release of a key is by-passed
reset_rls_trig_counter(<note>)
Resets the release trigger counter (used by the release trigger system script)
will_never_terminate(<event-id>) Tells the script engine that this event will never be finished (used by the release trigger system script)
Examples
A preprocessor is used to exclude code elements from interpretation. Here's how it works:
USE_CODE_IF(<condition>)
...
END_USE_CODE
or
USE_CODE_IF_NOT(<condition>)
...
END_USE_CODE
<condition> refers to a symbolic name which consists of alphanumeric symbols, preceded by a letter. You could write for example:
on note
 {do something general} $var := 5
{do some conditional code} USE_CODE_IF_NOT(dont_do_sequencer) while ($count > 0) play_note()
 end while END_USE_CODE end on
What's happening here?
Only if the symbol dont_do_sequencer is not defined, the code between USE_ and END_USE will be processed. If the symbol were to be found, the code would not be passed on to the parser; it is as if the code was never written. Therefore it does not utilize any CPU power.
You can define symbols with
SET_CONDITION(<condition symbol>)
and delete the definition with
RESET_CONDITION(<condition symbol>)
All commands will be interpreted before the script is running, i.e., by using USE_CODE_ , the code might get stalled before it is passed to the script engine. This means, SET_CONDITION and RE-SET_CONDITION are not actually true commands: they cannot be utilized in if()...end if statements; also a wait() statement before those commands is useless. Each SET_CONDITION and RESET_CONDITION will be executed before something else happens.
All defined symbols are passed on to following scripts, i.e. if script 3 contains conditional code, you can turn it on or off in script 1 or 2.
You can use conditional code to bypass system scripts. There are two built-in symbols:
NO_SYS_SCRIPT_PEDAL
NO_SYS_SCRIPT_RLS_TRIG
If you define one of those symbols with SET_CONDITION(), the corresponding part of the system scripts will be bypassed. For clarity reasons, those definitions should always take place in the in-it callback.
on init
 {we want to do our own release triggering}
 SET_CONDITION(NO_SYS_SCRIPT_RLS_TRIG) end on
on release {do something custom here} end on

20.2. PGS
It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script.
PGS commands
pgs_create_key(<key-id>,<size>)
pgs_key_exists(<key-id>)
pgs_set_key_val(<key-id>,<index>,<value>)
pgs_get_key_val(<key-id>,<index>)
<key-id> is similar to a variable name; it can only contain letters and numbers and must not start with a number. It is a good idea to always write them in capitals to emphasize their unique status.
Here's an example, insert this script into any slot:
on init pgs_create_key(FIRST_KEY, 1) {defines a key with 1 element} pgs_create_key(NEXT_KEY, 128) {defines a key with 128 elements} declare ui_button $Just_Do_It
end on
on ui_control($Just_Do_It)
 {writes 70 into the first and only memory location of FIRST_KEY} pgs_set_key_val(FIRST_KEY, 0, 70)
 {writes 50 into the first and 60 into the last memory location of NEXT_KEY} pgs_set_key_val(NEXT_KEY, 0, 50) pgs_set_key_val(NEXT_KEY, 127, 60)
end on
and insert the following script into any other slot:
on init declare ui_knob $First (0,100,1) declare ui_table %Next[128] (5,2,100)
end on on pgs_changed
 {checks if FIRST_KEY and NEXT_KEY have been declared} if(pgs_key_exists(FIRST_KEY) and _pgs_key_exists(NEXT_KEY))
$First := pgs_get_key_val(FIRST_KEY,0) {in this case 70}
 %Next[0] := pgs_get_key_val(NEXT_KEY,0) {in this case 50}
 %Next[127] := pgs_get_key_val(NEXT_KEY,127) {in this case 60}
 end if end on
As illustrated above, there is also a callback that is executed whenever a set_key command has been executed.
on pgs_changed
Callback type, executed whenever any pgs_set_key_val() is executed in any script
It is possible to have as many keys as you want, however each key can only have up to 256 ele-ments.
The basic handling for PGS strings is the same as for normal PGS keys; there�fs only one differ-ence: PGS strings keys aren�ft arrays like the standard PGS keys you already know . they resem-ble normal string variables.
PGS strings commands
pgs_create_str_key(<key-id>)
pgs_str_key_exists(<key-id>)
pgs_set_str_key_val(<key-id>,<stringvalue>)
<stringvalue> := pgs_get_str_key_val(<key-id>)
<key-id> is something similar to a variable name. It can only contain letters and numbers and must not start with a number. It is a good idea to always write them in capitals to emphasize their unique status.
20.3. Zone and Slice Functions
find_zone(<zone-name>)
Returns the zone ID for the specified zone name. Only available in the init callback.
get_sample_length(<zone-ID>)
Returns the length of the specified zone's sample in microseconds
num_slices_zone(<zone-ID>)
Returns the number of slices of the specified zone
zone_slice_length(<zone-ID>,<slice-index>)
Returns the length in microseconds of the specified slice with respect to the current tempo
zone_slice_start(<zone-ID>,<slice-index>)
Returns the absolute start point of the specified slice in microseconds, independent of the current tempo
zone_slice_idx_loop_start(<zone-ID>,<loop-index>)
Returns the index number of the slice at the loop start
zone_slice_idx_loop_end(<zone-ID>,<loop-index>)
Returns the index number of the slice at the loop end
zone_slice_loop_count(<zone-ID>,<loop-index>)
Returns the loop count of the specified loop
dont_use_machine_mode(<ID-number>)
Play the specified event in sampler mode

20.4. User defined Functions
function <function-name>
�c
end function
Declares a function
call <function-name>
Calls a previously declared function
Remarks
The function has to be declared before it is called.

Examples
on init declare $root_note := 60
 declare ui_button $button_1 set_text ($button_1,"Play C Major")
 declare ui_button $button_2 set_text ($button_2,"Play Gb Major")
 declare ui_button $button_3
 set_text ($button_3,"Play C7 (b9,#11)")
end on
function func_play_triad play_note($root_note,100,0,300000) play_note($root_note + 4,100,0,300000) play_note($root_note + 7,100,0,300000)
end function
on ui_control ($button_1) $root_note := 60 call func_play_triad
$button_1 := 0 end on on ui_control ($button_2)
 $root_note := 66 call func_play_triad $button_2 := 0
end on
on ui_control ($button_3) $root_note := 60 call func_play_triad $root_note := 66 call func_play_triad $button_3 := 0
end on
Jazz Harmony 101


20.5. Resource Container
Introduction
The Resource Container is a useful tool for library developers. It is a dedicated location to store scripts, graphics, .nka files and impulse response files that can be referenced by any NKI or group of NKIs that are linked to the container. Another benefit is that you can create a resource container monolith file containing all the scripts, graphics etc, so that you can easily move them around or send them to other team members. When loading an NKI, the resource container is treated like a sample, so if it is not found it will appear in the Samples Missing dialogue.

Setup
To create a Resource Container for your NKI, open up its instrument options and click the <Cre-ate>; button beside the area labeled as Resource Container. After creating a new resource con-tainer file, KONTAKT checks if there is already a resource folder structure available. If there isn�ft, you can let KONTAKT create it for you. If you do this, you will find a Resources and a Data folder next to the NKR file you just created.
The Resources folder is the place where you can store the files that an NKI can use, which are not samples. As you can see KONTAKT has already created several subfolders for you: ir_samples, pictures (for GUI graphics and wallpapers), data (for .nka files) and scripts. The only thing to do now is to move your files into the right folders and you are ready to go.

Working with the Resource Container
Let�fs say you�fre creating a new library: after setting up the Resource Container as described above, you can tell all of the NKIs that are part of your library to use this special Resource Con-tainer. Just open up the NKI�fs instrument options and use the Browse function.
As long as the Resources folder exist besides the NKR file (this is the Resource Container mono-lith), KONTAKT will read all files directly from this folder structure.
For loading scripts from the scripts subfolder, use the �gApply from�c -> Resources folder�h function within the script editor.
Now let�fs say you want to send your current working status to another team member. Open up the instrument options, click the Create button and then overwrite your NKR file. Be aware that this will completely overwrite your monolith, it won�ft be matched in any way. Now KONTAKT will do all of the following:
.
Check the ir_samples subfolder for any .wav, .aif or .aiff files and put them into the monolith.

.
Check the pictures folder for any .tga or .png files that also have a .txt file of the same filename next to them. All of these will be packed into the monolith. Note that wallpapers also need a .txt file or they will be ignored.

.
Check the scripts subfolder for any .txt files which will then be put into the monolith.

.
Check the data subfolder for any .nka files which will then be put into the monolith.


After that rename your Resources folder and reopen your NKI. Now that there is no Resources folder present anymore, KONTAKT will automatically read from the NKR monolith file. If everything is still working as expected you can send your NKIs and the NKR monolith to your team member.
To continue your work just rename the Resources folder back to �gResources�h.

Remarks
.
The Resource Container will be checked in the samples missing dialog.

.
When you save your NKI as a monolith file, the Resource Container will not be integrated into the monolith. The path to the Resource Container will be saved in absolute path mode.




20.6. Changing FX from KSP
Introduction
Prior to Kontakt 5.5, there was already the infrastructure in place to get info about the content of effect slots via engine parameter variables like $ENGINE_PAR_EFFECT_TYPE and built-in con-stants like $EFFECT_TYPE_FILTER (see Module Status Retrieval).
Starting with Kontakt 5.5, it is also possible to change FX with the same set of built-in variables.

Example
on init
 set_engine_par($ENGINE_PAR_EFFECT_TYPE,$EFFECT_TYPE_FILTER,0,0,-1)
 set_engine_par($ENGINE_PAR_EFFECT_SUBTYPE, $FILTER_TYPE_LDR_LP4,0,0,-1) end on
Inserts a 4 pole lowpass ladder filter into the first group slot

on async_complete callback
Changing FX slot contents is an asynchronous operation. This means, one cannot reliably access the newly instantiated effect immediately after instantiation. To resolve this, the command returns an $NI_ASYNC_ID and triggers the on async_complete callback.

Default Filter Type
Filters are somewhat special as they are effect types that feature subtypes. Since one can now instantiate a new filter from KSP without explicitly selecting its subtype, there is the need for a pre-defined default filter subtype. This is the SV LP4.

Implications on Modulation and Automation assignments
When changing the contents of an FX slots through KSP, it is expected that the handling of as-signed automation and modulation is identical to performing the same action using Kontakt's GUI.
.
When changing a slot's effect type or removing it entirely, all modulation and automation as-signments are also removed. Specifically to modulators, if the removed assignments are the only ones of a certain one (i.e., if the modulator is not assigned to other targets as well), the modulator itself is also removed.

.
When changing a slot's effect subtype (only applies to filters), everything is left unchanged. It is accepted that in certain cases, one may end up with "orphaned" modulation assignments as it is the case right now; e.g., when having modulation assigned to a parameter that is no longer available, like Resonance or Gain.



Changing Modulator SubTypes
Using the same commands described above, one can also change the subtype of internal modula-tors. Specifically, one could switch between envelope types (AHDSR, Flex and DBD), or LFO types (Rectangle, Triangle, Sawtooth, Random and Multi). A modulator cannot be inserted or re-moved. Its Type (LFO, Envelope, Step Modulator, Envelope Follower and Glide) cannot be changed either.

Special Cases
There are two effect types that cannot be set from KSP:
.
Surround Panner

.
AET filter




20.7. The Advanced Engine Tab
The Advanced Engine tab can be a useful tool for debugging and measuring the performance of your scripts.
While the Engine tab (a sub-tab of the Expert tab in the Browser Pane) can provide a useful dis-play of performance statistics, the advanced version gives higher accuracy to things like CPU us-age, and also displays information on multiple instances of KONTAKT when it is used as a plug-in.
Displaying the Advanced Engine Tab
As mentioned earlier, the Engine tab is a sub section of the Expert tab, which can be found in the Browser Pane.
.
To access the Advanced Engine tab, hold the [Alt] key while clicking on the Engine tab.

.
To return to the main Engine tab, just click on the Engine tab again with no keys held.



Instance Overview
If you are running multiple instances of KONTAKT as a plug-in in a DAW or host, each instance will be given an entry in this section. If you are using KONTAKT in standalone, only the current instance will be displayed.
There are five performance statistics you can view here:
.
CPU: displays the current CPU load in percent (at a higher resolution than the other CPU read-outs in KONTAKT) as well as the highest recorded peak CPU level (displayed in parenthesis). You can reset the high peak by re-initializing the KONTAKT instance by clicking on the Engine Restart (!) button.

.
Voices: displays the total number of voices currently in use by the KONTAKT instance.

.
Voiceskilled: displays the total number of voices that have been killed due to CPU overload (displayed on the left) and DFD overload (displayed on the right).

.
ProcessBuffer: displays the current audio buffer size in samples.

.
Events: displays the total number of events currently in the event queue. While a voice is the equivalent to a sample being played back, an event is more closely related to MIDI note mes-sages being processed by the engine. For example, a single event could produce 3 voices, if there are 3 samples mapped to a single note. Additionally, if you are holding a MIDI key event though the triggered sample has finished playback, the voice will terminate, but the event will remain in the queue. As such, this display can be useful for tracking down events that are hanging, as these are not always audible in the way that hanging voices would be.



Total
The lower section displays the total performance statistics for all KONTAKT instances currently loaded. It has the following parameters:
.
Voices and Voices killed: like the displays in the Instance Overview, but a total for all instan-ces.

.
DFDload: if you are playing Instruments that use DFD mode, this measures their hard disk ac-cess. It is essentially a more accurate version of the Disk meter in KONTAKT�fs Main Header.

.
DFDmemory: a measurement of how much RAM is being used to process the DFD stream.

.
DFDrequests: the total number of requests made by KONTAKT to read data from the hard disk.






21. MULTI SCRIPT
21.1. General Information
The multi script utilizes the same KSP syntax as the instrument scripts. Here are the main differen-ces:
.
The multi script works on a pure MIDI event basis, i.e., you're working with raw MIDI data.

.
There are no on note, on release and on controller callbacks.

.
Every MIDI event triggers the on midi_in callback.

.
There are various built-in variables for the respective MIDI bytes.


The new multi script tab is accessed by clicking on the "KSP" button in the multi header.
Just as instrument scripts are saved with the instrument, multi scripts are saved with the multi. In relation to GUIs, everything is identical with the instrument script except for the height, which is limited to 3 grid spaces (just like the instrument scripts in KONTAKT 2/3). The scripts are stored in a folder called "multiscripts", which resides next to the already existing "scripts" folder inside the "presets" folder:
/Native Instruments/Kontakt 6/presets/multiscripts
The multi script has only two callback types, the on midi_in callback and the various on ui_control callbacks. Each MIDI event like Note, Controller, Program Change etc. is triggering the on midi_in callback.
It is very important to understand the different internal structure of the event processing in the multi script opposed to the instrument script.
On the instrument level, you can retrieve the event IDs of notes only, i.e., $EVENT_ID only works in the on note and on release callback. On the multi level, any incoming MIDI event has a unique ID which can be retrieved with $EVENT_ID. This means, $EVENT_ID can be a note event, a controller message, a program change command etc.
This brings us to the usage of change_note(), change_velo() etc. commands. Since $EVENT_ID does not necessarily refer to a note event, this commands will not work in the multi script. There will be a command coming soon which enables you to change the MIDI bytes of events without having to ignore them first.
And most important of all, remember that the multi script is nothing more than a MIDI processor, whereas the instrument script is an event processor. A note event in the instrument script is bound to a voice, whereas MIDI events from the multi script are "translated' into note events on the instru-ment level. This simply means that play_note(), change_tune() etc. don't work in the multi script.
You should be familiar with the basic structure of MIDI messages when working with the multi script.

21.2. ignore_midi
ignore_midi
Ignores events
Remarks
.
Like ignore_event(), ignore_midi is a very "strong" command. Keep in mind that ig-nore_midi will ignore all incoming events.

.
If you just want to change the MIDI channel and/or any of the bytes, you can also use set_event_par().



Example
on midi_in if ($MIDI_COMMAND = $MIDI_COMMAND_NOTE_ON and $MIDI_BYTE_2 > 0) ignore_midi end if
 if ($MIDI_COMMAND = $MIDI_COMMAND_NOTE_OFF or ... ($MIDI_COMMAND = $MIDI_COMMAND_NOTE_ON and $MIDI_BYTE_2 = 0)) ignore_midi end if end on
Ignoring note on and note off messages. Note that some keyboards use a note on command with a velocity of 0 to designate a note off command.

See Also
ignore_event()


21.3. on midi_in
on midi_in
MIDI callback, triggered by every incoming MIDI event
Example
on midi_in if ($MIDI_COMMAND = $MIDI_COMMAND_NOTE_ON and $MIDI_BYTE_2 > 0)
 message ("Note On") end if if ($MIDI_COMMAND = $MIDI_COMMAND_NOTE_ON and $MIDI_BYTE_2 = 0)
 message ("Note Off") end if if ($MIDI_COMMAND = $MIDI_COMMAND_NOTE_OFF)
 message ("Note Off")
end if if ($MIDI_COMMAND = $MIDI_COMMAND_CC)
 message ("Controller") end if if ($MIDI_COMMAND = $MIDI_COMMAND_PITCH_BEND)
 message ("Pitch Bend") end if if ($MIDI_COMMAND = $MIDI_COMMAND_MONO_AT)
 message ("Channel Pressure") end if if ($MIDI_COMMAND = $MIDI_COMMAND_POLY_AT)
 message ("Poly Pressure") end if if ($MIDI_COMMAND = $MIDI_COMMAND_PROGRAM_CHANGE)
 message ("Program Change") end if end on
Monitoring various MIDI data

See Also
ignore_midi


21.4. set_midi()
set_midi(<channel>,<command>,<byte-1>, <byte-2>)
Create any type of MIDI event
Remarks
. If you simply want to change the MIDI channel and/or any of the MIDI bytes, you can also use set_event_par().

Example
on midi_in
 if ($MIDI_COMMAND = $MIDI_COMMAND_NOTE_ON and $MIDI_BYTE_2 > 0) set_midi ($MIDI_CHANNEL,$MIDI_COMMAND_NOTE_ON,$MIDI_BYTE_1+4,$MIDI_BYTE_2) set_midi ($MIDI_CHANNEL,$MIDI_COMMAND_NOTE_ON,$MIDI_BYTE_1+7,$MIDI_BYTE_2)
 end if
 if ($MIDI_COMMAND = $MIDI_COMMAND_NOTE_OFF or ... ($MIDI_COMMAND = $MIDI_COMMAND_NOTE_ON and $MIDI_BYTE_2 = 0)) set_midi ($MIDI_CHANNEL,$MIDI_COMMAND_NOTE_ON,$MIDI_BYTE_1+4,0) set_midi ($MIDI_CHANNEL,$MIDI_COMMAND_NOTE_ON,$MIDI_BYTE_1+7,0) end if end on
A simple harmonizer . note that you also have to supply the correct note off commands

See Also
set_event_par() $EVENT_PAR_MIDI_CHANNEL $EVENT_PAR_MIDI_COMMAND $EVENT_PAR_MIDI_BYTE_1 $EVENT_PAR_MIDI_BYTE_2


21.5. Multi Script Variables
$MIDI_CHANNEL
The MIDI channel of the received MIDI event. Since KONTAKT can handle four different MIDI ports, this number can go from 0 - 63 (four ports x 16 MIDI channels).
$MIDI_COMMAND
The command type like Note, CC, Program Change etc. of the received MIDI event. There are various constants for this vari-able (see below).
$MIDI_BYTE_1
$MIDI_BYTE_2
The two MIDI bytes of the message, always in the range 0-127
$MIDI_COMMAND_NOTE_ON $MIDI_BYTE_1 = note number
$MIDI_BYTE_2 = velocity
Note: a velocity value of 0 equals a note off command
$MIDI_COMMAND_NOTE_OFF $MIDI_BYTE_1 = note number
$MIDI_BYTE_2 = release velocity
$MIDI_COMMAND_POLY_AT $MIDI_BYTE_1 = note number
$MIDI_BYTE_2 = polyphonic key pressure value
$MIDI_COMMAND_CC $MIDI_BYTE_1 = controller number
$MIDI_BYTE_2 = controller value
$MIDI_COMMAND_PROGRAM_CHANGE $MIDI_BYTE_1 = program number
$MIDI_BYTE_2 = not used
$MIDI_COMMAND_MONO_AT $MIDI_BYTE_1 = channel pressure value $MIDI_BYTE_2 = not used
$MIDI_COMMAND_PITCH_BEND $MIDI_BYTE_1 = LSB value $MIDI_BYTE_2 = MSB value
$MIDI_COMMAND_RPN/$MIDI_COMMAND_NRPN $MIDI_BYTE_1 = rpn/nrpn address $MIDI_BYTE_2 = rpn/nrpn value
Event Parameter Constants Event parameters to be used with set_event_par() and get_event_par(): $EVENT_PAR_MIDI_CHANNEL $EVENT_PAR_MIDI_COMMAND $EVENT_PAR_MIDI_BYTE_1 $EVENT_PAR_MIDI_BYTE_2


22. VERSION HISTORY
22.1. KONTAKT 6.1.0
New Features
.
New engine parameter for the retrigger button on internal modulators ($ENGINE_PAR_IN-TMOD_RETRIGGER)

.
New waveform visualization modes ($CONTROL_PAR_WF_VIS_MODE with $NI_WF_VIS_MODE_1, $NI_WF_VIS_MODE_2 and $NI_WF_VIS_MODE_3 as values)

.
New Wavetable Mode ($ENGINE_PAR_WT_INHARMONIC_MODE)

.
New UI Control (ui_panel) and related control parameter ($CONTROL_PAR_PARENT_PANEL)

.
New user interface command (load_performance_view()) to load performance views cre-ated on Creator Tools



22.2. KONTAKT 6.0.2
New Features
.
New engine_par constants for new KONTAKT 6 effects.

.
New engine_par constants for new Wavetable mode.

.
New UI control: ui_wavetable including new commands and built-in variables.

.
New commands for variable watching through Creator Tools: watch_var() and watch_ar-ray_idx()

.
New control parameter allows deactivating text position shifts when clicking on buttons and switches: $CONTROL_PAR_DISABLE_TEXT_SHIFTING

.
New command enables use of custom dynamic fonts: get_font_id()

.
New control parameters allow granular control over font types for a button�fs or menu�fs different states: $CONTROL_PAR_FONT_TYPE_ON, $CONTROL_PAR_FONT_TYPE_OFF_PRESSED, $CONTROL_PAR_FONT_TYPE_ON_PRESSED, $CONTROL_PAR_FONT_TYPE_OFF_HOVER and $CONTROL_PAR_FONT_TYPE_ON_HOVER

.
New command allows for quickly disabling emission of messages, warnings or watched varia-ble events to both the Kontakt Status Bar and Creator Tools: disable_logging() with one of the following as the: $NI_LOG_MESSAGE, $NI_LOG_WARNING, $NI_LOG_WATCHING



Improved Features
.
New built-in variable and related built-in constants for the XY Pad allow identification of the mouse events that trigger its callback: $NI_MOUSE_EVENT_TYPE, $NI_MOUSE_EVENT_TYPE_LEFT_BUTTON_DOWN, $NI_MOUSE_EVENT_TYPE_LEFT_BUT-TON_UP and $NI_MOUSE_EVENT_TYPE_DRAG

.
$CONTROL_PAR_TEXTPOS_Y is now allowed on value edit controls.




22.3. KONTAKT 5.8.0 Improved Features
.
It is now possible to have up to three file selectors per script slot.

.
The maximum number of controls per type has now been raised to 512.

.
The maximum size for an array has now been raised to 1000000.


22.4. KONTAKT 5.7 New Features
.
New built-in variable for all UI elements: $CONTROL_PAR_Z_LAYER

.
Waveform styling options: $CONTROL_PAR_WAVE_COLOR, $CONTROL_PAR_BG_COLOR, $CONTROL_PAR_WAVE_CURSOR_COLOR, $CONTROL_PAR_SLICEMARKERS_COLOR, $CON-TROL_PAR_BG_ALPHA

.
Engine parameter variables for new effects: ACBox, Cat, DStortion, HotSolo, Van51.

.
Added engine parameter variables for effect parameters that are buttons.

.
Added engine parameter variables for setting the subtype for the Distortion and Saturator ef-fects: $ENGINE_PAR_DISTORTION_TYPE, $ENGINE_PAR_SHAPE_TYPE


Improved Features
. ui_waveform now accepts $HIDE_PART_BG as a hide_part() and $CONTROL_PAR_HIDE constant.


22.5. KONTAKT 5.6.8 New Features
. New built-in UI variables: $NI_CONTROL_PAR_IDX, $HIDE_PART_CURSOR

22.6. KONTAKT 5.6.5 New Features
.
New UI control: ui_xy Including new built-in variables: $CONTROL_PAR_CURSOR_PICTURE, $CON-TROL_PAR_MOUSE_MODE, $CONTROL_PAR_ACTIVE_INDEX, $CONTROL_PAR_MOUSE_BE-HAVIOUR_X, $CONTROL_PAR_MOUSE_BEHAVIOUR_Y

.
New UI commands: set_control_par_arr() and set_control_par_str_arr()



22.7. KONTAKT 5.6
New Features
.
Support for real numbers, including new ~realVariable and ?realArray[] types.

.
Additional mathematical commands for real numbers.

.
New constants: ~NI_MATH_PI and ~NI_MATH_E

.
New UI commands: set_ui_color() and set_ui_width_px()

.
New control parameter for setting automation IDs via KSP: $CONTROL_PAR_AUTOMATION_ID



22.8. KONTAKT 5.5
New Features
.
New engine parameter variables and built-in constants for controlling the unit parameter of time-related parameters, e.g., $ENGINE_PAR_DL_TIME_UNIT, $NI_SYNC_UNIT_8TH

.
Possible to change FX from KSP by using engine parameter variables for effect type, e.g.


set_engine_par($ENGINE_PAR_EFFECT_TYPE,$EFFECT_TYPE_FILTER,0,0,-1)
See also 'Changing FX from KSP' in 'Advanced Concepts'.
. Possible to set Time Machine Pro voice settings: set_voice_limit(), get_voice_lim-it(), $NI_VL_TMPRO_STANDARD, $NI_VL_TMRPO_HQ

22.9. KONTAKT 5.4.2
Improved Features
. Various manual corrections.

22.10. KONTAKT 5.4.1
New Features
.
New callback type: on persistence_changed

.
New command: set_snapshot_type()

.
New command: make_instr_persistence()

.
New key color constants and command: get_key_color()

.
Ability to set the pressed state of KONTAKT's keyboard: set_key_pressed(), set_key_pressed_support(), get_key_triggerstate()

.
Ability to specify key names and ranges: set_key_name(), get_key_name(), set_key-range(), remove_keyrange()

.
Ability to specify key types: set_key_type(), get_key_type()



Improved Features
.
Data folder in resource container, additional mode for load_array()

.
Usage of load_array_str() in other callbacks.



22.11. KONTAKT 5.3 New Features
. Added Engine Parameter Variables for the new Simple Filter effect.

22.12. KONTAKT 5.2 Improved Features
. Updated file handling.
New Features
. Commands to insert and remove MIDI events.


22.13. KONTAKT 5.1.1 New Features
. Added Engine Parameter Variables for the new Feedback Compressor effect.
22.14. KONTAKT 5.1 New Features
.
New commands: load_array_str(), save_array_str()

.
Added Engine Parameter Variables for the new Jump Amp effect.


Manual Corrections
. Miscellaneous corrections and improvements.


22.15. KONTAKT 5.0.2 New Features
. New Engine Parameter Variables for Time Machine Pro (HQ Mode): $ENGINE_PAR_ENVE-LOPE_ORDER, $ENGINE_PAR_FORMANT_SHIFT

22.16. KONTAKT 5.0.1
New Features
. Added effect type and effect sub-type constants for the new KONTAKT 5 effects.

22.17. KONTAKT 5
New Features
.
MIDI file support including many new commands: load_midi_file(), save_midi_file(), mf_get_num_tracks(), mf_get_first(), mf_get_next(), mf_get_next_at(), mf_get_last(), mf_get_prev(), mf_get_prev_at(), mf_get_channel(), mf_get_command(), mf_get_byte_one(), mf_get_byte_two(), mf_get_pos(), mf_get_track_idx(), mf_set_channel(), mf_set_command(), mf_set_byte_one(), mf_set_byte_two(), mf_set_pos()

.
New UI control: ui_text_edit

.
New UI control: ui_level_meter Including new commands and built-in variables: attach_level_meter(), $CON-TROL_PAR_BG_COLOR, $CONTROL_PAR_OFF_COLOR, $CONTROL_PAR_ON_COLOR, $CON-TROL_PAR_OVERLOAD_COLOR, $CONTROL_PAR_PEAK_COLOR, $CONTROL_PAR_VERTICAL

.
New UI control: ui_file_selector Including new commands and built-in variables: fs_get_filename(), fs_navigate(), $CONTROL_PAR_BASEPATH, $CONTROL_PAR_COLUMN_WIDTH, $CONTROL_PAR_FILEPATH, $CONTROL_PAR_FILE_TYPE

.
New commands for dynamic dropdown menus: get_menu_item_value(), get_menu_item_str(), get_menu_item_visibility(), set_menu_item_value(), set_menu_item_str(), set_menu_item_visibility(), $CONTROL_PAR_SELEC-TED_ITEM_IDX, $CONTROL_PAR_NUM_ITEMS

.
New callback type: on async_complete


Including new built-in variables: $NI_ASYNC_ID, $NI_ASYNC_EXIT_STATUS, $NI_CB_TYPE_ASYNC_OUT
.
New internal constant for KONTAKT's new bus system: $NI_BUS_OFFSET

.
New engine_par constants for new KONTAKT 5 effects.

.
New commands: wait_ticks(), stop_wait()



Improved Features
.
Support for string arrays added for load array() and save_array()

.
PGS support for strings: pgs_create_str_key(), pgs_str_key_exists(), pgs_set_str_key_val(), pgs_get_str_key_val()

.
The maximum height of set_ui_height_px() is now 540 pixels.




22.18. KONTAKT 4.2
New Features
.
The Resource Container, a helpful tool for creating instrument libraries.

.
New ID to set wallpapers via script: $INST_WALLPAPER_ID

.
New key color: $KEY_COLOR_BLACK

.
New callback type: on listener

.
New commands for this callback: set_listener(), change_listener_par()

.
New commands for storing arrays: save_array(), load_array()

.
New command to check the purge status of a group: get_purge_state()

.
New built-in variable: $NI_SONG_POSITION

.
New control parameter: $CONTROL_PAR_ALLOW_AUTOMATION



Improved Features
.
The script editor is now much more efficient, especially with large scripts.

.
New UI control limit: 256 (per control and script).

.
Event parameters can now be used without affecting the system scripts.




22.19. KONTAKT 4.1.2
New Features
.
New UI control: UI waveform

.
New commands for this UI control: set_ui_wf_property(), get_ui_wf_property(), attach_zone()

.
New variables & constants to be used with these commands: $UI_WAVEFORM_USE_SLICES, $UI_WAVEFORM_USE_TABLE, $UI_WAVEFORM_TABLE_IS_BIPOLAR, $UI_WAVE-FORM_USE_MIDI_DRAG, $UI_WF_PROP_PLAY_CURSOR, $UI_WF_PROP_FLAGS, $UI_WF_PROP_TABLE_VAL, $UI_WF_PROP_TABLE_IDX_HIGHLIGHT, $UI_WF_PROP_MIDI_DRAG_START_NOTE

.
New event parameter: $EVENT_PAR_PLAY_POS



22.20. KONTAKT 4.1.1
Improved Features
. The built-in variables $SIGNATURE_NUM and $SIGNATURE_DENOM don't reset to 4/4 if the host's transport is stopped

22.21. KONTAKT 4.1
New Features
.
Implementation of user defined functions: function

.
New control parameter variable: $CONTROL_PAR_AUTOMATION_NAME

.
New command: delete_event_mark()

.
Support for polyphonic aftertouch: on poly_at�cend on, %POLY_AT[], $POLY_AT_NUM

.
New command: get_event_ids()

.
New control parameter variables: $CONTROL_PAR_KEY_SHIFT, $CON-TROL_PAR_KEY_ALT, $CONTROL_PAR_KEY_CONTROL



Improved Features
.
The built-in variable $MIDI_CHANNEL is now also supported in the instrument script.

.
The sample offset parameter in play_note() now also works in DFD mode, according to the S.Mod value set for the respective zone in the wave editor



Manual Corrections
. Correct Modulation Engine Parameter Variables


22.22. KONTAKT 4.0.2
New Features
.
New engine parameter to set the group output channel: $ENGINE_PAR_OUTPUT_CHANNEL

.
New built-in variable: $NUM_OUTPUT_CHANNELS

.
New function: output_channel_name()

.
New built-in variable: $CURRENT_SCRIPT_SLOT

.
New built-in variable: $EVENT_PAR_SOURCE



Improved Features
. The load_ir_sample() command now also accepts single file names for loading IR sam-ples into KONTAKT's convolution effect, i.e. without a path designation. In this case the sample is expected to reside in the folder called "ir_samples" inside the user folder.


22.23. KONTAKT 4
New Features
.
Multiscript

.
New id-based User Interface Controls system: set_control_par(), get_control_par() and get_ui_id()

.
Pixel exact positioning and resizing of UI controls.

.
Skinning of UI controls.

.
New UI controls: switch and slider.

.
Assign colors to KONTAKT's keyboard by using set_key_color()

.
New timing variable: $KSP_TIMER (in microseconds).

.
New path variable: $GET_FOLDER_FACTORY_DIR

.
New hide constants: $HIDE_PART_NOTHING and $HIDE_WHOLE_CONTROL

.
Link scripts to text files.



Improved Features
.
New array size limit: 32768

.
Retrieve and set event parameters for tuning, volume and pan of an event: $EVENT_PAR_TUNE, $EVENT_PAR_VOL and $EVENT_PAR_PAN

.
Larger performance view size: set_ui_height(), set_script_title()

.
Beginning underscores from KONTAKT 2/3 commands like _set_engine_par() can be omitted, i.e. you can write set_engine_par() instead.




22.24. KONTAKT 3.5
New Features
.
Retrieve the status of a particular event: event_status()

.
Hide specific parts of UI controls: hide_part() %GROUPS_SELECTED



Improved Features
.
Support for channel aftertouch: $VCC_MONO_AT

.
New array size limit: 2048




22.25. KONTAKT 3
New Features
.
Offset for wallpaper graphic: _set_skin_offset()

.
Program Global Storage (PGS) for inter-script communication:


_pgs_create_key() _pgs_key_exists() _pgs_set_key_val() _pgs_get_key_val()
.
New callback type: on _pgs_changed

.
Addressing modulators by name: find_mod() and find_target()

.
Change the number of displayed steps in a column: set_table_steps_shown()

.
Info tags for UI controls: set_control_help()



Improved Features
. All five performance views can now be displayed together.


22.26. KONTAKT 2.2
New Features
.
New callback type: on ui_update

.
New built-in variables for group based scripting: $REF_GROUP_IDX and %GROUPS_SELECTED

.
Ability to create custom group start options: NO_SYS_SCRIPT_GROUP_START (+ various Group Start Options Variables).

.
Retrieving the release trigger state of a group: $ENGINE_PAR_RELEASE_TRIGGER

.
Default values for knobs: set_knob_defval()



22.27. KONTAKT 2.1.1
New Features
.
Assign unit marks to knobs: set_knob_unit()

.
Assign text strings to knobs: set_knob_label()

.
Retrieve the knob display: _get_engine_par_disp()



22.28. KONTAKT 2.1
New Features
.
string arrays (! prefix) and string variables (@ prefix)

.
Engine parameter: _set_engine_par()

.
Loading IR samples: _load_ir_sample()

.
Performance View: make_perfview

.
rpn/nrpn implementation:


on rpn & on nrpn $RPN_ADDRESS $RPN_VALUE msb() and lsb() set_rpn() and set_nrpn()
.
Event parameters: set_event_par()

.
New built-in variables:


$NUM_GROUPS $NUM_ZONES $VCC_PITCH_BEND $PLAYED_VOICES_TOTAL $PLAYED_VOICES_INST

Improved Features
.
Possible to name UI controls with set_text()

.
Moving and hiding UI controls.

.
MIDI CCs generated by set_controller() can now also be used for automation, as well as modulation.




22.29. KONTAKT 2
Initial release.


23. INDEX
.!. ! (string variable) 22 .$. $ (constant) 23, 24 $ (polyphonic variable) 25 $ (variable) 17, 19 .%. % (array) 18, 20 .@. @ (string variable) 21 .A. add_menu_item() 99 add_text_line() 100 allow_group() 85 array_equal() 81 attach_level_meter() 101 attach_zone() 102 .B. Bit Operators 48 Boolean Operators 45 by_marks() 186 by_track() 187 .C. change_listener_par() 91 change_note() 63, 64 change_pan() 65 change_tune() 66 change_velo() 67 change_vol() 68 Control Statements 46 Control Statements 42 .D. delete_event_mark() 69 disallow_group() 86 .E. event_status() 70 exit 54 .F. fade_in() 71 fade_out() 72 find_group() 87 find_mod() 148 find_target() 150 fs_get_filename() 104 fs_navigate() 105 function 227 .G. get_control_par() 106 get_engine_par() 151 get_engine_par_disp() 153 get_event_ids() 73 get_event_par() 74 get_event_par_arr() 76 get_folder() 160 get_key_color() 132 get_key_name() 133 get_key_triggerstate() 134 get_key_type() 135 get_keyrange_max_note() 137 get_keyrange_min_note() 136 get_keyrange_name() 138 get_menu_item_str() 107 get_menu_item_value() 108 get_menu_item_visibility() 109 get_purge_state() 88 get_ui_id() 110 get_ui_wf_property() 111 get_voice_limit() 154 group_name() 89 .H. hide_part() 103 .I. if�celse�cend if 42 ignore_controller 55 ignore_event() 77 ignore_midi 232 .L. load_array() 161 load_array_str() 163 load_ir_sample() 165 lsb() 53 .M. make_instr_persistent() 26 make_perfview 112 make_persistent() 27 message() 56 mf_get_buffer_size() 177 mf_get_event_par() 182 mf_get_first() 188 mf_get_id() 183 mf_get_last() 189 mf_get_mark() 185 mf_get_next() 190 mf_get_next_at() 191 mf_get_num_tracks() 194 mf_get_prev() 192 mf_get_prev_at() 193 mf_insert_event() 179 mf_insert_file() 172 mf_remove_event() 180 mf_reset() 178 mf_set_buffer_size() 176 mf_set_event_par() 181 mf_set_export_area() 174 mf_set_mark() 184 move_control() 113 move_control_px() 114 ms_to_ticks() 92 msb() 52 .N. note_off() 57 num_elements() 82 .O. on async_complete 3 on controller 4 on init 5 on listener 7 on midi_in 233 on note 8 on persistence_changed 9 on pgs_changed 10 on poly_at 11 on release 12 on rpn/nrpn 13 on ui_control 14 on ui_update 15 output_channel_name() 155 .P. play_note() 58 Preprocessor 221 purge_group() 90 .R. random() 49, 50, 51 read_persistent_var() 28 remove_keyrange() 147 reset_ksp_timer 95 .S. save_array() 167 save_array_str() 168 save_midi_file() 170 search() 83 select() 43 set_control_help() 115 set_control_par() 116 set_controller() 59 set_engine_par() 156 set_event_mark() 78 set_event_par() 79 set_event_par_arr() 80 set_key_color() 139 set_key_name() 142 set_key_pressed() 143 set_key_pressed_support() 144 set_key_type() 145 set_keyrange() 146 set_knob_defval() 117 set_knob_label() 118 set_knob_unit() 119 set_listener() 93 set_menu_item_str () 120 set_menu_item_value () 121 set_menu_item_visibility () 122 set_midi() 234 set_rpn()/set_nrpn() 60 set_script_title() 124 set_skin_offset() 125 set_snapshot_type() 61 set_table_steps_shown() 123 set_text() 126 set_ui_height() 128 set_ui_height_px() 127, 129, 130 set_ui_wf_property() 131 set_voice_limit() 158 sort() 84 stop_wait() 94 .T. ticks_to_ms() 96 .U. ui_button 29 ui_file_selector 31 ui_knob 30 ui_label 33 ui_level_meter 34 ui_menu 35 ui_slider 36 ui_switch 37 ui_table 38 ui_text_edit 39 ui_value_edit 40 ui_waveform 41 .W. wait() 97 wait_ticks() 98 while() 44


