//
    // Generated by /data/Excel2Completion.py
    //
    export var CompletionList = {
        "make_instr_persistent":
        {
            "snippet_string": "make_instr_persistent( ${1:variable} )",
            "signature":   "make_instr_persistent(variable)",
            "description": "retain the value of a variable only with the instrument"
        },
        "make_instr_persistence":
        {
            "snippet_string": "make_instr_persistence( ${1:variable} )",
            "signature":   "make_instr_persistence(variable)",
            "description": "retain the value of a variable only with the instrument"
        },
        "make_persistent":
        {
            "snippet_string": "make_persistent( ${1:variable} )",
            "signature":   "make_persistent(variable)",
            "description": "retain the value of a variable whith the instrument and snapshot"
        },
        "_read_persistent_var":
        {
            "snippet_string": "_read_persistent_var( ${1:variable} )",
            "signature":   "_read_persistent_var(variable)",
            "description": "instantly reloads the value of a variable that was saved via the make_persistent()command"
        },
        "read_persistent_var":
        {
            "snippet_string": "read_persistent_var( ${1:variable} )",
            "signature":   "read_persistent_var(variable)",
            "description": "instantly reloads the value of a variable that was saved via the make_persistent()command"
        },
        "abs":
        {
            "snippet_string": "abs( ${1:x} )",
            "signature":   "abs(x)",
            "description": "Absolute value"
        },
        "in_range":
        {
            "snippet_string": "in_range( ${1:x}, ${2:y}, ${3:z} )",
            "signature":   "in_range(x,y,z)",
            "description": "Boolean Operator: true if x is between y and z"
        },
        "inc":
        {
            "snippet_string": "inc( ${1:x} )",
            "signature":   "inc(x)",
            "description": "increment an expression by 1 (x + 1)"
        },
        "dec":
        {
            "snippet_string": "dec( ${1:x} )",
            "signature":   "dec(x)",
            "description": "decrement an expression by 1 (x - 1)"
        },
        "mod":
        {
            "snippet_string": "${1:x} mod ${2:y}",
            "signature":   "x mod y",
            "description": "modulo; returns the remainder of a division"
        },
        "exp":
        {
            "snippet_string": "exp( ${1:x} )",
            "signature":   "exp(x)",
            "description": "exponential function (returns the value of e^x)"
        },
        "log":
        {
            "snippet_string": "log( ${1:x} )",
            "signature":   "log(x)",
            "description": "logarithmic function"
        },
        "pow":
        {
            "snippet_string": "pow( ${1:x}, ${2:y} )",
            "signature":   "pow(x,y)",
            "description": "power (returns the value of x^y)"
        },
        "sqrt":
        {
            "snippet_string": "sqrt( ${1:x} )",
            "signature":   "sqrt(x)",
            "description": "square root"
        },
        "ceil":
        {
            "snippet_string": "ceil( ${1:x} )",
            "signature":   "ceil(x)",
            "description": "ceiling (round up) ceil(2.3) = 3.0"
        },
        "floor":
        {
            "snippet_string": "floor( ${1:x} )",
            "signature":   "floor(x)",
            "description": "floor (round down) floor(2.8) = 2.0"
        },
        "round":
        {
            "snippet_string": "round( ${1:x} )",
            "signature":   "round(x)",
            "description": "round (round to nearest) round(2.3) = 2.0 round(2.8) = 3.0"
        },
        "cos":
        {
            "snippet_string": "cos( ${1:x} )",
            "signature":   "cos(x)",
            "description": "cosine function"
        },
        "sin":
        {
            "snippet_string": "sin( ${1:x} )",
            "signature":   "sin(x)",
            "description": "sine function"
        },
        "tan":
        {
            "snippet_string": "tan( ${1:x} )",
            "signature":   "tan(x)",
            "description": "tangent function"
        },
        "acos":
        {
            "snippet_string": "acos( ${1:x} )",
            "signature":   "acos(x)",
            "description": "arccosine function"
        },
        "asin":
        {
            "snippet_string": "asin( ${1:x} )",
            "signature":   "asin(x)",
            "description": "arcsine (inverse sine function)"
        },
        "atan":
        {
            "snippet_string": "atan( ${1:x} )",
            "signature":   "atan(x)",
            "description": "arctangent (inverse tangent function)"
        },
        "bitwise_and":
        {
            "snippet_string": "${1:x} .and. ${2:y}",
            "signature":   "x .and. y",
            "description": "Bitwise Operator: \"and\""
        },
        "bitwise_or":
        {
            "snippet_string": "${1:x} .or. ${2:y}",
            "signature":   "x .or. y",
            "description": "Bitwise Operator: \"or\""
        },
        "bitwise_not":
        {
            "snippet_string": ".not. ${1:x}",
            "signature":   ".not. x",
            "description": "Bitwise Operator: \"negation\""
        },
        "sh_left":
        {
            "snippet_string": "sh_left( ${1:expression}, ${2:shift-bits} )",
            "signature":   "sh_left(expression,shift-bits)",
            "description": "shifts the bits in <expression> by the amount of <shift-bits> to the left"
        },
        "sh_right":
        {
            "snippet_string": "sh_right( ${1:expression}, ${2:shift-bits} )",
            "signature":   "sh_right(expression,shift-bits)",
            "description": "shifts the bits in <expression> by the amount of <shift-bits> to the right"
        },
        "random":
        {
            "snippet_string": "random( ${1:min}, ${2:max} )",
            "signature":   "random(min,max)",
            "description": "generate a random integer in the range <min> to <max>"
        },
        "int_to_real":
        {
            "snippet_string": "int_to_real( ${1:integer value} )",
            "signature":   "int_to_real(integer)",
            "description": "converts an integer value into a real number"
        },
        "real_to_int":
        {
            "snippet_string": "real_to_int( ${1:real value} )",
            "signature":   "real_to_int(real)",
            "description": "converts a real number into an integer"
        },
        "msb":
        {
            "snippet_string": "msb( ${1:value} )",
            "signature":   "msb(value)",
            "description": "return the MSB portion (most significant byte) of a 14 bit value"
        },
        "lsb":
        {
            "snippet_string": "lsb( ${1:value} )",
            "signature":   "lsb(value)",
            "description": "return the LSB portion (least significant byte) of a 14 bit value"
        },
        "exit":
        {
            "snippet_string": "exit",
            "signature":   "exit",
            "description": "immediately stops a callback or exits a function"
        },
        "ignore_controller":
        {
            "snippet_string": "ignore_controller",
            "signature":   "ignore_controller",
            "description": "ignore a controller event in a controller callback"
        },
        "message":
        {
            "snippet_string": "message( ${1:variable/text} )",
            "signature":   "message(variable/text)",
            "description": "display text in the status line of KONTAKT"
        },
        "note_off":
        {
            "snippet_string": "note_off( ${1:ID-number} )",
            "signature":   "note_off(ID-number)",
            "description": "send a note off message to a specific note"
        },
        "play_note":
        {
            "snippet_string": "play_note( ${1:note-number}, ${2:velocity}, ${3:sample-offset}, ${4:duration} )",
            "signature":   "play_note(note-number,velocity,sample-offset,duration)",
            "description": "generate a MIDI note, i.e. generate a note on message followed by a note off message"
        },
        "set_controller":
        {
            "snippet_string": "set_controller( ${1:MIDI CC number/$VCC_PITCH_BEND/$VCC_MONO}, ${2:value} )",
            "signature":   "set_controller(MIDI CC number/$VCC_PITCH_BEND/$VCC_MONO,value)",
            "description": "send a MIDI CC, pitchbend or channel pressure value"
        },
        "set_rpn":
        {
            "snippet_string": "set_rpn( ${1:address}, ${2:value} )",
            "signature":   "set_rpn(address,value)",
            "description": "send a rpn message"
        },
        "set_nrpn":
        {
            "snippet_string": "set_nrpn( ${1:address}, ${2:value} )",
            "signature":   "set_nrpn(address,value)",
            "description": "send a nrpn message"
        },
        "set_snapshot_type":
        {
            "snippet_string": "set_snapshot_type( ${1:type} )",
            "signature":   "set_snapshot_type(type)",
            "description": "configures the KSP processor behavior of all five slots when a snapshot is recalled"
        },
        "by_marks":
        {
            "snippet_string": "by_marks( ${1:bit-mask} )",
            "signature":   "by_marks(bit-mask)",
            "description": "a user defined group of events (or event IDs)"
        },
        "change_note":
        {
            "snippet_string": "change_note( ${1:ID-number}, ${2:note-number} )",
            "signature":   "change_note(ID-number,note-number)",
            "description": "change the note number of a specific note event"
        },
        "change_pan":
        {
            "snippet_string": "change_pan( ${1:ID-number}, ${2:panorama}, ${3:relative-bit} )",
            "signature":   "change_pan(ID-number,panorama,relative-bit)",
            "description": "change the pan position of a specific note event"
        },
        "change_tune":
        {
            "snippet_string": "change_tune( ${1:ID-number}, ${2:tune-amount}, ${3:relative-bit} )",
            "signature":   "change_tune(ID-number,tune-amount,relative-bit)",
            "description": "change the tuning of a specific note event in millicent"
        },
        "change_velo":
        {
            "snippet_string": "change_velo( ${1:ID-number}, ${2:velocity} )",
            "signature":   "change_velo(ID-number,velocity)",
            "description": "change the velocity of a specific note event"
        },
        "change_vol":
        {
            "snippet_string": "change_vol( ${1:ID-number}, ${2:volume}, ${3:relative-bit} )",
            "signature":   "change_vol(ID-number,volume,relative-bit)",
            "description": "change the volume of a specific note event in millidecibel"
        },
        "delete_event_mark":
        {
            "snippet_string": "delete_event_mark( ${1:ID-number}, ${2:bit-mark} )",
            "signature":   "delete_event_mark(ID-number,bit-mark)",
            "description": "delete an event mark, i.e. ungroup the specified event from an event group"
        },
        "event_status":
        {
            "snippet_string": "event_status( ${1:ID-number} )",
            "signature":   "event_status(ID-number)",
            "description": "retrieve the status of a particular note event (or MIDI event in the multi script)"
        },
        "fade_in":
        {
            "snippet_string": "fade_in( ${1:ID-number}, ${2:fade-time} )",
            "signature":   "fade_in(ID-number,fade-time)",
            "description": "perform a fade-in for a specific note event"
        },
        "fade_out":
        {
            "snippet_string": "fade_out( ${1:ID-number}, ${2:fade-time} )",
            "signature":   "fade_out(ID-number,fade-time)",
            "description": "perform a fade-out for a specific note event"
        },
        "get_event_mark":
        {
            "snippet_string": "get_event_mark( ${1:ID-number}, ${2:bit-mark} )",
            "signature":   "get_event_mark(ID-number,bit-mark)",
            "description": "Check if the specified event belongs to a specific event group (returns 1 if the bitmark is set, 0 otherwise)"
        },
        "get_event_ids":
        {
            "snippet_string": "get_event_ids( ${1:array-name} )",
            "signature":   "get_event_ids(array-name)",
            "description": "fills the specified array with all active event IDs."
        },
        "get_event_par":
        {
            "snippet_string": "get_event_par( ${1:ID-number}, ${2:parameter} )",
            "signature":   "get_event_par(ID-number,parameter)",
            "description": "return the value of a specific event parameter of the specified event"
        },
        "get_event_par_arr":
        {
            "snippet_string": "get_event_par_arr( ${1:ID-number}, ${2:parameter}, ${3:group-index} )",
            "signature":   "get_event_par_arr(ID-number,parameter,group-index)",
            "description": "special form of get_event_par(), used to retrieve the group allow state of the specified event"
        },
        "ignore_event":
        {
            "snippet_string": "ignore_event( ${1:ID-number} )",
            "signature":   "ignore_event(ID-number)",
            "description": "ignore a note event in a note on or note off callback"
        },
        "redirect_output":
        {
            "snippet_string": "redirect_output( ${1:ID-number}, ${2:output-type}, ${3:index} )",
            "signature":   "redirect_output(ID-number,output-type,index)",
            "description": "Routes the audio signal of the specified event to a specific output or bus"
        },
        "set_event_mark":
        {
            "snippet_string": "set_event_mark( ${1:ID-number}, ${2:bit-mark} )",
            "signature":   "set_event_mark(ID-number,bit-mark)",
            "description": "Assign the specified event to a specific event group"
        },
        "set_event_par":
        {
            "snippet_string": "set_event_par( ${1:ID-number}, ${2:parameter}, ${3:value} )",
            "signature":   "set_event_par(ID-number,parameter,value)",
            "description": "assign a parameter to a specific event"
        },
        "set_event_par_arr":
        {
            "snippet_string": "set_event_par_arr( ${1:ID-number}, ${2:parameter}, ${3:value}, ${4:group-index} )",
            "signature":   "set_event_par_arr(ID-number,parameter,value,group-index)",
            "description": "special form of set_event_par(), used to set the group allow state of the specified event"
        },
        "array_equal":
        {
            "snippet_string": "array_equal( ${1:array-variable}, ${2:array-variable} )",
            "signature":   "array_equal(array-variable,array-variable)",
            "description": "checks the values of two arrays, true if all values are equal, false if not"
        },
        "num_elements":
        {
            "snippet_string": "num_elements( ${1:array-variable} )",
            "signature":   "num_elements(array-variable)",
            "description": "returns the number of elements in an array"
        },
        "search":
        {
            "snippet_string": "search( ${1:array-variable}, ${2:value} )",
            "signature":   "search(array-variable,value)",
            "description": "searches the specified array for the specified value and returns the index of its first position."
        },
        "sort":
        {
            "snippet_string": "sort( ${1:array-variable}, ${2:direction} )",
            "signature":   "sort(array-variable,direction)",
            "description": "searches the specified array for the specified value and returns the index of its first position."
        },
        "allow_group":
        {
            "snippet_string": "allow_group( ${1:group-index} )",
            "signature":   "allow_group(group-index)",
            "description": "allows the specified group, i.e. makes it available for playback"
        },
        "disallow_group":
        {
            "snippet_string": "disallow_group( ${1:group-index} )",
            "signature":   "disallow_group(group-index)",
            "description": "disallows the specified group, i.e. makes it unavailable for playback"
        },
        "find_group":
        {
            "snippet_string": "find_group( ${1:group-name} )",
            "signature":   "find_group(group-name)",
            "description": "returns the group index for the specified group name"
        },
        "get_purge_state":
        {
            "snippet_string": "get_purge_state( ${1:group-index} )",
            "signature":   "get_purge_state(group-index)",
            "description": "returns the purge state of the specified group. 0=purged, 1=not purged"
        },
        "group_name":
        {
            "snippet_string": "group_name( ${1:group-index} )",
            "signature":   "group_name(group-index)",
            "description": "returns the group name for the specified group"
        },
        "purge_group":
        {
            "snippet_string": "purge_group( ${1:group-index}, ${2:mode} )",
            "signature":   "purge_group(group-index,mode)",
            "description": "purges (i.e. unloads from RAM) the samples of the specified group"
        },
        "change_listener_par":
        {
            "snippet_string": "change_listener_par( ${1:signal-type}, ${2:parameter} )",
            "signature":   "change_listener_par(signal-type,parameter)",
            "description": "changes the parameters of the on listener callback. Can be used in every callback."
        },
        "ms_to_ticks":
        {
            "snippet_string": "ms_to_ticks( ${1:microseconds} )",
            "signature":   "ms_to_ticks(microseconds)",
            "description": "converts a microseconds value into a tempo dependent ticks value"
        },
        "set_listener":
        {
            "snippet_string": "set_listener( ${1:signal-type}, ${2:parameter} )",
            "signature":   "set_listener(signal-type,parameter)",
            "description": "Sets the signals on which the listener callback should react to. Can only be used in the init callback."
        },
        "stop_wait":
        {
            "snippet_string": "stop_wait( ${1:callback-ID}, ${2:parameter} )",
            "signature":   "stop_wait(callback-ID,parameter)",
            "description": "stops wait commands in the specified callback"
        },
        "reset_ksp_timer":
        {
            "snippet_string": "reset_ksp_timer",
            "signature":   "reset_ksp_timer",
            "description": "resets the KSP timer ($KSP_TIMER) to zero"
        },
        "ticks_to_ms":
        {
            "snippet_string": "ticks_to_ms( ${1:ticks} )",
            "signature":   "ticks_to_ms(ticks)",
            "description": "converts a tempo dependent ticks value into a microseconds value"
        },
        "wait":
        {
            "snippet_string": "wait( ${1:wait-time} )",
            "signature":   "wait(wait-time)",
            "description": "pauses the callback for the specified time in microseconds"
        },
        "wait_async":
        {
            "snippet_string": "wait_async( ${1:asyncID} )",
            "signature":   "wait_async(asyncID)",
            "description": "waits until the async command identified by the <asyncID> is finished"
        },
        "wait_ticks":
        {
            "snippet_string": "wait_ticks( ${1:wait-time} )",
            "signature":   "wait_ticks(wait-time)",
            "description": "pauses the callback for the specified time in ticks"
        },
        "add_menu_item":
        {
            "snippet_string": "add_menu_item( ${1:variable}, ${2:text}, ${3:value} )",
            "signature":   "add_menu_item(variable,text,value)",
            "description": "create a menu entry"
        },
        "add_text_line":
        {
            "snippet_string": "add_text_line( ${1:variable}, ${2:text} )",
            "signature":   "add_text_line(variable,text)",
            "description": "add a new text line in the specified label without erasing existing text"
        },
        "attach_level_meter":
        {
            "snippet_string": "attach_level_meter( ${1:ui-ID}, ${2:group}, ${3:slot}, ${4:channel}, ${5:bus} )",
            "signature":   "attach_level_meter(ui-ID,group,slot,channel,bus)",
            "description": "attach a level meter to a certain position within the instrument to read volume data"
        },
        "attach_zone":
        {
            "snippet_string": "attach_zone( ${1:variable}, ${2:zone-id}, ${3:flags} )",
            "signature":   "attach_zone(variable,zone-id,flags)",
            "description": "connects the corresponding zone to the waveform so that it shows up within the display"
        },
        "hide_part":
        {
            "snippet_string": "hide_part( ${1:variable}, ${2:hide-mask} )",
            "signature":   "hide_part(variable,hide-mask)",
            "description": "hide specific parts of user interface controls"
        },
        "fs_get_filename":
        {
            "snippet_string": "fs_get_filename( ${1:ui-ID}, ${2:return-parameter} )",
            "signature":   "fs_get_filename(ui-ID,return-parameter)",
            "description": "return the filename of the last selected file in the UI file browser."
        },
        "fs_navigate":
        {
            "snippet_string": "fs_navigate( ${1:ui-ID}, ${2:direction} )",
            "signature":   "fs_navigate(ui-ID,direction)",
            "description": "jump to the next/previous file in an ui file selector and trigger its callback."
        },
        "get_control_par":
        {
            "snippet_string": "get_control_par( ${1:ui-ID}, ${2:control-parameter} )",
            "signature":   "get_control_par(ui-ID,control-parameter)",
            "description": "retrieve various parameters of the specified gui control"
        },
        "get_menu_item_str":
        {
            "snippet_string": "get_menu_item_str( ${1:menu-ID}, ${2:index} )",
            "signature":   "get_menu_item_str(menu-ID,index)",
            "description": "returns the string value of the menu's entry."
        },
        "get_menu_item_value":
        {
            "snippet_string": "get_menu_item_value( ${1:menu-ID}, ${2:index} )",
            "signature":   "get_menu_item_value(menu-ID,index)",
            "description": "returns the value of the menu's entry."
        },
        "get_menu_item_visibility":
        {
            "snippet_string": "get_menu_item_visibility( ${1:menu-ID}, ${2:index} )",
            "signature":   "get_menu_item_visibility(menu-ID,index)",
            "description": "returns 1 if the menu entry is visible, otherwise 0."
        },
        "get_ui_id":
        {
            "snippet_string": "get_ui_id( ${1:variable} )",
            "signature":   "get_ui_id(variable)",
            "description": "retrieve the ID number of an ui control"
        },
        "get_ui_wf_property":
        {
            "snippet_string": "get_ui_wf_property( ${1:variable}, ${2:property}, ${3:index} )",
            "signature":   "get_ui_wf_property(variable,property,index)",
            "description": "returns the value of the waveform's different properties."
        },
        "load_performance_view":
        {
            "snippet_string": "load_performance_view( ${1:filename} )",
            "signature":   "load_performance_view(filename)",
            "description": "Loads a performance view file (NCKP) that was created in the Creator Tools GUI Designer <filename>. The filename of the NCKP file, without extension, as a string (in quotation marks)"
        },
        "make_perfview":
        {
            "snippet_string": "make_perfview",
            "signature":   "make_perfview",
            "description": "activates the performance view for the respective script"
        },
        "move_control":
        {
            "snippet_string": "move_control( ${1:variable}, ${2:x-position}, ${3:y-position} )",
            "signature":   "move_control(variable,x-position,y-position)",
            "description": "position ui elements in the standard KONTAKT grid"
        },
        "move_control_px":
        {
            "snippet_string": "move_control_px( ${1:variable}, ${2:x-position}, ${3:y-position} )",
            "signature":   "move_control_px(variable,x-position,y-position)",
            "description": "position ui elements in pixels"
        },
        "set_control_help":
        {
            "snippet_string": "set_control_help( ${1:variable}, ${2:text} )",
            "signature":   "set_control_help(variable,text)",
            "description": "assigns a text string to be displayed when hovering the ui control. The text will appear in KONTAKT's info pane."
        },
        "set_control_par":
        {
            "snippet_string": "set_control_par( ${1:ui-ID}, ${2:control-parameter}, ${3:value} )",
            "signature":   "set_control_par(ui-ID,control-parameter,value)",
            "description": "change various parameters of the specified gui control"
        },
        "set_control_par_str":
        {
            "snippet_string": "set_control_par_str_arr( ${1:ui-ID}, ${2:CONTROL_PAR_xxx}, ${3:value} )",
            "signature":   "set_control_par_str_arr(ui-ID,CONTROL_PAR_xxx,value)",
            "description": "A variation of the command for usage with text strings. ( see: set_control_par() Remarks)"
        },
        "set_control_par_arr":
        {
            "snippet_string": "set_control_par_arr( ${1:ui-ID}, ${2:control-parameter}, ${3:value}, ${4:index} )",
            "signature":   "set_control_par_arr(ui-ID,control-parameter,value,index)",
            "description": "change various parameters of an element within an array based gui control (for example: cursors in the XY pad)"
        },
        "set_control_par_str_arr":
        {
            "snippet_string": "set_control_par_str_arr( ${1:ui-ID}, ${2:control-parameter}, ${3:value}, ${4:index} )",
            "signature":   "set_control_par_str_arr(ui-ID,control-parameter,value,index)",
            "description": "A variation of the command for usage with text strings. ( see: set_control_par_arr() Remarks)"
        },
        "set_knob_defval":
        {
            "snippet_string": "set_knob_defval( ${1:variable}, ${2:value} )",
            "signature":   "set_knob_defval(variable,value)",
            "description": "assign a default value to a knob to which the knob is reset when Cmd-clicking (mac) or Ctrl-clicking (PC) the knob."
        },
        "set_knob_label":
        {
            "snippet_string": "set_knob_label( ${1:variable}, ${2:text} )",
            "signature":   "set_knob_label(variable,text)",
            "description": "assign a text string to a knob"
        },
        "set_knob_unit":
        {
            "snippet_string": "set_knob_unit( ${1:variable}, ${2:knob-unit-constant} )",
            "signature":   "set_knob_unit(variable,knob-unit-constant)",
            "description": "assign a unit mark to a knob."
        },
        "set_menu_item_str":
        {
            "snippet_string": "set_menu_item_str( ${1:menu-id}, ${2:index}, ${3:string} )",
            "signature":   "set_menu_item_str(menu-id,index,string)",
            "description": "sets the value of a menu entry."
        },
        "set_menu_item_value":
        {
            "snippet_string": "set_menu_item_value( ${1:menu-id}, ${2:index}, ${3:value} )",
            "signature":   "set_menu_item_value(menu-id,index,value)",
            "description": "sets the value of a menu entry."
        },
        "set_menu_item_visibility":
        {
            "snippet_string": "set_menu_item_visibility( ${1:menu-id}, ${2:index}, ${3:visibility} )",
            "signature":   "set_menu_item_visibility(menu-id,index,visibility)",
            "description": "sets the visibility of a menu entry."
        },
        "set_table_steps_shown":
        {
            "snippet_string": "set_table_steps_shown( ${1:variable}, ${2:num-of-steps} )",
            "signature":   "set_table_steps_shown(variable,num-of-steps)",
            "description": "changes the number of displayed columns in an ui table"
        },
        "set_script_title":
        {
            "snippet_string": "set_script_title( ${1:text} )",
            "signature":   "set_script_title(text)",
            "description": "set the script title"
        },
        "_set_skin_offset":
        {
            "snippet_string": "_set_skin_offset( ${1:offset-in-pixel} )",
            "signature":   "_set_skin_offset(offset-in-pixel)",
            "description": "offsets the chosen background picture file by the specified number of pixels"
        },
        "set_skin_offset":
        {
            "snippet_string": "set_skin_offset( ${1:offset-in-pixel} )",
            "signature":   "set_skin_offset(offset-in-pixel)",
            "description": "offsets the chosen background picture file by the specified number of pixels"
        },
        "set_text":
        {
            "snippet_string": "set_text( ${1:variable}, ${2:text} )",
            "signature":   "set_text(variable,text)",
            "description": "when applied to a label: delete the text currently visible in the specified label and add new text.\nwhen applied to knobs, buttons, switches and value edits: set the display name of the ui element.\n"
        },
        "set_ui_color":
        {
            "snippet_string": "set_ui_color( ${1:hex-values}, ${2:text} )",
            "signature":   "set_ui_color(hex-values,text)",
            "description": "set the main background color of the performance view"
        },
        "set_ui_height":
        {
            "snippet_string": "set_ui_height( ${1:height} )",
            "signature":   "set_ui_height(height)",
            "description": "set the height of a script performance view in grid units"
        },
        "set_ui_height_px":
        {
            "snippet_string": "set_ui_height_px( ${1:height} )",
            "signature":   "set_ui_height_px(height)",
            "description": "set the height of a script performance view in pixels"
        },
        "set_ui_width_px":
        {
            "snippet_string": "set_ui_width_px( ${1:width} )",
            "signature":   "set_ui_width_px(width)",
            "description": "set the width of a script performance view in pixels"
        },
        "set_ui_wf_property":
        {
            "snippet_string": "set_ui_wf_property( ${1:variable}, ${2:property}, ${3:index}, ${4:value} )",
            "signature":   "set_ui_wf_property(variable,property,index,value)",
            "description": "sets different properties for the waveform control"
        },
        "get_font_id":
        {
            "snippet_string": "get_font_id( ${1:id} )",
            "signature":   "get_font_id(id)",
            "description": "Enables use of custom dynamic fonts"
        },
        "get_key_color":
        {
            "snippet_string": "get_key_color( ${1:note-nr} )",
            "signature":   "get_key_color(note-nr)",
            "description": "returns the color constant of the specified note number"
        },
        "get_key_name":
        {
            "snippet_string": "get_key_name( ${1:note-nr} )",
            "signature":   "get_key_name(note-nr)",
            "description": "returns the name of the specified key"
        },
        "get_key_triggerstate":
        {
            "snippet_string": "get_key_triggerstate( ${1:note-nr} )",
            "signature":   "get_key_triggerstate(note-nr)",
            "description": "returns the pressed state of the specified note number (i.e. key) on the KONTAKT keyboard, can be either 1 (key pressed) or 0 (key released)"
        },
        "get_key_type":
        {
            "snippet_string": "get_key_type( ${1:note-nr} )",
            "signature":   "get_key_type(note-nr)",
            "description": "returns the key type constant of the specified key."
        },
        "get_keyrange_min_note":
        {
            "snippet_string": "get_keyrange_min_note( ${1:note-nr} )",
            "signature":   "get_keyrange_min_note(note-nr)",
            "description": "returns the lowest note of the specified key range"
        },
        "get_keyrange_max_note":
        {
            "snippet_string": "get_keyrange_max_note( ${1:note-nr} )",
            "signature":   "get_keyrange_max_note(note-nr)",
            "description": "returns the highest note of the specified key range"
        },
        "get_keyrange_name":
        {
            "snippet_string": "get_keyrange_name( ${1:note-nr} )",
            "signature":   "get_keyrange_name(note-nr)",
            "description": "returns the name of the specified key range"
        },
        "set_key_color":
        {
            "snippet_string": "set_key_color( ${1:note-nr}, ${2:key-color-constant} )",
            "signature":   "set_key_color(note-nr,key-color-constant)",
            "description": "sets the color of the specified key (i.e. MIDI note) on the KONTAKT keyboard. use $KEY_COLOR_****"
        },
        "set_key_name":
        {
            "snippet_string": "set_key_name( ${1:note-nr}, ${2:name} )",
            "signature":   "set_key_name(note-nr,name)",
            "description": "assigns a text string to the specified key"
        },
        "set_key_pressed":
        {
            "snippet_string": "set_key_pressed( ${1:note-nr}, ${2:value} )",
            "signature":   "set_key_pressed(note-nr,value)",
            "description": "sets the trigger state of the specified key on KONTAKT's keyboard either to pressed/on (1) or released/off (0)"
        },
        "set_key_pressed_support":
        {
            "snippet_string": "set_key_pressed_support( ${1:mode} )",
            "signature":   "set_key_pressed_support(mode)",
            "description": "sets the pressed state support mode for KONTAKT'S keyboard. The available modes are:\n0: KONTAKT handles all pressed states, set_key_pressed() commands are ignored (default mode)\n1: KONTAKT's keyboard is only affected by set_key_pressed() commands\n"
        },
        "set_key_type":
        {
            "snippet_string": "set_key_type( ${1:note-nr}, ${2:key-type-constant} )",
            "signature":   "set_key_type(note-nr,key-type-constant)",
            "description": "assigns a key type to the specified key.\nThe following key types are available:\n$NI_KEY_TYPE_DEFAULT (i.e. normal mapped notes that produce sound)\n$NI_KEY_TYPE_CONTROL (i.e. key switches or other notes that do not produce sound)\n$NI_KEY_TYPE_NONE (resets the key to its normal KONTAKT behaviour)\n"
        },
        "set_keyrange":
        {
            "snippet_string": "set_keyrange( ${1:min-note}, ${2:max-note}, ${3:name} )",
            "signature":   "set_keyrange(min-note,max-note,name)",
            "description": "assigns a text string to the specified range of keys."
        },
        "remove_keyrange":
        {
            "snippet_string": "remove_keyrange( ${1:note-nr} )",
            "signature":   "remove_keyrange(note-nr)",
            "description": "assigns a text string to the specified range of keys"
        },
        "find_mod":
        {
            "snippet_string": "find_mod( ${1:group-index}, ${2:mod-name} )",
            "signature":   "find_mod(group-index,mod-name)",
            "description": "returns the slot index of an internal modulator or external modulation slot"
        },
        "find_target":
        {
            "snippet_string": "find_target( ${1:group-index}, ${2:mod-index}, ${3:target-name} )",
            "signature":   "find_target(group-index,mod-index,target-name)",
            "description": "returns the slot index of a modulation slot of an internal modulator"
        },
        "_get_engine_par":
        {
            "snippet_string": "_get_engine_par( ${1:parameter}, ${2:group}, ${3:slot}, ${4:generic} )",
            "signature":   "_get_engine_par(parameter,group,slot,generic)",
            "description": "returns the value of a specific engine parameter"
        },
        "get_engine_par":
        {
            "snippet_string": "get_engine_par( ${1:parameter}, ${2:group}, ${3:slot}, ${4:generic} )",
            "signature":   "get_engine_par(parameter,group,slot,generic)",
            "description": "returns the value of a specific engine parameter"
        },
        "_get_engine_par_disp":
        {
            "snippet_string": "_get_engine_par_disp( ${1:parameter}, ${2:group}, ${3:slot}, ${4:generic} )",
            "signature":   "_get_engine_par_disp(parameter,group,slot,generic)",
            "description": "returns the displayed string of a specific engine parameter"
        },
        "get_engine_par_disp":
        {
            "snippet_string": "get_engine_par_disp( ${1:parameter}, ${2:group}, ${3:slot}, ${4:generic} )",
            "signature":   "get_engine_par_disp(parameter,group,slot,generic)",
            "description": "returns the displayed string of a specific engine parameter"
        },
        "get_voice_limit":
        {
            "snippet_string": "get_voice_limit( ${1:voice-type} )",
            "signature":   "get_voice_limit(voice-type)",
            "description": "retunrs the voice limit for the Time Machine Pro mode of the source module"
        },
        "output_channel_name":
        {
            "snippet_string": "output_channel_name( ${1:output-number} )",
            "signature":   "output_channel_name(output-number)",
            "description": "returns the channel name for the specified output"
        },
        "_set_engine_par":
        {
            "snippet_string": "_set_engine_par( ${1:parameter}, ${2:value}, ${3:group}, ${4:slot}, ${5:generic} )",
            "signature":   "_set_engine_par(parameter,value,group,slot,generic)",
            "description": "control automatable KONTAKT parameters and bypass buttons"
        },
        "set_engine_par":
        {
            "snippet_string": "set_engine_par( ${1:parameter}, ${2:value}, ${3:group}, ${4:slot}, ${5:generic} )",
            "signature":   "set_engine_par(parameter,value,group,slot,generic)",
            "description": "control automatable KONTAKT parameters and bypass buttons"
        },
        "set_voice_limit":
        {
            "snippet_string": "set_voice_limit( ${1:voice-type}, ${2:value} )",
            "signature":   "set_voice_limit(voice-type,value)",
            "description": "sets the voice limit for the Time Machine Pro mode of the source module"
        },
        "get_loop_par":
        {
            "snippet_string": "get_loop_par( ${1:zone-id}, ${2:loop-index}, ${3:parameter} )",
            "signature":   "get_loop_par(zone-id,loop_index,parameter)",
            "description": "Returns the loop parameters of a zone"
        },
        "get_loop_sample":
        {
            "snippet_string": "get_loop_par( ${1:zone-id}, ${2:return-parameter} )",
            "signature":   "get_sample(zone-id,return-parameter)",
            "description": "Returns paths, file names and extensions of samples"
        },
        "get_zone_par":
        {
            "snippet_string": "get_zone_par( ${1:zone-id}, ${2:parameter} )",
            "signature":   "get_zone_par(zone-id,parameter)",
            "description": "Returns the zone parameters"
        },
        "is_zone_empty":
        {
            "snippet_string": "is_zone_emptyr( ${1:zone-id} )",
            "signature":   "is_zone_empty(zone-id)",
            "description": "Returns 1 if a zone is empty (has no sample), otherwise returns 0"
        },
        "set_loop_par":
        {
            "snippet_string": "set_loop_par( ${1:zone-id}, ${2:loop-index}, ${3:parameter}, ${4:value} )",
            "signature":   "set_loop_par(zone-id,loop_index,parameter,value)",
            "description": "Sets the loop parameters of a user zone"
        },
        "set_num_user_zones":
        {
            "snippet_string": "set_num_user_zones(${1:number_of_user_zones} )",
            "signature":   "set_num_user_zones(number_of_user_zones)",
            "description": "Creates empty user zones"
        },
        "set_sample":
        {
            "snippet_string": "set_sample( ${1:zone-id}, ${2:sample-path} )",
            "signature":   "set_sample(zone-id,sample-path)",
            "description": "Sets the user sample in a zone"
        },
        "set_zone_par":
        {
            "snippet_string": "set_zone_par( ${1:zone-id}, ${2:parameter}, ${3:value} )",
            "signature":   "set_zone_par(zone-id,parameter,value)",
            "description": "Sets the user zone parameters"
        },
        "_get_folder":
        {
            "snippet_string": "_get_folder( ${1:path-variable} )",
            "signature":   "_get_folder(path-variable)",
            "description": "returns the path specified with the built-in path variable"
        },
        "get_folder":
        {
            "snippet_string": "get_folder( ${1:path-variable} )",
            "signature":   "get_folder(path-variable)",
            "description": "returns the path specified with the built-in path variable"
        },
        "load_array":
        {
            "snippet_string": "load_array( ${1:array-variable}, ${2:mode} )",
            "signature":   "load_array(array-variable,mode)",
            "description": "loads an array from an external file (.nka file)"
        },
        "load_array_str":
        {
            "snippet_string": "load_array_str( ${1:array-variable}, ${2:path} )",
            "signature":   "load_array_str(array-variable,path)",
            "description": "loads an array from an external file (.nka file) using the file's absolute path"
        },
        "_load_ir_sample":
        {
            "snippet_string": "_load_ir_sample( ${1:file-path}, ${2:slot}, ${3:generic} )",
            "signature":   "_load_ir_sample(file-path,slot,generic)",
            "description": "loads an impulse response sample into KONTAKT's convolution effect"
        },
        "load_ir_sample":
        {
            "snippet_string": "load_ir_sample( ${1:file-path}, ${2:slot}, ${3:generic} )",
            "signature":   "load_ir_sample(file-path,slot,generic)",
            "description": "loads an impulse response sample into KONTAKT's convolution effect"
        },
        "load_midi_file":
        {
            "snippet_string": "load_midi_file( ${1:path} )",
            "signature":   "load_midi_file(path)",
            "description": "Load MIDI file from path (*Non documented)"
        },
        "save_array":
        {
            "snippet_string": "save_array( ${1:array-variable}, ${2:mode} )",
            "signature":   "save_array(array-variable,mode)",
            "description": "saves an array to an external file (i.e. an .nka file)"
        },
        "save_array_str":
        {
            "snippet_string": "save_array_str( ${1:array-variable}, ${2:path} )",
            "signature":   "save_array_str(array-variable,path)",
            "description": "saves an array to an external file (i.e. an .nka file), using the specified absolute path"
        },
        "save_midi_file":
        {
            "snippet_string": "save_midi_file( ${1:path} )",
            "signature":   "save_midi_file(path)",
            "description": "saves a MIDI file with a range specified by the mf_set_export_area() command."
        },
        "detect_instrument_type":
        {
            "snippet_string": "detect_instrument_type( ${1:zone-id}, ${2:instrument-type-result} )",
            "signature":   "detect_instrument_type(zone-id,instrument-type-result)",
            "description": "Assigns <drum-type-result> a $NI_DETECT_INSTRUMENT_TYPE tag describing the in- strument type of an audio sample."
        },
        "detect_pitch":
        {
            "snippet_string": "detect_pitch( ${1:zone-id}, ${2:pitch-result} )",
            "signature":   "detect_pitch(zone-id,pitch-result)",
            "description": "Returns a real value representing the fundamental frequency of an audio sample, in semi- tones and cents"
        },
        "detect_loudness":
        {
            "snippet_string": "detect_loudness( ${1:zone-id}, ${2:loudness-result} )",
            "signature":   "detect_loudness(zone-id,loudness-result)",
            "description": "Returns a real value representing the loudness of an audio sample in dB."
        },
        "detect_peak":
        {
            "snippet_string": "detect_peak( ${1:zone-id}, ${2:peak-result} )",
            "signature":   "detect_peak(zone-id,peak-result)",
            "description": "Returns a real value representing peak level of an audio sample in dB."
        },
        "detect_rms":
        {
            "snippet_string": "detect_rms( ${1:zone-id}, ${2:rms-result} )",
            "signature":   "detect_rms(zone-id,rms-result)",
            "description": "Returns a real value representing the RMS level of an audio sample in dB."
        },
        "detect_sample_type":
        {
            "snippet_string": "detect_sample_type( ${1:zone-id}, ${2:sample-type-result} )",
            "signature":   "detect_sample_type(zone-id,sample-type-result)",
            "description": "Assigns <sample-type-result> a $NI_DETECT_SAMPLE_TYPE tag describing the whether an audio sample is a drum or an instrument."
        },
        "detect_drum_type":
        {
            "snippet_string": "detect_drum_type( ${1:zone-id}, ${2:drum-type-result} )",
            "signature":   "detect_drum_type(zone-id,drum-type-result)",
            "description": "Assigns <drum-type-result> a $NI_DETECT_DRUM_TYPE tag describing the drum type of an audio sample."
        },
        "mf_copy_export_area":
        {
            "snippet_string": "mf_copy_export_area( ${1:index} )",
            "signature":   "mf_insert_file(index)",
            "description": "Copies the content of MIDI export area 0 to the specified index."
        },
        "mf_insert_file":
        {
            "snippet_string": "mf_insert_file( ${1:path}, ${2:track-offset}, ${3:position-offset}, ${4:mode} )",
            "signature":   "mf_insert_file(path,track-offset,position-offset,mode)",
            "description": "inserts a MIDI file into the MIDI object."
        },
        "mf_set_export_area":
        {
            "snippet_string": "mf_set_export_area( ${1:name}, ${2:start-pos}, ${3:end-pos}, ${4:start-track}, ${5:end-track} )",
            "signature":   "mf_set_export_area(name,start-pos,end-pos,start-track,end-track)",
            "description": "defines the part of the MIDI object that will be exported when using a drag and drop area, or the save_midi_file() command."
        },
        "mf_set_buffer_size":
        {
            "snippet_string": "mf_set_buffer_size( ${1:size} )",
            "signature":   "mf_set_buffer_size(size)",
            "description": "defines a number of inactive MIDI events, that can be activated and edited"
        },
        "mf_get_buffer_size":
        {
            "snippet_string": "mf_get_buffer_size()",
            "signature":   "mf_get_buffer_size()",
            "description": "returns the size of the MIDI event buffer"
        },
        "mf_reset":
        {
            "snippet_string": "mf_reset()",
            "signature":   "mf_reset()",
            "description": "resets the MIDI object, sets the event buffer to zero, and removes all events"
        },
        "mf_insert_event":
        {
            "snippet_string": "mf_insert_event( ${1:track}, ${2:pos}, ${3:command}, ${4:byte1}, ${5:byte2} )",
            "signature":   "mf_insert_event(track,pos,command,byte1,byte2)",
            "description": "activates an inactive MIDI event in the MIDI object. However, because the command and position are defined in this command, it can be considered as an insertion."
        },
        "mf_remove_event":
        {
            "snippet_string": "mf_remove_event( ${1:event-id} )",
            "signature":   "mf_remove_event(event-id)",
            "description": "deactivates an event in the MIDI object, effectively removing it"
        },
        "mf_set_event_par":
        {
            "snippet_string": "mf_set_event_par( ${1:event-id}, ${2:parameter}, ${3:value} )",
            "signature":   "mf_set_event_par(event-id,parameter,value)",
            "description": "sets an event parameter"
        },
        "mf_get_event_par":
        {
            "snippet_string": "mf_get_event_par( ${1:event-id}, ${2:parameter} )",
            "signature":   "mf_get_event_par(event-id,parameter)",
            "description": "returns the value of an event parameter"
        },
        "mf_get_id":
        {
            "snippet_string": "mf_get_id()",
            "signature":   "mf_get_id()",
            "description": "returns the ID of the currently selected event (when using the navigation commands like mf_get_first(), and mf_get_next(), etc)"
        },
        "mf_set_mark":
        {
            "snippet_string": "mf_set_mark( ${1:event-id}, ${2:mark}, ${3:status} )",
            "signature":   "mf_set_mark(event-id,mark,status)",
            "description": "marks an event, so that you may groups events together and process that group quickly"
        },
        "mf_get_mark":
        {
            "snippet_string": "mf_get_mark( ${1:event-id}, ${2:mark} )",
            "signature":   "mf_get_mark(event-id,mark)",
            "description": "checks if an event is marked or not. Returns 1 if it is marked, or 0 if it is not."
        },
        "by_track":
        {
            "snippet_string": "by_track( ${1:track} )",
            "signature":   "by_track(track)",
            "description": "can be used to group events by their track number"
        },
        "mf_get_first":
        {
            "snippet_string": "mf_get_first( ${1:track-index} )",
            "signature":   "mf_get_first(track-index)",
            "description": "moves the position marker to the first event in the MIDI track"
        },
        "mf_get_last":
        {
            "snippet_string": "mf_get_last( ${1:track-index} )",
            "signature":   "mf_get_last(track-index)",
            "description": "moves the position marker to the last event in the MIDI track"
        },
        "mf_get_next":
        {
            "snippet_string": "mf_get_next( ${1:track-index} )",
            "signature":   "mf_get_next(track-index)",
            "description": "moves the position marker to the next event in the MIDI track"
        },
        "mf_get_next_at":
        {
            "snippet_string": "mf_get_next_at( ${1:track-index}, ${2:pos} )",
            "signature":   "mf_get_next_at(track-index,pos)",
            "description": "moves the position marker to the next event in the MIDI track right after the defined position."
        },
        "mf_get_prev":
        {
            "snippet_string": "mf_get_prev( ${1:track-index} )",
            "signature":   "mf_get_prev(track-index)",
            "description": "moves the position marker to the previous event in the MIDI track"
        },
        "mf_get_prev_at":
        {
            "snippet_string": "mf_get_prev_at( ${1:track-index}, ${2:pos} )",
            "signature":   "mf_get_prev_at(track-index,pos)",
            "description": "moves the position marker to the first event before the defined position"
        },
        "mf_get_num_tracks":
        {
            "snippet_string": "mf_get_num_tracks()",
            "signature":   "mf_get_num_tracks()",
            "description": "returns the number of tracks in a MIDI object."
        },
        "mf_set_pos":
        {
            "snippet_string": "mf_set_pos( ${1:value} )",
            "signature":   "mf_set_pos(value)",
            "description": "Non documented"
        },
        "mf_set_command":
        {
            "snippet_string": "mf_set_command( ${1:value} )",
            "signature":   "mf_set_command(value)",
            "description": "Non documented"
        },
        "mf_set_byte_one":
        {
            "snippet_string": "mf_set_byte_one( ${1:value} )",
            "signature":   "mf_set_byte_one(value)",
            "description": "Non documented"
        },
        "mf_set_byte_two":
        {
            "snippet_string": "mf_set_byte_two( ${1:value} )",
            "signature":   "mf_set_byte_two(value)",
            "description": "Non documented"
        },
        "mf_set_num_export_areas":
        {
            "snippet_string": "mf_set_num_export_areas( ${1:num} )",
            "signature":   "mf_set_num_export_areas(num)",
            "description": "Sets the number of export areas, with a maximum of 512."
        },
        "SET_CONDITION":
        {
            "snippet_string": "SET_CONDITION( ${1:condition-symbol} )",
            "signature":   "SET_CONDITION(condition-symbol)",
            "description": "define a symbol to be used as a condition"
        },
        "RESET_CONDITION":
        {
            "snippet_string": "RESET_CONDITION( ${1:condition-symbol} )",
            "signature":   "RESET_CONDITION(condition-symbol)",
            "description": "delete a definition"
        },
        "USE_CODE_IF":
        {
            "snippet_string": "USE_CODE_IF( ${1:condition-symbol} )",
            "signature":   "USE_CODE_IF(condition-symbol)",
            "description": "interpret code when <condition> is defined"
        },
        "USE_CODE_IF_NOT":
        {
            "snippet_string": "USE_CODE_IF_NOT( ${1:condition-symbol} )",
            "signature":   "USE_CODE_IF_NOT(condition-symbol)",
            "description": "interpret code when <condition> is not defined"
        },
        "END_USE_CODE":
        {
            "snippet_string": "END_USE_CODE",
            "signature":   "END_USE_CODE",
            "description": "end of USE_CODE_IF"
        },
        "NO_SYS_SCRIPT_GROUP_START":
        {
            "snippet_string": "NO_SYS_SCRIPT_GROUP_START",
            "signature":   "NO_SYS_SCRIPT_GROUP_START",
            "description": "condition; if defined with SET_CONDITION(), the system script which handles all group start options will be bypassed"
        },
        "NO_SYS_SCRIPT_PEDAL":
        {
            "snippet_string": "NO_SYS_SCRIPT_PEDAL",
            "signature":   "NO_SYS_SCRIPT_PEDAL",
            "description": "condition; if defined with SET_CONDITION(), the system script which sustains notes when CC# 64 is received will be bypassed"
        },
        "NO_SYS_SCRIPT_RLS_TRIG":
        {
            "snippet_string": "NO_SYS_SCRIPT_RLS_TRIG",
            "signature":   "NO_SYS_SCRIPT_RLS_TRIG",
            "description": "condition; if defined with SET_CONDITION(), the system script which triggers samples upon the release of a key is bypassed"
        },
        "_reset_rls_trig_counter":
        {
            "snippet_string": "_reset_rls_trig_counter( ${1:note} )",
            "signature":   "_reset_rls_trig_counter(note)",
            "description": "dresets the release trigger counter (used by the release trigger system script)"
        },
        "reset_rls_trig_counter":
        {
            "snippet_string": "reset_rls_trig_counter( ${1:note} )",
            "signature":   "reset_rls_trig_counter(note)",
            "description": "dresets the release trigger counter (used by the release trigger system script)"
        },
        "_will_never_terminate":
        {
            "snippet_string": "_will_never_terminate( ${1:event-id} )",
            "signature":   "_will_never_terminate(event-id)",
            "description": ""
        },
        "will_never_terminate":
        {
            "snippet_string": "will_never_terminate( ${1:event-id} )",
            "signature":   "will_never_terminate(event-id)",
            "description": ""
        },
        "_pgs_create_key":
        {
            "snippet_string": "_pgs_create_key( ${1:key-id}, ${2:size} )",
            "signature":   "_pgs_create_key(key-id,size)",
            "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script."
        },
        "pgs_create_key":
        {
            "snippet_string": "pgs_create_key( ${1:key-id}, ${2:size} )",
            "signature":   "pgs_create_key(key-id,size)",
            "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script."
        },
        "_pgs_key_exists":
        {
            "snippet_string": "_pgs_key_exists( ${1:key-id} )",
            "signature":   "_pgs_key_exists(key-id)",
            "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script."
        },
        "pgs_key_exists":
        {
            "snippet_string": "pgs_key_exists( ${1:key-id} )",
            "signature":   "pgs_key_exists(key-id)",
            "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script."
        },
        "_pgs_set_key_val":
        {
            "snippet_string": "_pgs_set_key_val( ${1:key-id}, ${2:index}, ${3:value} )",
            "signature":   "_pgs_set_key_val(key-id,index,value)",
            "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script."
        },
        "pgs_set_key_val":
        {
            "snippet_string": "pgs_set_key_val( ${1:key-id}, ${2:index}, ${3:value} )",
            "signature":   "pgs_set_key_val(key-id,index,value)",
            "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script."
        },
        "_pgs_get_key_val":
        {
            "snippet_string": "_pgs_get_key_val( ${1:key-id}, ${2:index} )",
            "signature":   "_pgs_get_key_val(key-id,index)",
            "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script."
        },
        "pgs_get_key_val":
        {
            "snippet_string": "pgs_get_key_val( ${1:key-id}, ${2:index} )",
            "signature":   "pgs_get_key_val(key-id,index)",
            "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script."
        },
        "pgs_create_str_key":
        {
            "snippet_string": "pgs_create_str_key( ${1:key-id} )",
            "signature":   "pgs_create_str_key(key-id)",
            "description": ""
        },
        "pgs_str_key_exists":
        {
            "snippet_string": "pgs_str_key_exists( ${1:key-id} )",
            "signature":   "pgs_str_key_exists(key-id)",
            "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script."
        },
        "pgs_set_str_key_val":
        {
            "snippet_string": "pgs_set_str_key_val( ${1:key-id}, ${2:stringvalue} )",
            "signature":   "pgs_set_str_key_val(key-id,stringvalue)",
            "description": ""
        },
        "find_zone":
        {
            "snippet_string": "find_zone( ${1:zone-name} )",
            "signature":   "find_zone(zone-name)",
            "description": "returns the zone ID for the specified zone name. Only availabe in the init callback."
        },
        "get_sample_length":
        {
            "snippet_string": "get_sample_length( ${1:zone-ID} )",
            "signature":   "get_sample_length(zone-ID)",
            "description": "returns the length of the specified zone's sample in microseconds"
        },
        "_slice_length":
        {
            "snippet_string": "_slice_length( ${1:zone-ID}, ${2:slice-index} )",
            "signature":   "_slice_length(zone-ID,slice-index)",
            "description": "returns the length in microseconds of the specified slice with respect to the current tempo"
        },
        "_slice_start":
        {
            "snippet_string": "_slice_start( ${1:zone-ID}, ${2:slice-index} )",
            "signature":   "_slice_start(zone-ID,slice-index)",
            "description": "returns the absolute start point of the specified slice in microseconds, independent of the current tempo"
        },
        "_slice_idx_loop_start":
        {
            "snippet_string": "_slice_idx_loop_start( ${1:zone-ID}, ${2:loop-index} )",
            "signature":   "_slice_idx_loop_start(zone-ID,loop-index)",
            "description": "returns the index number of the slice at the loop start"
        },
        "_slice_idx_loop_end":
        {
            "snippet_string": "_slice_idx_loop_end( ${1:zone-ID}, ${2:loop-index} )",
            "signature":   "_slice_idx_loop_end(zone-ID,loop-index)",
            "description": "returns the index number of the slice at the loop end"
        },
        "_slice_loop_count":
        {
            "snippet_string": "_slice_loop_count( ${1:zone-ID}, ${2:loop-index} )",
            "signature":   "_slice_loop_count(zone-ID,loop-index)",
            "description": "returns the loop count of the specified loop"
        },
        "num_slices_zone":
        {
            "snippet_string": "num_slices_zone( ${1:zone-ID} )",
            "signature":   "num_slices_zone(zone-ID)",
            "description": "returns the number of slices of the specified zone"
        },
        "zone_slice_length":
        {
            "snippet_string": "zone_slice_length( ${1:zone-ID}, ${2:slice-index} )",
            "signature":   "zone_slice_length(zone-ID,slice-index)",
            "description": "returns the length in microseconds of the specified slice with respect to the current tempo"
        },
        "zone_slice_start":
        {
            "snippet_string": "zone_slice_start( ${1:zone-ID}, ${2:slice-index} )",
            "signature":   "zone_slice_start(zone-ID,slice-index)",
            "description": "returns the absolute start point of the specified slice in microseconds, independent of the current tempo"
        },
        "zone_slice_idx_loop_start":
        {
            "snippet_string": "zone_slice_idx_loop_start( ${1:zone-ID}, ${2:loop-index} )",
            "signature":   "zone_slice_idx_loop_start(zone-ID,loop-index)",
            "description": "returns the index number of the slice at the loop start"
        },
        "zone_slice_idx_loop_end":
        {
            "snippet_string": "zone_slice_idx_loop_end( ${1:zone-ID}, ${2:loop-index} )",
            "signature":   "zone_slice_idx_loop_end(zone-ID,loop-index)",
            "description": "returns the index number of the slice at the loop end"
        },
        "zone_slice_loop_count":
        {
            "snippet_string": "zone_slice_loop_count( ${1:zone-ID}, ${2:loop-index} )",
            "signature":   "zone_slice_loop_count(zone-ID,loop-index)",
            "description": "returns the loop count of the specified loop"
        },
        "dont_use_machine_mode":
        {
            "snippet_string": "dont_use_machine_mode( ${1:ID-number} )",
            "signature":   "dont_use_machine_mode(ID-number)",
            "description": "play the specified event in sampler mode"
        },
        "function":
        {
            "snippet_string": "",
            "signature":   "",
            "description": "declares a function"
        },
        "call":
        {
            "snippet_string": "call ${1:functionName}",
            "signature":   "call functionName",
            "description": "calls a previously declares function"
        },
        "ignore_midi":
        {
            "snippet_string": "ignore_midi",
            "signature":   "ignore_midi",
            "description": "Like ignore_event(), ignore_midi is a very \"strong\" command. Keep in mind that ignore_midi will ignore all incoming MIDI events. If you simply want to change the MIDI channel and/or any of the MIDI bytes, you can also use set_event_par()."
        },
        "set_midi":
        {
            "snippet_string": "set_midi( ${1:channel}, ${2:command}, ${3:byte-1}, ${4:byte-2} )",
            "signature":   "set_midi(channel,command,byte1,byte2)",
            "description": "create any type of MIDI event. If you simply want to change the MIDI channel and/or any of the MIDI bytes, you can also use set_event_par()."
        },
        "watch_var":
        {
            "snippet_string": "watch_var( ${1:var} )",
            "signature":   "watch_var(var)",
            "description": "Variable watching through Creator Tools"
        },
        "watch_array_idx":
        {
            "snippet_string": "watch_array_idx( ${1:arr}, ${2:idx} )",
            "signature":   "watch_array_idx(arr,idx)",
            "description": "Variable watching through Creator Tools"
        },
        "disable_logging":
        {
            "snippet_string": "disable_logging( ${1:type} )",
            "signature":   "disable_logging(type)",
            "description": "Quickly disabling emission of messages, warnings or watched variable\nevents to both the Kontakt Status Bar\n$NI_LOG_MESSAGE, $NI_LOG_WARNING, $NI_LOG_WATCHING\n"
        },
        "_delay_event_for_loading_slots":
        {
            "snippet_string": "_delay_event_for_loading_slots( ${1:arg1} )",
            "signature":   "_delay_event_for_loading_slots(arg1)",
            "description": "Undocumented"
        },
        "cc_delivery_request":
        {
            "snippet_string": "cc_delivery_request( ${1:arg1} )",
            "signature":   "cc_delivery_request(arg1)",
            "description": "Undocumented"
        },
        "change_time_with_pitch":
        {
            "snippet_string": "change_time_with_pitch( ${1:arg1} )",
            "signature":   "change_time_with_pitch(arg1)",
            "description": "Undocumented"
        },
        "connect_view":
        {
            "snippet_string": "connect_view()",
            "signature":   "connect_view()",
            "description": "Undocumented"
        },
        "get_control_par_arr":
        {
            "snippet_string": "get_control_par_arr( ${1:arg1}, ${2:arg2}, ${3:arg3} )",
            "signature":   "get_control_par_arr(arg1,arg2},arg3)",
            "description": "Undocumented"
        },
        "get_control_par_str":
        {
            "snippet_string": "get_control_par_str( ${1:arg1}, ${2:arg2} )",
            "signature":   "get_control_par_str(arg1},arg2)",
            "description": "Undocumented"
        },
        "get_control_par_str_arr":
        {
            "snippet_string": "get_control_par_str_arr( ${1:arg1}, ${2:arg2}, ${3:arg3} )",
            "signature":   "get_control_par_str(arg1},arg2,arg3)",
            "description": "Undocumented"
        },
        "get_engine_par_disp_m":
        {
            "snippet_string": "get_engine_par_disp_m( ${1:arg1}, ${2:arg2}, ${3:arg3}, ${4:arg4} )",
            "signature":   "get_engine_par_disp_m(arg1,arg2},arg3,arg4)",
            "description": "Undocumented"
        },
        "get_engine_par_m":
        {
            "snippet_string": "get_engine_par_m( ${1:arg1}, ${2:arg2}, ${3:arg3}, ${4:arg4} )",
            "signature":   "get_engine_par_m(arg1,arg2,arg3,arg4)",
            "description": "Undocumented"
        },
        "load_ir_sample_m":
        {
            "snippet_string": "load_ir_sample_m( ${1:arg1} )",
            "signature":   "load_ir_sample_m(arg1)",
            "description": "Undocumented"
        },
        "load_patch":
        {
            "snippet_string": "load_patch( ${1:arg1}, ${2:arg2} )",
            "signature":   "load_patch(arg1,arg2)",
            "description": "Undocumented"
        },
        "mf_get_byte_one":
        {
            "snippet_string": "mf_get_byte_one()",
            "signature":   "mf_get_byte_one()",
            "description": "Undocumented"
        },
        "mf_get_byte_two":
        {
            "snippet_string": "mf_get_byte_two()",
            "signature":   "mf_get_byte_two()",
            "description": "Undocumented"
        },
        "mf_get_channel":
        {
            "snippet_string": "mf_get_channel()",
            "signature":   "mf_get_channel()",
            "description": "Undocumented"
        },
        "mf_get_command":
        {
            "snippet_string": "mf_get_command()",
            "signature":   "mf_get_command()",
            "description": "Undocumented"
        },
        "mf_get_note_length":
        {
            "snippet_string": "mf_get_note_length()",
            "signature":   "mf_get_note_length()",
            "description": "Undocumented"
        },
        "mf_get_pos":
        {
            "snippet_string": "mf_get_pos()",
            "signature":   "mf_get_pos()",
            "description": "Undocumented"
        },
        "mf_get_track_idx":
        {
            "snippet_string": "mf_get_track_idx()",
            "signature":   "mf_get_track_idx()",
            "description": "Undocumented"
        },
        "mf_set_channel":
        {
            "snippet_string": "mf_set_channel()",
            "signature":   "mf_set_channel()",
            "description": "Undocumented"
        },
        "_num_slices":
        {
            "snippet_string": "_num_slices( ${1:arg1} )",
            "signature":   "_num_slices(arg1)",
            "description": "Undocumented"
        },
        "num_slices":
        {
            "snippet_string": "num_slices( ${1:arg1} )",
            "signature":   "num_slices(arg1)",
            "description": "Undocumented"
        },
        "pgs_get_str_key_val":
        {
            "snippet_string": "pgs_get_str_key_val()",
            "signature":   "pgs_get_str_key_val()",
            "description": "Undocumented"
        },
        "redirect_midi":
        {
            "snippet_string": "redirect_midi( ${1:arg1} )",
            "signature":   "redirect_midi(arg1)",
            "description": "Undocumented"
        },
        "reset_engine":
        {
            "snippet_string": "reset_engine()",
            "signature":   "reset_engine()",
            "description": "Undocumented"
        },
        "set_engine_par_m":
        {
            "snippet_string": "set_engine_par_m( ${1:arg1}, ${2:arg2}, ${3:arg3}, ${4:arg4}, ${5:arg5} )",
            "signature":   "set_engine_par_m(arg1,arg2,arg3,arg4,arg5)",
            "description": "Undocumented"
        },
        "show_library_tab":
        {
            "snippet_string": "show_library_tab",
            "signature":   "show_library_tab",
            "description": "Undocumented"
        },
        "slice_idx_loop_end":
        {
            "snippet_string": "slice_idx_loop_end( ${1:arg1}, ${2:arg2} )",
            "signature":   "slice_idx_loop_end(arg1,arg2)",
            "description": "Undocumented"
        },
        "slice_idx_loop_start":
        {
            "snippet_string": "slice_idx_loop_start( ${1:arg1}, ${2:arg2} )",
            "signature":   "slice_idx_loop_start(arg1,arg2)",
            "description": "Undocumented"
        },
        "slice_length":
        {
            "snippet_string": "slice_length( ${1:arg1}, ${2:arg2} )",
            "signature":   "slice_length(arg1,arg2)",
            "description": "Undocumented"
        },
        "slice_loop_count":
        {
            "snippet_string": "slice_loop_count( ${1:arg1}, ${2:arg2} )",
            "signature":   "slice_loop_count(arg1,arg2)",
            "description": "Undocumented"
        },
        "slice_start":
        {
            "snippet_string": "slice_start( ${1:arg1}, ${2:arg2} )",
            "signature":   "slice_start(arg1,arg2)",
            "description": "Undocumented"
        },
        "unload_slot":
        {
            "snippet_string": "unload_slot( ${1:arg1} )",
            "signature":   "unload_slot(arg1)",
            "description": "Undocumented"
        }
};
